{"file_contents":{"backend/routes/audit.js":{"content":"const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst db = require('../db');\n\nconst router = express.Router();\n\nconst JWT_SECRET = 'real_user_auth_secret_2025';\n\nfunction getUserFromToken(req) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return null;\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch {\n    return null;\n  }\n}\n\nfunction canViewAuditLog(serverId, userId, callback) {\n  db.get('SELECT owner_id FROM servers WHERE id = ?', [serverId], (err, server) => {\n    if (err || !server) return callback(false);\n    if (server.owner_id === userId) return callback(true);\n    \n    db.all(`\n      SELECT sr.permissions FROM server_roles sr\n      JOIN server_member_roles smr ON sr.id = smr.role_id\n      WHERE smr.server_id = ? AND smr.user_id = ?\n    `, [serverId, userId], (err, roles) => {\n      if (err) return callback(false);\n      for (const role of roles) {\n        const perms = JSON.parse(role.permissions || '{}');\n        if (perms.administrator || perms.manage_server) {\n          return callback(true);\n        }\n      }\n      callback(false);\n    });\n  });\n}\n\nrouter.get('/server/:serverId', (req, res) => {\n  const user = getUserFromToken(req);\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const serverId = req.params.serverId;\n  const limit = parseInt(req.query.limit) || 50;\n  const offset = parseInt(req.query.offset) || 0;\n  const actionType = req.query.action_type;\n  \n  canViewAuditLog(serverId, user.userId, (canView) => {\n    if (!canView) return res.status(403).json({ error: 'No permission to view audit log' });\n    \n    let query = `\n      SELECT \n        al.*,\n        u.username as actor_username,\n        u.profile_picture as actor_picture\n      FROM audit_log al\n      JOIN users u ON al.actor_id = u.id\n      WHERE al.server_id = ?\n    `;\n    const params = [serverId];\n    \n    if (actionType) {\n      query += ' AND al.action_type = ?';\n      params.push(actionType);\n    }\n    \n    query += ' ORDER BY al.created_at DESC LIMIT ? OFFSET ?';\n    params.push(limit, offset);\n    \n    db.all(query, params, (err, logs) => {\n      if (err) return res.status(500).json({ error: 'Failed to load audit log' });\n      \n      const formatted = logs.map(log => ({\n        id: log.id,\n        actionType: log.action_type,\n        actor: {\n          id: log.actor_id,\n          username: log.actor_username,\n          profilePicture: log.actor_picture\n        },\n        targetType: log.target_type,\n        targetId: log.target_id,\n        changes: log.changes ? JSON.parse(log.changes) : null,\n        reason: log.reason,\n        createdAt: log.created_at\n      }));\n      \n      res.json(formatted);\n    });\n  });\n});\n\nrouter.get('/server/:serverId/stats', (req, res) => {\n  const user = getUserFromToken(req);\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const serverId = req.params.serverId;\n  \n  canViewAuditLog(serverId, user.userId, (canView) => {\n    if (!canView) return res.status(403).json({ error: 'No permission to view audit log' });\n    \n    db.all(`\n      SELECT action_type, COUNT(*) as count\n      FROM audit_log\n      WHERE server_id = ?\n      GROUP BY action_type\n      ORDER BY count DESC\n    `, [serverId], (err, stats) => {\n      if (err) return res.status(500).json({ error: 'Failed to load stats' });\n      \n      db.get('SELECT COUNT(*) as total FROM audit_log WHERE server_id = ?', [serverId], (err, total) => {\n        res.json({\n          total: total?.total || 0,\n          byAction: stats\n        });\n      });\n    });\n  });\n});\n\nrouter.get('/server/:serverId/user/:userId', (req, res) => {\n  const user = getUserFromToken(req);\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { serverId, userId } = req.params;\n  const limit = parseInt(req.query.limit) || 20;\n  \n  canViewAuditLog(serverId, user.userId, (canView) => {\n    if (!canView) return res.status(403).json({ error: 'No permission to view audit log' });\n    \n    db.all(`\n      SELECT \n        al.*,\n        u.username as actor_username\n      FROM audit_log al\n      JOIN users u ON al.actor_id = u.id\n      WHERE al.server_id = ? AND (al.actor_id = ? OR (al.target_type = 'user' AND al.target_id = ?))\n      ORDER BY al.created_at DESC\n      LIMIT ?\n    `, [serverId, userId, userId, limit], (err, logs) => {\n      if (err) return res.status(500).json({ error: 'Failed to load user audit log' });\n      \n      const formatted = logs.map(log => ({\n        id: log.id,\n        actionType: log.action_type,\n        actorUsername: log.actor_username,\n        targetType: log.target_type,\n        targetId: log.target_id,\n        changes: log.changes ? JSON.parse(log.changes) : null,\n        reason: log.reason,\n        createdAt: log.created_at\n      }));\n      \n      res.json(formatted);\n    });\n  });\n});\n\nconst ACTION_TYPES = {\n  ROLE_CREATE: 'Role created',\n  ROLE_UPDATE: 'Role updated',\n  ROLE_DELETE: 'Role deleted',\n  ROLE_ASSIGN: 'Role assigned to member',\n  ROLE_REMOVE: 'Role removed from member',\n  CHANNEL_CREATE: 'Channel created',\n  CHANNEL_UPDATE: 'Channel updated',\n  CHANNEL_DELETE: 'Channel deleted',\n  CATEGORY_CREATE: 'Category created',\n  CATEGORY_DELETE: 'Category deleted',\n  MEMBER_KICK: 'Member kicked',\n  MEMBER_BAN: 'Member banned',\n  MEMBER_UNBAN: 'Member unbanned',\n  MESSAGE_DELETE: 'Message deleted',\n  MESSAGE_PIN: 'Message pinned',\n  SERVER_UPDATE: 'Server settings updated',\n  INVITE_CREATE: 'Invite created',\n  INVITE_DELETE: 'Invite deleted'\n};\n\nrouter.get('/action-types', (req, res) => {\n  res.json(ACTION_TYPES);\n});\n\n// Global update log - tracks ALL updates across the entire system\nrouter.get('/global', (req, res) => {\n  const user = getUserFromToken(req);\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const limit = parseInt(req.query.limit) || 100;\n  const offset = parseInt(req.query.offset) || 0;\n  const updateType = req.query.type;\n  \n  // Check if user is admin\n  db.get('SELECT is_admin FROM users WHERE id = ?', [user.userId], (err, userData) => {\n    if (err || !userData?.is_admin) {\n      return res.status(403).json({ error: 'Admin access required' });\n    }\n    \n    let query = `\n      SELECT ul.*, u.username as actor_username\n      FROM update_log ul\n      LEFT JOIN users u ON ul.actor_id = u.id\n    `;\n    const params = [];\n    \n    if (updateType) {\n      query += ' WHERE ul.update_type = ?';\n      params.push(updateType);\n    }\n    \n    query += ' ORDER BY ul.created_at DESC LIMIT ? OFFSET ?';\n    params.push(limit, offset);\n    \n    db.all(query, params, (err, logs) => {\n      if (err) return res.status(500).json({ error: 'Failed to load update log' });\n      \n      const formatted = logs.map(log => ({\n        id: log.id,\n        updateType: log.update_type,\n        actor: {\n          id: log.actor_id,\n          username: log.actor_username\n        },\n        targetType: log.target_type,\n        targetId: log.target_id,\n        changes: log.changes ? JSON.parse(log.changes) : null,\n        description: log.description,\n        createdAt: log.created_at\n      }));\n      \n      res.json(formatted);\n    });\n  });\n});\n\n// Get update log stats\nrouter.get('/global/stats', (req, res) => {\n  const user = getUserFromToken(req);\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  \n  db.get('SELECT is_admin FROM users WHERE id = ?', [user.userId], (err, userData) => {\n    if (err || !userData?.is_admin) {\n      return res.status(403).json({ error: 'Admin access required' });\n    }\n    \n    db.all(`\n      SELECT update_type, COUNT(*) as count\n      FROM update_log\n      GROUP BY update_type\n      ORDER BY count DESC\n    `, (err, stats) => {\n      if (err) return res.status(500).json({ error: 'Failed to load stats' });\n      \n      db.get('SELECT COUNT(*) as total FROM update_log', (err, total) => {\n        res.json({\n          total: total?.total || 0,\n          byType: stats || []\n        });\n      });\n    });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":8049,"size_tokens":null},"backend/routes/reactions.js":{"content":"const express = require('express');\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst router = express.Router();\n\nfunction getUserId(req) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return null;\n  try {\n    const decoded = jwt.verify(token, 'real_user_auth_secret_2025');\n    return decoded.userId;\n  } catch {\n    return null;\n  }\n}\n\nrouter.get('/:messageId', (req, res) => {\n  const { messageId } = req.params;\n  \n  db.all(`\n    SELECT mr.*, u.username \n    FROM message_reactions mr\n    JOIN users u ON mr.user_id = u.id\n    WHERE mr.message_id = ?\n    ORDER BY mr.created_at ASC\n  `, [messageId], (err, reactions) => {\n    if (err) return res.status(500).json({ error: err.message });\n    \n    const grouped = {};\n    (reactions || []).forEach(r => {\n      if (!grouped[r.emoji]) {\n        grouped[r.emoji] = { emoji: r.emoji, count: 0, users: [], userIds: [] };\n      }\n      grouped[r.emoji].count++;\n      grouped[r.emoji].users.push(r.username);\n      grouped[r.emoji].userIds.push(r.user_id);\n    });\n    \n    res.json(Object.values(grouped));\n  });\n});\n\nrouter.post('/:messageId', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { messageId } = req.params;\n  const { emoji } = req.body;\n  \n  if (!emoji) return res.status(400).json({ error: 'Emoji required' });\n  \n  db.get('SELECT id FROM message_reactions WHERE message_id = ? AND user_id = ? AND emoji = ?',\n    [messageId, userId, emoji], (err, existing) => {\n      if (existing) {\n        db.run('DELETE FROM message_reactions WHERE id = ?', [existing.id], (err) => {\n          if (err) return res.status(500).json({ error: err.message });\n          res.json({ success: true, action: 'removed' });\n        });\n      } else {\n        db.run('INSERT INTO message_reactions (message_id, user_id, emoji) VALUES (?, ?, ?)',\n          [messageId, userId, emoji], function(err) {\n            if (err) return res.status(500).json({ error: err.message });\n            res.json({ success: true, action: 'added', reactionId: this.lastID });\n          });\n      }\n    });\n});\n\nrouter.delete('/:messageId/:emoji', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { messageId, emoji } = req.params;\n  \n  db.run('DELETE FROM message_reactions WHERE message_id = ? AND user_id = ? AND emoji = ?',\n    [messageId, userId, decodeURIComponent(emoji)], function(err) {\n      if (err) return res.status(500).json({ error: err.message });\n      res.json({ success: true, removed: this.changes > 0 });\n    });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":2700,"size_tokens":null},"frontend/js/transitions.js":{"content":"// Smooth Page Transitions\n(function() {\n  // Wait for DOM to be ready\n  document.addEventListener('DOMContentLoaded', function() {\n    // Add click handler to all internal links\n    document.querySelectorAll('a[href]').forEach(function(link) {\n      // Skip external links, anchor links, and special links\n      const href = link.getAttribute('href');\n      if (!href || \n          href.startsWith('#') || \n          href.startsWith('http') || \n          href.startsWith('//') ||\n          link.getAttribute('target') === '_blank' ||\n          link.hasAttribute('download')) {\n        return;\n      }\n      \n      link.addEventListener('click', function(e) {\n        e.preventDefault();\n        const destination = this.href;\n        \n        // Add exit animation class\n        document.body.classList.add('page-exit');\n        \n        // Navigate after animation completes\n        setTimeout(function() {\n          window.location.href = destination;\n        }, 280);\n      });\n    });\n    \n    // Handle browser back/forward buttons\n    window.addEventListener('pageshow', function(event) {\n      if (event.persisted) {\n        // Page was loaded from cache (back/forward)\n        document.body.classList.remove('page-exit');\n      }\n    });\n  });\n  \n  // Smooth transition for dashboard cards\n  const cards = document.querySelectorAll('.dashboard-card');\n  cards.forEach(function(card, index) {\n    card.style.animationDelay = (index * 0.08) + 's';\n  });\n  \n  // Stagger animation for game cards\n  const gameCards = document.querySelectorAll('.game-card');\n  gameCards.forEach(function(card, index) {\n    card.style.animationDelay = (index * 0.03) + 's';\n  });\n})();\n","path":null,"size_bytes":1673,"size_tokens":null},"frontend/css/chat.css":{"content":".chat-app {\n  display: grid;\n  grid-template-columns: 200px 1fr 250px;\n  grid-template-rows: 1fr;\n  height: 100vh;\n  background: var(--bg);\n  color: var(--text);\n}\n\n.chat-main {\n  display: flex;\n  flex-direction: column;\n  background: var(--bg);\n  height: 100%;\n  overflow: hidden;\n}\n\n.chat-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 20px;\n  border-bottom: 2px solid var(--accent);\n  background: var(--card);\n}\n\n.messages-container {\n  flex: 1;\n  overflow-y: auto;\n  padding: 20px;\n  display: flex;\n  flex-direction: column;\n  gap: 10px;\n}\n\n.welcome {\n  text-align: center;\n  color: var(--text-light);\n  padding: 40px;\n  font-size: 16px;\n}\n\n.message {\n  display: flex;\n  gap: 12px;\n  padding: 12px;\n  background: var(--card);\n  border-radius: 8px;\n  animation: slideIn 0.2s ease;\n}\n\n@keyframes slideIn {\n  from {\n    opacity: 0;\n    transform: translateY(10px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n.message-avatar {\n  width: 36px;\n  height: 36px;\n  border-radius: 50%;\n  object-fit: cover;\n  border: 2px solid var(--accent);\n}\n\n.message-content {\n  flex: 1;\n}\n\n.message-header {\n  display: flex;\n  justify-content: space-between;\n  margin-bottom: 4px;\n  font-size: 12px;\n}\n\n.message-username {\n  font-weight: 600;\n  color: var(--primary);\n}\n\n.message-timestamp {\n  color: var(--text-light);\n}\n\n.message-text {\n  color: var(--text);\n  word-wrap: break-word;\n}\n\n.message-input {\n  display: flex;\n  align-items: center;\n  gap: 10px;\n  padding: 15px;\n  background: var(--card);\n  border-top: 2px solid var(--accent);\n  flex-shrink: 0;\n  z-index: 10;\n}\n\n.mentions-dropdown {\n  position: absolute;\n  bottom: 100%;\n  left: 60px;\n  right: 60px;\n  max-height: 200px;\n  overflow-y: auto;\n  background: var(--card);\n  border: 1px solid var(--accent);\n  border-radius: 8px;\n  box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);\n  display: none;\n  z-index: 100;\n}\n\n.mentions-dropdown.active {\n  display: block;\n}\n\n.mention-item {\n  display: flex;\n  align-items: center;\n  gap: 10px;\n  padding: 10px 15px;\n  cursor: pointer;\n  transition: background 0.2s;\n}\n\n.mention-item:hover,\n.mention-item.selected {\n  background: var(--accent);\n}\n\n.mention-item img {\n  width: 28px;\n  height: 28px;\n  border-radius: 50%;\n  object-fit: cover;\n}\n\n.mention-item .mention-name {\n  color: var(--text);\n  font-weight: 500;\n}\n\n.mention-item .mention-status {\n  font-size: 12px;\n  color: var(--text-secondary);\n}\n\n#messageInput {\n  flex: 1;\n  padding: 12px;\n  background: var(--bg);\n  color: var(--text);\n  border: 1px solid var(--accent);\n  border-radius: 6px;\n  font-family: 'Inter', sans-serif;\n}\n\n#messageInput:focus {\n  outline: none;\n  box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.2);\n}\n\n#sendBtn {\n  padding: 12px 20px;\n  background: linear-gradient(135deg, var(--primary), var(--accent));\n  color: var(--bg);\n  border: none;\n  border-radius: 6px;\n  cursor: pointer;\n  font-weight: 600;\n  transition: transform 0.2s;\n}\n\n#sendBtn:hover {\n  transform: scale(1.05);\n}\n\n/* Sidebars */\n.sidebar {\n  background: var(--card);\n  border: 1px solid var(--accent);\n  padding: 15px;\n  overflow-y: auto;\n}\n\n.servers-sidebar {\n  border-right: 2px solid var(--accent);\n}\n\n.users-sidebar {\n  border-left: 2px solid var(--accent);\n}\n\n.sidebar-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 15px;\n  padding-bottom: 10px;\n  border-bottom: 1px solid var(--accent);\n}\n\n.sidebar-header h3 {\n  margin: 0;\n  font-size: 14px;\n  color: var(--primary);\n}\n\n.add-btn {\n  padding: 6px 12px;\n  background: var(--accent);\n  color: var(--bg);\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n  font-weight: 600;\n  font-size: 12px;\n  transition: all 0.2s;\n}\n\n.add-btn:hover {\n  transform: scale(1.05);\n}\n\n.servers-list,\n.friends-list,\n.users-list {\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n}\n\n.server-btn,\n.channel-btn,\n.friend-btn {\n  padding: 10px;\n  background: var(--bg);\n  color: var(--text);\n  border: 1px solid var(--accent);\n  border-radius: 6px;\n  cursor: pointer;\n  text-align: left;\n  transition: all 0.2s;\n  font-family: 'Inter', sans-serif;\n}\n\n.server-btn:hover,\n.channel-btn:hover,\n.friend-btn:hover {\n  background: var(--accent);\n  color: var(--bg);\n}\n\n.server-btn.active,\n.channel-btn.active,\n.friend-btn.active {\n  background: var(--accent);\n  color: var(--bg);\n  font-weight: 600;\n}\n\n.sidebar-divider {\n  height: 1px;\n  background: var(--accent);\n  margin: 15px 0;\n}\n\n.back-btn {\n  padding: 8px 16px;\n  background: transparent;\n  color: var(--primary);\n  border: 1px solid var(--accent);\n  border-radius: 4px;\n  cursor: pointer;\n  transition: all 0.2s;\n}\n\n.back-btn:hover {\n  background: var(--accent);\n  color: var(--bg);\n}\n\n/* Discord Features Styles */\n\n/* Message Actions */\n.message {\n  position: relative;\n}\n\n.message:hover .msg-actions {\n  opacity: 1;\n}\n\n.msg-actions {\n  position: absolute;\n  top: 8px;\n  right: 8px;\n  display: flex;\n  gap: 4px;\n  opacity: 0;\n  transition: opacity 0.2s;\n  background: var(--card);\n  padding: 4px;\n  border-radius: 6px;\n  box-shadow: 0 2px 8px rgba(0,0,0,0.2);\n}\n\n.msg-action-btn {\n  width: 28px;\n  height: 28px;\n  background: var(--bg);\n  border: 1px solid var(--accent);\n  border-radius: 4px;\n  cursor: pointer;\n  font-size: 14px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.2s;\n}\n\n.msg-action-btn:hover {\n  background: var(--accent);\n  transform: scale(1.1);\n}\n\n/* Reactions */\n.msg-reactions {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 6px;\n  margin-top: 6px;\n}\n\n.msg-reaction {\n  padding: 4px 8px;\n  background: var(--bg);\n  border: 1px solid var(--accent);\n  border-radius: 12px;\n  cursor: pointer;\n  font-size: 13px;\n  transition: all 0.2s;\n}\n\n.msg-reaction:hover {\n  background: var(--accent);\n}\n\n.msg-reaction.user-reacted {\n  background: var(--primary);\n  color: white;\n  border-color: var(--primary);\n}\n\n/* Reply Preview */\n.msg-reply-preview {\n  background: var(--bg);\n  padding: 6px 10px;\n  border-radius: 6px;\n  font-size: 12px;\n  color: var(--text-light);\n  margin-bottom: 6px;\n  border-left: 3px solid var(--primary);\n  cursor: pointer;\n}\n\n.msg-reply-preview:hover {\n  background: var(--accent);\n}\n\n/* Attachments */\n.msg-attachment {\n  margin-top: 8px;\n}\n\n.msg-attachment img {\n  max-width: 300px;\n  max-height: 200px;\n  border-radius: 8px;\n  cursor: pointer;\n  transition: transform 0.2s;\n}\n\n.msg-attachment img:hover {\n  transform: scale(1.02);\n}\n\n.msg-attachment a {\n  display: inline-flex;\n  align-items: center;\n  gap: 6px;\n  padding: 8px 12px;\n  background: var(--bg);\n  border: 1px solid var(--accent);\n  border-radius: 6px;\n  color: var(--primary);\n  text-decoration: none;\n}\n\n.msg-attachment a:hover {\n  background: var(--accent);\n}\n\n/* Edited Message */\n.msg-edited {\n  font-size: 11px;\n  color: var(--text-light);\n  margin-left: 6px;\n}\n\n/* Mentions */\n.mention {\n  background: rgba(114, 137, 218, 0.2);\n  color: var(--primary);\n  padding: 0 4px;\n  border-radius: 4px;\n  cursor: pointer;\n  font-weight: 500;\n}\n\n.mention:hover {\n  background: rgba(114, 137, 218, 0.4);\n}\n\n/* Typing Indicator */\n.typing-indicator {\n  padding: 0 20px;\n  font-size: 13px;\n  color: var(--text-light);\n  height: 0;\n  overflow: hidden;\n  transition: all 0.2s;\n}\n\n.typing-indicator.active {\n  height: 24px;\n  padding: 4px 20px;\n}\n\n/* Reply Bar */\n.reply-bar {\n  display: none;\n  align-items: center;\n  gap: 10px;\n  padding: 8px 20px;\n  background: var(--card);\n  border-top: 1px solid var(--accent);\n  font-size: 13px;\n}\n\n.reply-bar.active {\n  display: flex;\n}\n\n.reply-bar .reply-content {\n  flex: 1;\n  color: var(--text-light);\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.cancel-reply {\n  background: none;\n  border: none;\n  color: var(--text-light);\n  font-size: 18px;\n  cursor: pointer;\n  padding: 0 8px;\n}\n\n.cancel-reply:hover {\n  color: #e74c3c;\n}\n\n/* File Upload Button */\n.upload-btn {\n  width: 36px;\n  height: 36px;\n  background: var(--bg);\n  border: 1px solid var(--accent);\n  border-radius: 6px;\n  cursor: pointer;\n  font-size: 18px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.2s;\n}\n\n.upload-btn:hover {\n  background: var(--accent);\n}\n\n/* Emoji Picker */\n.emoji-picker {\n  position: absolute;\n  bottom: 60px;\n  right: 20px;\n  background: var(--card);\n  border: 1px solid var(--accent);\n  border-radius: 8px;\n  padding: 10px;\n  display: none;\n  box-shadow: 0 4px 16px rgba(0,0,0,0.2);\n  z-index: 100;\n}\n\n.emoji-picker.active {\n  display: block;\n}\n\n.emoji-grid {\n  display: grid;\n  grid-template-columns: repeat(6, 1fr);\n  gap: 4px;\n  max-width: 200px;\n}\n\n.emoji-btn {\n  width: 32px;\n  height: 32px;\n  background: none;\n  border: none;\n  font-size: 20px;\n  cursor: pointer;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n\n.emoji-btn:hover {\n  background: var(--accent);\n  transform: scale(1.2);\n}\n\n/* Search Modal */\n.search-modal {\n  display: none;\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  background: var(--card);\n  padding: 20px;\n  border-radius: 12px;\n  width: 90%;\n  max-width: 500px;\n  max-height: 80vh;\n  overflow: hidden;\n  z-index: 1001;\n  box-shadow: 0 8px 32px rgba(0,0,0,0.3);\n}\n\n.search-modal.active {\n  display: block;\n}\n\n.search-input {\n  width: 100%;\n  padding: 12px;\n  background: var(--bg);\n  border: 1px solid var(--accent);\n  border-radius: 6px;\n  color: var(--text);\n  font-size: 14px;\n  margin-bottom: 15px;\n}\n\n.search-input:focus {\n  outline: none;\n  border-color: var(--primary);\n}\n\n.search-results {\n  max-height: 400px;\n  overflow-y: auto;\n}\n\n.search-result {\n  padding: 12px;\n  background: var(--bg);\n  border-radius: 6px;\n  margin-bottom: 8px;\n  cursor: pointer;\n  transition: all 0.2s;\n}\n\n.search-result:hover {\n  background: var(--accent);\n}\n\n/* Invite Modal */\n.invite-modal {\n  display: none;\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  background: var(--card);\n  padding: 20px;\n  border-radius: 12px;\n  width: 90%;\n  max-width: 350px;\n  z-index: 1001;\n  box-shadow: 0 8px 32px rgba(0,0,0,0.3);\n}\n\n.invite-modal.active {\n  display: block;\n}\n\n.invite-code {\n  font-family: 'Courier New', monospace;\n  font-size: 24px;\n  font-weight: bold;\n  text-align: center;\n  background: var(--bg);\n  padding: 20px;\n  border-radius: 8px;\n  margin: 15px 0;\n  letter-spacing: 4px;\n  color: var(--primary);\n  border: 2px dashed var(--accent);\n}\n\n/* Unread Badge */\n.unread-badge {\n  position: absolute;\n  top: -4px;\n  right: -4px;\n  min-width: 18px;\n  height: 18px;\n  background: #e74c3c;\n  color: white;\n  font-size: 11px;\n  font-weight: bold;\n  border-radius: 10px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 0 4px;\n}\n\n/* Header Buttons */\n.pins-btn, .search-btn {\n  width: 32px;\n  height: 32px;\n  background: var(--bg);\n  border: 1px solid var(--accent);\n  border-radius: 6px;\n  cursor: pointer;\n  font-size: 16px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.2s;\n}\n\n.pins-btn:hover, .search-btn:hover {\n  background: var(--accent);\n}\n\n/* Flash animation for jump to message */\n@keyframes flash {\n  0%, 100% { background: var(--card); }\n  50% { background: var(--primary); }\n}\n\n/* Server buttons with relative positioning for badges */\n.server-btn, .channel-btn, .friend-btn {\n  position: relative;\n}\n\n/* Server Settings Modal */\n.server-settings-modal {\n  display: none;\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  background: var(--card);\n  border-radius: 12px;\n  width: 90%;\n  max-width: 900px;\n  height: 80vh;\n  max-height: 600px;\n  z-index: 1001;\n  box-shadow: 0 8px 32px rgba(0,0,0,0.4);\n  overflow: hidden;\n  display: none;\n  flex-direction: column;\n}\n\n.server-settings-modal.active {\n  display: flex;\n}\n\n.settings-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 20px;\n  border-bottom: 1px solid var(--accent);\n}\n\n.settings-header h2 {\n  margin: 0;\n  color: var(--text);\n}\n\n.settings-header .close-btn {\n  background: none;\n  border: none;\n  color: var(--text-light);\n  font-size: 28px;\n  cursor: pointer;\n}\n\n.settings-header .close-btn:hover {\n  color: #e74c3c;\n}\n\n.settings-tabs {\n  display: flex;\n  border-bottom: 1px solid var(--accent);\n  padding: 0 20px;\n}\n\n.settings-tab {\n  padding: 12px 20px;\n  background: none;\n  border: none;\n  color: var(--text-light);\n  cursor: pointer;\n  border-bottom: 2px solid transparent;\n  transition: all 0.2s;\n}\n\n.settings-tab:hover {\n  color: var(--text);\n}\n\n.settings-tab.active {\n  color: var(--primary);\n  border-bottom-color: var(--primary);\n}\n\n.settings-content {\n  flex: 1;\n  overflow: hidden;\n}\n\n.settings-panel {\n  display: none;\n  height: 100%;\n  overflow-y: auto;\n}\n\n.settings-panel.active {\n  display: flex;\n}\n\n/* Roles Panel */\n#rolesPanel {\n  display: none;\n}\n\n#rolesPanel.active {\n  display: flex;\n}\n\n.roles-sidebar {\n  width: 200px;\n  border-right: 1px solid var(--accent);\n  padding: 15px;\n  overflow-y: auto;\n}\n\n.create-role-btn {\n  width: 100%;\n  padding: 10px;\n  background: var(--primary);\n  color: white;\n  border: none;\n  border-radius: 6px;\n  cursor: pointer;\n  margin-bottom: 15px;\n  font-weight: 600;\n}\n\n.create-role-btn:hover {\n  opacity: 0.9;\n}\n\n.roles-list {\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n}\n\n.role-item {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  padding: 10px;\n  border-radius: 6px;\n  cursor: pointer;\n  transition: background 0.2s;\n}\n\n.role-item:hover {\n  background: var(--bg);\n}\n\n.role-item.active {\n  background: var(--accent);\n}\n\n.role-color {\n  width: 12px;\n  height: 12px;\n  border-radius: 50%;\n}\n\n.role-name {\n  flex: 1;\n  color: var(--text);\n  font-size: 14px;\n}\n\n.role-editor {\n  flex: 1;\n  padding: 20px;\n  overflow-y: auto;\n}\n\n.no-role-selected {\n  color: var(--text-light);\n  text-align: center;\n  padding: 40px;\n}\n\n.role-form {\n  display: flex;\n  flex-direction: column;\n  gap: 20px;\n}\n\n.role-form .form-group {\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n}\n\n.role-form label {\n  color: var(--text);\n  font-weight: 600;\n  font-size: 14px;\n}\n\n.role-form input[type=\"text\"],\n.role-form input[type=\"color\"] {\n  padding: 10px;\n  background: var(--bg);\n  border: 1px solid var(--accent);\n  border-radius: 6px;\n  color: var(--text);\n}\n\n.permissions-grid {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  gap: 10px;\n}\n\n.permission-item {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  padding: 8px;\n  background: var(--bg);\n  border-radius: 6px;\n}\n\n.permission-item label {\n  flex: 1;\n  font-weight: normal;\n  font-size: 13px;\n}\n\n.role-actions {\n  display: flex;\n  gap: 10px;\n  margin-top: 20px;\n}\n\n.role-actions button {\n  padding: 10px 20px;\n  border: none;\n  border-radius: 6px;\n  cursor: pointer;\n  font-weight: 600;\n}\n\n.save-role-btn {\n  background: var(--primary);\n  color: white;\n}\n\n.delete-role-btn {\n  background: #e74c3c;\n  color: white;\n}\n\n/* Categories Panel */\n.categories-list {\n  padding: 15px;\n  display: flex;\n  flex-direction: column;\n  gap: 10px;\n}\n\n.category-item {\n  display: flex;\n  align-items: center;\n  gap: 10px;\n  padding: 12px;\n  background: var(--bg);\n  border-radius: 6px;\n}\n\n.category-item input {\n  flex: 1;\n  padding: 8px;\n  background: var(--card);\n  border: 1px solid var(--accent);\n  border-radius: 4px;\n  color: var(--text);\n}\n\n.category-item button {\n  padding: 8px 12px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n\n/* Members Panel */\n.members-search {\n  padding: 15px;\n  border-bottom: 1px solid var(--accent);\n}\n\n.members-search input {\n  width: 100%;\n  padding: 10px;\n  background: var(--bg);\n  border: 1px solid var(--accent);\n  border-radius: 6px;\n  color: var(--text);\n}\n\n.members-list {\n  padding: 15px;\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n  overflow-y: auto;\n}\n\n.member-item {\n  display: flex;\n  align-items: center;\n  gap: 12px;\n  padding: 10px;\n  background: var(--bg);\n  border-radius: 6px;\n}\n\n.member-item img {\n  width: 36px;\n  height: 36px;\n  border-radius: 50%;\n}\n\n.member-info {\n  flex: 1;\n}\n\n.member-name {\n  color: var(--text);\n  font-weight: 500;\n}\n\n.member-roles {\n  display: flex;\n  gap: 4px;\n  flex-wrap: wrap;\n  margin-top: 4px;\n}\n\n.member-role-tag {\n  font-size: 11px;\n  padding: 2px 6px;\n  border-radius: 3px;\n  background: var(--accent);\n}\n\n/* Audit Log Panel */\n.audit-list {\n  padding: 15px;\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n}\n\n.audit-item {\n  padding: 12px;\n  background: var(--bg);\n  border-radius: 6px;\n  display: flex;\n  gap: 12px;\n}\n\n.audit-item img {\n  width: 32px;\n  height: 32px;\n  border-radius: 50%;\n}\n\n.audit-info {\n  flex: 1;\n}\n\n.audit-action {\n  color: var(--text);\n  font-size: 14px;\n}\n\n.audit-time {\n  color: var(--text-light);\n  font-size: 12px;\n  margin-top: 4px;\n}\n","path":null,"size_bytes":16787,"size_tokens":null},"frontend/js/chat.js":{"content":"// Chat page\nlet socket;\nlet currentUser;\nlet currentChannel = null;\nlet currentFriend = null;\nlet currentGroupChat = null;\nlet isGlobalChat = false;\nlet messageOffset = 0;\nlet isLoadingMessages = false;\nlet hasMoreMessages = true;\nlet currentMessageEndpoint = null;\nlet userInfoCache = {};\nlet isAdmin = false;\nlet eventListenersInitialized = false;\nlet friendNicknames = {};\nlet lastMessageId = 0;\nlet messagePollingInterval = null;\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  console.log('[CHAT] DOMContentLoaded - starting initialization');\n  currentUser = checkAuth();\n  console.log('[CHAT] currentUser:', currentUser);\n  if (!currentUser) {\n    console.log('[CHAT] No current user, exiting');\n    return;\n  }\n\n  console.log('[CHAT] Calling initSocket...');\n  initSocket();\n  loadServers();\n  loadGroupChats();\n  loadPendingRequests();\n  loadFriendNicknames();\n  loadFriends();\n  setupEventListeners();\n  setupGlobalChat();\n  checkAdminStatus();\n  \n  // Add scroll listener for infinite load of older messages\n  const container = document.getElementById('messagesContainer');\n  container.addEventListener('scroll', () => {\n    if (container.scrollTop < 150 && hasMoreMessages && !isLoadingMessages) {\n      loadMessages(true);\n    }\n  });\n  \n  // Poll for new messages every 3 seconds\n  startMessagePolling();\n  \n  // Refresh pending requests every 10 seconds\n  setInterval(loadPendingRequests, 10000);\n});\n\n// Message polling for new messages every 3 seconds\nfunction startMessagePolling() {\n  if (messagePollingInterval) clearInterval(messagePollingInterval);\n  messagePollingInterval = setInterval(pollNewMessages, 3000);\n}\n\nfunction pollNewMessages() {\n  if (!currentMessageEndpoint || isLoadingMessages) return;\n  \n  fetch(`${currentMessageEndpoint}?after=${lastMessageId}`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(messages => {\n      if (messages && messages.length > 0) {\n        messages.forEach(msg => {\n          if (msg.id > lastMessageId) {\n            // Check if message already exists in DOM\n            if (!document.querySelector(`[data-msg-id=\"${msg.id}\"]`)) {\n              displayMessage(msg, true);\n            }\n            lastMessageId = Math.max(lastMessageId, msg.id);\n          }\n        });\n      }\n    })\n    .catch(() => {});\n}\n\n// Check if current user is admin\nfunction checkAdminStatus() {\n  fetch('/api/admin/check', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      isAdmin = data.isAdmin;\n      if (isAdmin) {\n        document.getElementById('adminSection').style.display = 'block';\n        setupAdminPanel();\n      }\n    });\n}\n\n// Setup admin panel\nlet adminPanelInitialized = false;\nfunction setupAdminPanel() {\n  if (adminPanelInitialized) return;\n  adminPanelInitialized = true;\n  \n  const openBtn = document.getElementById('openAdminBtn');\n  const closeBtn = document.getElementById('closeAdminBtn');\n  const overlay = document.getElementById('adminOverlay');\n  const panel = document.getElementById('adminPanel');\n  const tabs = document.querySelectorAll('.admin-tab');\n  \n  openBtn.addEventListener('click', () => {\n    overlay.classList.add('active');\n    panel.classList.add('active');\n    loadAdminUsers();\n    loadServerRequests();\n  });\n  \n  closeBtn.addEventListener('click', closeAdminPanel);\n  overlay.addEventListener('click', closeAdminPanel);\n  \n  tabs.forEach(tab => {\n    tab.addEventListener('click', () => {\n      tabs.forEach(t => t.classList.remove('active'));\n      tab.classList.add('active');\n      document.querySelectorAll('.admin-content').forEach(c => c.classList.remove('active'));\n      document.getElementById(tab.dataset.tab + 'Tab').classList.add('active');\n    });\n  });\n}\n\nfunction closeAdminPanel() {\n  document.getElementById('adminOverlay').classList.remove('active');\n  document.getElementById('adminPanel').classList.remove('active');\n}\n\n// Load all users for admin\nfunction loadAdminUsers() {\n  fetch('/api/admin/users', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(users => {\n      const list = document.getElementById('adminUsersList');\n      list.innerHTML = '';\n      \n      users.forEach(user => {\n        const row = document.createElement('div');\n        row.className = 'user-row';\n        \n        // Check if user is currently banned (ban_until is in the future)\n        const isBanned = user.ban_until && new Date(user.ban_until) > new Date();\n        const banTimeLeft = isBanned ? getTimeRemaining(new Date(user.ban_until)) : '';\n        \n        let badges = '';\n        if (user.role === 'admin') badges += '<span class=\"badge-admin\">ADMIN</span>';\n        if (isBanned) badges += `<span class=\"badge-banned\">BANNED (${banTimeLeft})</span>`;\n        if (user.warning_count > 0) badges += `<span class=\"badge-warn\">${user.warning_count} warns</span>`;\n        \n        let actions = '';\n        if (user.role !== 'admin') {\n          if (isBanned) {\n            actions = `<button class=\"btn-unban\" onclick=\"unbanUser(${user.id})\">Unban</button>`;\n          } else {\n            actions = `\n              <button class=\"btn-warn\" onclick=\"warnUser(${user.id}, '${escapeHtml(user.username)}')\">Warn</button>\n              <button class=\"btn-ban\" onclick=\"banUser(${user.id}, '${escapeHtml(user.username)}')\">Ban</button>\n            `;\n          }\n          if (user.warning_count > 0) {\n            actions += `<button onclick=\"clearWarnings(${user.id})\" style=\"background:#3498db;color:white;\">Clear</button>`;\n          }\n        }\n        \n        row.innerHTML = `\n          <img src=\"${user.profile_picture || 'https://via.placeholder.com/36'}\" alt=\"\">\n          <div class=\"info\">\n            <div class=\"name\">${escapeHtml(user.username)}${badges}</div>\n            <div class=\"status\">${user.is_online ? 'Online' : 'Offline'} - Joined ${new Date(user.created_at).toLocaleDateString()}</div>\n            ${isBanned && user.ban_reason ? `<div class=\"status\" style=\"color:#e74c3c;\">Reason: ${escapeHtml(user.ban_reason)}</div>` : ''}\n          </div>\n          <div class=\"actions\">${actions}</div>\n        `;\n        list.appendChild(row);\n      });\n    });\n}\n\n// Load server requests for admin\nfunction loadServerRequests() {\n  fetch('/api/admin/server-requests', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(requests => {\n      const list = document.getElementById('serverRequestsList');\n      list.innerHTML = requests.length === 0 \n        ? '<p style=\"color: var(--text-light);\">No pending server requests</p>'\n        : '';\n      \n      requests.forEach(req => {\n        const row = document.createElement('div');\n        row.className = 'request-row';\n        row.innerHTML = `\n          <h4>${escapeHtml(req.server_name)}</h4>\n          <p>Requested by: ${escapeHtml(req.username)} - ${new Date(req.created_at).toLocaleDateString()}</p>\n          <p>${req.description ? escapeHtml(req.description) : 'No description'}</p>\n          <div style=\"display:flex;gap:10px;\">\n            <button class=\"btn-approve\" onclick=\"approveServer(${req.id})\">Approve</button>\n            <button class=\"btn-deny\" onclick=\"denyServer(${req.id})\">Deny</button>\n          </div>\n        `;\n        list.appendChild(row);\n      });\n    });\n}\n\n// Admin actions\nfunction warnUser(userId, username) {\n  const reason = prompt(`Warn ${username}. Enter reason:`);\n  if (!reason) return;\n  \n  fetch(`/api/admin/warn/${userId}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}`\n    },\n    body: JSON.stringify({ reason })\n  })\n    .then(r => r.json())\n    .then(data => {\n      alert(data.message);\n      loadAdminUsers();\n    });\n}\n\nfunction banUser(userId, username) {\n  const duration = prompt(`Ban ${username} from chatting.\\n\\nEnter duration (e.g., \"30 minutes\", \"1 hour\", \"2 days\"):`);\n  if (!duration) return;\n  \n  const reason = prompt(`Enter reason for banning ${username}:`) || 'No reason provided';\n  \n  fetch(`/api/admin/ban/${userId}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}`\n    },\n    body: JSON.stringify({ reason, duration })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.error) {\n        alert('Error: ' + data.error);\n      } else {\n        alert(data.message);\n        loadAdminUsers();\n      }\n    });\n}\n\nfunction unbanUser(userId) {\n  fetch(`/api/admin/unban/${userId}`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      alert(data.message);\n      loadAdminUsers();\n    });\n}\n\nfunction clearWarnings(userId) {\n  fetch(`/api/admin/clear-warnings/${userId}`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      alert(data.message);\n      loadAdminUsers();\n    });\n}\n\nfunction approveServer(requestId) {\n  fetch(`/api/admin/approve-server/${requestId}`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      alert('Server approved!');\n      loadServerRequests();\n      loadServers();\n    });\n}\n\nfunction denyServer(requestId) {\n  fetch(`/api/admin/deny-server/${requestId}`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(() => {\n      alert('Server request denied');\n      loadServerRequests();\n    });\n}\n\n// Group chats\nlet currentGroupChatData = null;\nlet currentServerData = null;\n\nfunction loadGroupChats() {\n  fetch(`/api/messages/user/${currentUser.id}/group-chats`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(groups => {\n      const list = document.getElementById('groupChatsList');\n      list.innerHTML = '';\n      groups.forEach(group => {\n        const container = document.createElement('div');\n        container.className = 'group-item';\n        container.style.cssText = 'display: flex; align-items: center; gap: 5px; margin-bottom: 2px;';\n        \n        const btn = document.createElement('button');\n        btn.className = 'server-btn';\n        btn.style.cssText = 'flex: 1;';\n        btn.textContent = group.name || 'Group Chat';\n        btn.addEventListener('click', () => selectGroupChat(group));\n        \n        const isOwner = group.owner_id === currentUser.id;\n        \n        const optBtn = document.createElement('button');\n        optBtn.textContent = 'âš™';\n        optBtn.title = isOwner ? 'Manage Group' : 'Leave Group';\n        optBtn.style.cssText = 'padding: 5px 8px; background: var(--accent); border: none; border-radius: 4px; cursor: pointer; font-size: 12px;';\n        optBtn.addEventListener('click', (e) => {\n          e.stopPropagation();\n          showGroupChatOptions(group, isOwner);\n        });\n        \n        container.appendChild(btn);\n        container.appendChild(optBtn);\n        list.appendChild(container);\n      });\n    });\n}\n\nfunction selectGroupChat(group) {\n  currentGroupChat = group.id;\n  currentGroupChatData = group;\n  currentChannel = null;\n  currentFriend = null;\n  isGlobalChat = false;\n  messageOffset = 0;\n  hasMoreMessages = true;\n  document.getElementById('chatTitle').textContent = group.name || 'Group Chat';\n  document.getElementById('globalChatBtn').classList.remove('active');\n  currentMessageEndpoint = `/api/messages/group/${group.id}`;\n  socket.emit('join_group', { groupChatId: group.id });\n  loadMessages();\n}\n\nfunction showGroupChatOptions(group, isOwner) {\n  if (isOwner) {\n    const action = prompt(`Manage \"${group.name}\":\\n\\n1 - View/Kick Members\\n2 - Invite Friends\\n3 - Delete Group Chat\\n\\nEnter 1-3:`);\n    if (action === '1') {\n      manageGroupChatMembers(group);\n    } else if (action === '2') {\n      showInviteFriendsModal('group', group.id, group.name);\n    } else if (action === '3') {\n      if (confirm(`Are you sure you want to DELETE \"${group.name}\"? This cannot be undone.`)) {\n        deleteGroupChat(group.id);\n      }\n    }\n  } else {\n    const action = prompt(`\"${group.name}\" Options:\\n\\n1 - Invite Friends\\n2 - Leave Group Chat\\n\\nEnter 1 or 2:`);\n    if (action === '1') {\n      showInviteFriendsModal('group', group.id, group.name);\n    } else if (action === '2') {\n      if (confirm(`Leave \"${group.name}\"?`)) {\n        leaveGroupChat(group.id);\n      }\n    }\n  }\n}\n\nfunction manageGroupChatMembers(group) {\n  fetch(`/api/messages/group-chat/${group.id}/details`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      const memberList = data.members.map((m, i) => \n        `${i + 1}. ${m.username}${m.id === group.owner_id ? ' (Owner)' : ''}`\n      ).join('\\n');\n      \n      const choice = prompt(`Members of \"${group.name}\":\\n\\n${memberList}\\n\\nEnter member number to kick (or cancel):`);\n      if (choice) {\n        const idx = parseInt(choice) - 1;\n        if (idx >= 0 && idx < data.members.length) {\n          const member = data.members[idx];\n          if (member.id === currentUser.id) {\n            alert('Cannot kick yourself!');\n            return;\n          }\n          if (confirm(`Kick ${member.username} from the group?`)) {\n            kickFromGroupChat(group.id, member.id);\n          }\n        }\n      }\n    });\n}\n\nfunction leaveGroupChat(groupChatId) {\n  fetch(`/api/messages/group-chat/${groupChatId}/leave`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.error) {\n        alert(data.error);\n      } else {\n        alert('Left group chat');\n        loadGroupChats();\n        if (currentGroupChat === groupChatId) {\n          currentGroupChat = null;\n          document.getElementById('messagesContainer').innerHTML = '<div class=\"welcome\">Select a chat to start messaging</div>';\n          document.getElementById('chatTitle').textContent = 'Chat';\n        }\n      }\n    });\n}\n\nfunction deleteGroupChat(groupChatId) {\n  fetch(`/api/messages/group-chat/${groupChatId}`, {\n    method: 'DELETE',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.error) {\n        alert(data.error);\n      } else {\n        alert('Group chat deleted');\n        loadGroupChats();\n        if (currentGroupChat === groupChatId) {\n          currentGroupChat = null;\n          document.getElementById('messagesContainer').innerHTML = '<div class=\"welcome\">Select a chat to start messaging</div>';\n          document.getElementById('chatTitle').textContent = 'Chat';\n        }\n      }\n    });\n}\n\nfunction kickFromGroupChat(groupChatId, userId) {\n  fetch(`/api/messages/group-chat/${groupChatId}/kick/${userId}`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.error) {\n        alert(data.error);\n      } else {\n        alert('Member kicked');\n      }\n    });\n}\n\nfunction createGroupChat() {\n  currentChannel = null;\n  currentFriend = null;\n  currentGroupChat = null;\n  isGlobalChat = false;\n  \n  const container = document.getElementById('messagesContainer');\n  const header = document.getElementById('chatTitle');\n  \n  if (header) header.textContent = 'Create Group Chat';\n  \n  container.innerHTML = `\n    <div style=\"padding:40px;max-width:600px;margin:0 auto;\">\n      <h2 style=\"color:var(--text);margin-bottom:10px;font-size:20px;\">CREATE A GROUP CHAT</h2>\n      <p style=\"color:var(--text-light);margin-bottom:20px;font-size:14px;\">Start a group conversation with multiple friends!</p>\n      \n      <div style=\"margin-bottom:15px;\">\n        <label style=\"display:block;color:var(--text);font-weight:600;margin-bottom:8px;font-size:13px;\">GROUP NAME</label>\n        <input type=\"text\" id=\"createGroupNameInput\" placeholder=\"My Group Chat\" \n          style=\"width:100%;padding:12px 16px;background:var(--bg);border:1px solid var(--accent);border-radius:8px;color:var(--text);font-size:14px;\">\n      </div>\n      \n      <div style=\"margin-bottom:20px;\">\n        <label style=\"display:block;color:var(--text);font-weight:600;margin-bottom:8px;font-size:13px;\">MEMBERS (comma-separated usernames)</label>\n        <input type=\"text\" id=\"createGroupMembersInput\" placeholder=\"friend1, friend2, friend3\" \n          style=\"width:100%;padding:12px 16px;background:var(--bg);border:1px solid var(--accent);border-radius:8px;color:var(--text);font-size:14px;\">\n      </div>\n      \n      <button onclick=\"submitGroupChat()\" \n        style=\"width:100%;padding:14px;background:var(--primary);color:white;border:none;border-radius:8px;font-weight:600;cursor:pointer;font-size:15px;\">\n        Create Group Chat\n      </button>\n      \n      <div id=\"createGroupResult\" style=\"padding:12px;border-radius:8px;display:none;margin-top:15px;\"></div>\n    </div>\n  `;\n  \n  document.getElementById('createGroupNameInput').focus();\n}\n\nfunction submitGroupChat() {\n  const nameInput = document.getElementById('createGroupNameInput');\n  const membersInput = document.getElementById('createGroupMembersInput');\n  const resultDiv = document.getElementById('createGroupResult');\n  \n  const name = nameInput.value.trim();\n  const memberNames = membersInput.value.split(',').map(s => s.trim()).filter(s => s);\n  \n  if (!name) {\n    resultDiv.style.display = 'block';\n    resultDiv.style.background = 'rgba(231, 76, 60, 0.2)';\n    resultDiv.style.color = '#e74c3c';\n    resultDiv.textContent = 'Please enter a group name';\n    return;\n  }\n  \n  if (memberNames.length === 0) {\n    resultDiv.style.display = 'block';\n    resultDiv.style.background = 'rgba(231, 76, 60, 0.2)';\n    resultDiv.style.color = '#e74c3c';\n    resultDiv.textContent = 'Please add at least one member';\n    return;\n  }\n  \n  // Get user IDs from usernames\n  Promise.all(memberNames.map(username => \n    fetch(`/api/users/search?username=${encodeURIComponent(username)}`, {\n      headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n    }).then(r => r.json())\n  ))\n    .then(results => {\n      const memberIds = [currentUser.id];\n      results.forEach(r => {\n        if (r && r.id) memberIds.push(r.id);\n      });\n      \n      return fetch('/api/messages/group-chat', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${getAuthToken()}`\n        },\n        body: JSON.stringify({ name, memberIds })\n      });\n    })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        resultDiv.style.display = 'block';\n        resultDiv.style.background = 'rgba(46, 204, 113, 0.2)';\n        resultDiv.style.color = '#2ecc71';\n        resultDiv.textContent = 'âœ… Group chat created!';\n        nameInput.value = '';\n        membersInput.value = '';\n        loadGroupChats();\n      }\n    })\n    .catch(() => {\n      resultDiv.style.display = 'block';\n      resultDiv.style.background = 'rgba(231, 76, 60, 0.2)';\n      resultDiv.style.color = '#e74c3c';\n      resultDiv.textContent = 'âŒ Failed to create group chat';\n    });\n}\n\nlet socketInitialized = false;\nfunction initSocket() {\n  if (socketInitialized) return;\n  socketInitialized = true;\n  \n  socket = io({ \n    transports: ['websocket', 'polling'],\n    reconnection: true,\n    reconnectionAttempts: 5\n  });\n  \n  socket.on('connect_error', (err) => {\n    console.error('[SOCKET] Connection error:', err.message);\n  });\n\n  socket.on('connect', () => {\n    console.log('[SOCKET] Connected successfully! Socket ID:', socket.id);\n    socket.emit('user_join', { userId: currentUser.id });\n  });\n  \n  socket.on('disconnect', (reason) => {\n    console.log('[SOCKET] Disconnected:', reason);\n  });\n\n  socket.on('new_message', (message) => {\n    // Check if message is for current channel/friend/group/global\n    // For DMs, check both directions: I sent to friend OR friend sent to me\n    const isDMRelevant = currentFriend && (\n      (message.dmPartnerId === currentFriend && message.user_id === currentUser.id) ||\n      (message.user_id === currentFriend)\n    );\n    const isRelevant = (message.channel_id === currentChannel) || \n                       isDMRelevant || \n                       (message.groupChatId === currentGroupChat) ||\n                       (message.isGlobal && isGlobalChat);\n    if (isRelevant) {\n      displayMessage(message, true);\n    }\n    \n    // Send desktop notification only if message is NOT for the current view and NOT from current user\n    if (message.user_id !== currentUser.id && !isRelevant) {\n      // Check notification settings\n      const mutedServers = JSON.parse(localStorage.getItem('mutedServers') || '[]');\n      const mutedUsers = JSON.parse(localStorage.getItem('mutedUsers') || '[]');\n      const notificationsEnabled = localStorage.getItem('chatNotifications') !== 'false';\n      \n      // Check if server or user is muted\n      const serverMuted = message.server_id && mutedServers.includes(message.server_id);\n      const userMuted = mutedUsers.includes(message.user_id);\n      \n      if (notificationsEnabled && !serverMuted && !userMuted) {\n        // Send notification to parent (desktop)\n        const notifData = {\n          type: 'chatNotification',\n          title: message.username || 'New Message',\n          body: message.content ? (message.content.length > 50 ? message.content.substring(0, 50) + '...' : message.content) : 'Sent an attachment',\n          icon: 'ðŸ’¬',\n          serverId: message.server_id,\n          channelId: message.channel_id,\n          userId: message.user_id\n        };\n        \n        // Post to parent window (desktop)\n        if (window.parent && window.parent !== window) {\n          window.parent.postMessage(notifData, '*');\n        }\n      }\n    }\n  });\n\n  socket.on('message_deleted', (data) => {\n    const msgId = data.messageId || data;\n    document.querySelector(`[data-msg-id=\"${msgId}\"]`)?.remove();\n  });\n  \n  // Handle message errors (ban, admin-only servers, etc.)\n  socket.on('message_error', (data) => {\n    if (data.banUntil) {\n      const banDate = new Date(data.banUntil);\n      showBanNotice(banDate);\n    } else {\n      alert(data.error || 'Unable to send message');\n    }\n  });\n  \n  // Handle warning notifications\n  socket.on('user_warned', (data) => {\n    if (data.userId === currentUser.id) {\n      showWarningNotice(data.warningCount, data.reason);\n    }\n  });\n  \n  // Handle ban notifications\n  socket.on('user_banned', (data) => {\n    if (data.userId === currentUser.id) {\n      const banDate = new Date(data.banUntil);\n      showBanNotice(banDate, data.reason, data.duration);\n    }\n  });\n  \n  // Handle permanent ban notifications\n  socket.on('user_permabanned', (data) => {\n    if (data.userId === currentUser.id) {\n      showPermaBanNotice(data.reason);\n    }\n  });\n  \n  // Handle server approval notification\n  socket.on('server_approved', (data) => {\n    if (data.userId === currentUser.id) {\n      loadServers();\n      showServerSetupModal({ id: data.serverId, name: data.serverName });\n    }\n  });\n}\n\n// Show warning notice to user\nfunction showWarningNotice(warningCount, reason) {\n  const existing = document.getElementById('warningNotice');\n  if (existing) existing.remove();\n  \n  const notice = document.createElement('div');\n  notice.id = 'warningNotice';\n  notice.style.cssText = `\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    background: linear-gradient(135deg, #f39c12, #e67e22);\n    color: white;\n    padding: 30px 40px;\n    border-radius: 15px;\n    z-index: 2000;\n    text-align: center;\n    box-shadow: 0 10px 40px rgba(0,0,0,0.5);\n    font-weight: 600;\n    animation: warningPulse 0.5s ease-out;\n    max-width: 400px;\n  `;\n  notice.innerHTML = `\n    <div style=\"font-size: 40px; margin-bottom: 15px;\">âš ï¸</div>\n    <div style=\"font-size: 22px; margin-bottom: 10px;\">You have been warned.</div>\n    <div style=\"font-size: 28px; color: #fff; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); margin-bottom: 15px;\">(${warningCount}/3)</div>\n    <div style=\"font-size: 16px; opacity: 0.95; margin-bottom: 10px;\">3/3 = PermBan</div>\n    <div style=\"font-size: 13px; opacity: 0.8; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px; margin-top: 15px;\">\n      Reason: ${escapeHtml(reason)}\n    </div>\n    <button onclick=\"this.parentElement.remove()\" style=\"margin-top: 20px; padding: 10px 30px; background: white; color: #e67e22; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;\">\n      I Understand\n    </button>\n  `;\n  \n  // Add animation styles\n  if (!document.getElementById('warningStyles')) {\n    const style = document.createElement('style');\n    style.id = 'warningStyles';\n    style.textContent = `\n      @keyframes warningPulse {\n        0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }\n        50% { transform: translate(-50%, -50%) scale(1.05); }\n        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }\n      }\n    `;\n    document.head.appendChild(style);\n  }\n  \n  document.body.appendChild(notice);\n  \n  // Add overlay\n  const overlay = document.createElement('div');\n  overlay.id = 'warningOverlay';\n  overlay.style.cssText = `\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(0,0,0,0.7);\n    z-index: 1999;\n  `;\n  overlay.onclick = () => {\n    overlay.remove();\n    notice.remove();\n  };\n  document.body.appendChild(overlay);\n}\n\n// Show permanent ban notice\nfunction showPermaBanNotice(reason) {\n  const existing = document.getElementById('permaBanNotice');\n  if (existing) existing.remove();\n  \n  const notice = document.createElement('div');\n  notice.id = 'permaBanNotice';\n  notice.style.cssText = `\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    background: linear-gradient(135deg, #c0392b, #8e1d1d);\n    color: white;\n    padding: 40px 50px;\n    border-radius: 15px;\n    z-index: 2000;\n    text-align: center;\n    box-shadow: 0 10px 40px rgba(0,0,0,0.6);\n    font-weight: 600;\n    animation: warningPulse 0.5s ease-out;\n    max-width: 450px;\n  `;\n  notice.innerHTML = `\n    <div style=\"font-size: 50px; margin-bottom: 15px;\">ðŸš«</div>\n    <div style=\"font-size: 26px; margin-bottom: 10px;\">PERMANENTLY BANNED</div>\n    <div style=\"font-size: 18px; opacity: 0.9; margin-bottom: 15px;\">You have received 3/3 warnings</div>\n    <div style=\"font-size: 14px; opacity: 0.8; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px;\">\n      ${escapeHtml(reason)}\n    </div>\n    <div style=\"font-size: 12px; opacity: 0.7; margin-top: 15px;\">\n      You can no longer send messages. Contact an admin to appeal.\n    </div>\n  `;\n  \n  document.body.appendChild(notice);\n  \n  // Add overlay\n  const overlay = document.createElement('div');\n  overlay.id = 'permaBanOverlay';\n  overlay.style.cssText = `\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(0,0,0,0.8);\n    z-index: 1999;\n  `;\n  document.body.appendChild(overlay);\n}\n\n// Show ban notice to user\nfunction showBanNotice(banUntil, reason, duration) {\n  const existing = document.getElementById('banNotice');\n  if (existing) existing.remove();\n  \n  const timeLeft = getTimeRemaining(banUntil);\n  const notice = document.createElement('div');\n  notice.id = 'banNotice';\n  notice.style.cssText = `\n    position: fixed;\n    bottom: 80px;\n    left: 50%;\n    transform: translateX(-50%);\n    background: linear-gradient(135deg, #e74c3c, #c0392b);\n    color: white;\n    padding: 20px 30px;\n    border-radius: 12px;\n    z-index: 1000;\n    text-align: center;\n    box-shadow: 0 4px 20px rgba(0,0,0,0.4);\n    font-weight: 600;\n    max-width: 350px;\n  `;\n  notice.innerHTML = `\n    <div style=\"font-size: 16px; margin-bottom: 8px;\">ðŸš« You have been banned from chatting</div>\n    <div style=\"font-size: 13px; opacity: 0.9; margin-bottom: 5px;\">Duration: ${duration || timeLeft}</div>\n    <div style=\"font-size: 12px; opacity: 0.85; margin-bottom: 8px;\">Time remaining: ${timeLeft}</div>\n    ${reason ? `<div style=\"font-size: 11px; opacity: 0.8; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 6px;\">Reason: ${escapeHtml(reason)}</div>` : ''}\n    <div style=\"font-size: 10px; opacity: 0.7; margin-top: 8px;\">You can still access games, movies, and other features</div>\n  `;\n  document.body.appendChild(notice);\n  \n  // Auto-remove after 8 seconds\n  setTimeout(() => notice.remove(), 8000);\n}\n\n// Get time remaining in human readable format\nfunction getTimeRemaining(banUntil) {\n  const now = new Date();\n  const diff = banUntil - now;\n  \n  if (diff <= 0) return 'Expired';\n  \n  const minutes = Math.floor(diff / 60000);\n  const hours = Math.floor(minutes / 60);\n  const days = Math.floor(hours / 24);\n  \n  if (days > 0) return `${days} day${days > 1 ? 's' : ''} ${hours % 24} hour${hours % 24 !== 1 ? 's' : ''}`;\n  if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ${minutes % 60} minute${minutes % 60 !== 1 ? 's' : ''}`;\n  return `${minutes} minute${minutes !== 1 ? 's' : ''}`;\n}\n\nlet mentionUsers = [];\nlet selectedMentionIndex = 0;\nlet mentionStartPos = -1;\n\nfunction setupEventListeners() {\n  if (eventListenersInitialized) return;\n  eventListenersInitialized = true;\n  \n  document.getElementById('sendBtn').addEventListener('click', sendMessage);\n  \n  const messageInput = document.getElementById('messageInput');\n  messageInput.addEventListener('keypress', (e) => {\n    if (e.key === 'Enter' && !document.getElementById('mentionsDropdown').classList.contains('active')) {\n      sendMessage();\n    }\n  });\n  \n  messageInput.addEventListener('input', handleMentionInput);\n  messageInput.addEventListener('keydown', handleMentionKeydown);\n  \n  document.getElementById('addServerBtn').addEventListener('click', createServerRequest);\n  document.getElementById('joinServerBtn').addEventListener('click', openJoinServerModal);\n  document.getElementById('addFriendBtn').addEventListener('click', addFriend);\n  document.getElementById('createGroupBtn').addEventListener('click', createGroupChat);\n  \n  document.addEventListener('click', (e) => {\n    if (!e.target.closest('.mentions-dropdown') && !e.target.closest('#messageInput')) {\n      closeMentionsDropdown();\n    }\n  });\n}\n\nfunction handleMentionInput(e) {\n  const input = e.target;\n  const value = input.value;\n  const cursorPos = input.selectionStart;\n  \n  const textBeforeCursor = value.substring(0, cursorPos);\n  const atMatch = textBeforeCursor.match(/@(\\w*)$/);\n  \n  if (atMatch) {\n    mentionStartPos = cursorPos - atMatch[0].length;\n    const searchTerm = atMatch[1].toLowerCase();\n    showMentionsDropdown(searchTerm);\n  } else {\n    closeMentionsDropdown();\n  }\n}\n\nfunction handleMentionKeydown(e) {\n  const dropdown = document.getElementById('mentionsDropdown');\n  if (!dropdown.classList.contains('active')) return;\n  \n  const items = dropdown.querySelectorAll('.mention-item');\n  \n  if (e.key === 'ArrowDown') {\n    e.preventDefault();\n    selectedMentionIndex = Math.min(selectedMentionIndex + 1, items.length - 1);\n    updateMentionSelection(items);\n  } else if (e.key === 'ArrowUp') {\n    e.preventDefault();\n    selectedMentionIndex = Math.max(selectedMentionIndex - 1, 0);\n    updateMentionSelection(items);\n  } else if (e.key === 'Enter' || e.key === 'Tab') {\n    e.preventDefault();\n    if (items[selectedMentionIndex]) {\n      selectMention(mentionUsers[selectedMentionIndex]);\n    }\n  } else if (e.key === 'Escape') {\n    closeMentionsDropdown();\n  }\n}\n\nfunction updateMentionSelection(items) {\n  items.forEach((item, i) => {\n    item.classList.toggle('selected', i === selectedMentionIndex);\n  });\n  if (items[selectedMentionIndex]) {\n    items[selectedMentionIndex].scrollIntoView({ block: 'nearest' });\n  }\n}\n\nfunction showMentionsDropdown(searchTerm) {\n  const dropdown = document.getElementById('mentionsDropdown');\n  \n  let users = [];\n  if (currentServerData && currentServerData.members) {\n    users = currentServerData.members;\n  } else if (currentGroupChatData && currentGroupChatData.members) {\n    users = currentGroupChatData.members;\n  } else {\n    fetch('/api/users/online', {\n      headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n    })\n      .then(r => r.json())\n      .then(onlineUsers => {\n        mentionUsers = onlineUsers.filter(u => \n          u.username.toLowerCase().includes(searchTerm) && u.id !== currentUser.id\n        ).slice(0, 8);\n        renderMentionsDropdown();\n      })\n      .catch(() => {});\n    return;\n  }\n  \n  mentionUsers = users.filter(u => \n    u.username.toLowerCase().includes(searchTerm) && u.id !== currentUser.id\n  ).slice(0, 8);\n  \n  renderMentionsDropdown();\n}\n\nfunction renderMentionsDropdown() {\n  const dropdown = document.getElementById('mentionsDropdown');\n  \n  if (mentionUsers.length === 0) {\n    closeMentionsDropdown();\n    return;\n  }\n  \n  selectedMentionIndex = 0;\n  \n  dropdown.innerHTML = mentionUsers.map((user, i) => `\n    <div class=\"mention-item ${i === 0 ? 'selected' : ''}\" data-index=\"${i}\" onclick=\"selectMention(mentionUsers[${i}])\">\n      <img src=\"${user.profile_picture || 'https://via.placeholder.com/28'}\" alt=\"\">\n      <div>\n        <div class=\"mention-name\">${escapeHtml(user.username)}</div>\n        <div class=\"mention-status\">${user.is_online ? 'Online' : 'Offline'}</div>\n      </div>\n    </div>\n  `).join('');\n  \n  dropdown.classList.add('active');\n}\n\nfunction selectMention(user) {\n  const input = document.getElementById('messageInput');\n  const value = input.value;\n  \n  const before = value.substring(0, mentionStartPos);\n  const after = value.substring(input.selectionStart);\n  \n  input.value = before + '@' + user.username + ' ' + after;\n  input.focus();\n  \n  const newPos = mentionStartPos + user.username.length + 2;\n  input.setSelectionRange(newPos, newPos);\n  \n  closeMentionsDropdown();\n}\n\nfunction closeMentionsDropdown() {\n  const dropdown = document.getElementById('mentionsDropdown');\n  dropdown.classList.remove('active');\n  dropdown.innerHTML = '';\n  mentionStartPos = -1;\n}\n\n// Setup Global Chat\nlet globalChatInitialized = false;\nfunction setupGlobalChat() {\n  if (globalChatInitialized) return;\n  globalChatInitialized = true;\n  \n  const globalBtn = document.getElementById('globalChatBtn');\n  if (globalBtn) {\n    globalBtn.addEventListener('click', selectGlobalChat);\n  }\n}\n\n// Select Global Chat\nfunction selectGlobalChat() {\n  console.log('[DEBUG] selectGlobalChat called');\n  \n  // Reset other chat contexts\n  currentChannel = null;\n  currentFriend = null;\n  currentGroupChat = null;\n  isGlobalChat = true;\n  messageOffset = 0;\n  hasMoreMessages = true;\n  isLoadingMessages = false; // Reset loading state\n  \n  // Update UI\n  document.getElementById('chatTitle').textContent = 'Global Chat - Everyone\\'s Hangout';\n  document.getElementById('globalChatBtn').classList.add('active');\n  \n  // Remove active state from other buttons\n  document.querySelectorAll('.server-btn, .friend-btn').forEach(btn => {\n    btn.classList.remove('active');\n  });\n  \n  // Clear messages container first\n  document.getElementById('messagesContainer').innerHTML = '<div class=\"loading\">Loading messages...</div>';\n  \n  // Set endpoint and load messages\n  currentMessageEndpoint = '/api/messages/global';\n  console.log('[DEBUG] About to call loadMessages for global chat');\n  loadMessages();\n}\n\nfunction loadServers() {\n  fetch(`/api/servers/user/${currentUser.id}`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(servers => {\n      const list = document.getElementById('serversList');\n      list.innerHTML = '';\n      servers.forEach(server => {\n        const serverWrapper = document.createElement('div');\n        serverWrapper.className = 'server-wrapper';\n        serverWrapper.dataset.serverId = server.id;\n        \n        const container = document.createElement('div');\n        container.className = 'server-item';\n        container.style.cssText = 'display: flex; align-items: center; gap: 5px; margin-bottom: 2px;';\n        \n        const expandBtn = document.createElement('button');\n        expandBtn.className = 'expand-btn';\n        expandBtn.innerHTML = 'â–¶';\n        expandBtn.title = 'Expand channels';\n        expandBtn.style.cssText = 'padding: 4px 6px; background: transparent; border: none; cursor: pointer; font-size: 10px; color: var(--text-light); transition: transform 0.2s;';\n        expandBtn.addEventListener('click', (e) => {\n          e.stopPropagation();\n          toggleServerChannels(server, serverWrapper, expandBtn);\n        });\n        \n        const btn = document.createElement('button');\n        btn.className = 'server-btn';\n        btn.style.cssText = 'flex: 1;';\n        btn.textContent = server.name;\n        btn.addEventListener('click', () => toggleServerChannels(server, serverWrapper, expandBtn));\n        \n        container.appendChild(expandBtn);\n        container.appendChild(btn);\n        \n        if (server.id !== 1) {\n          const isOwner = server.owner_id === currentUser.id;\n          \n          const optBtn = document.createElement('button');\n          optBtn.textContent = 'âš™';\n          optBtn.title = isOwner ? 'Manage Server' : 'Leave Server';\n          optBtn.style.cssText = 'padding: 5px 8px; background: var(--accent); border: none; border-radius: 4px; cursor: pointer; font-size: 12px;';\n          optBtn.addEventListener('click', (e) => {\n            e.stopPropagation();\n            showServerOptions(server, isOwner);\n          });\n          \n          container.appendChild(optBtn);\n        }\n        \n        const channelsContainer = document.createElement('div');\n        channelsContainer.className = 'channels-container';\n        channelsContainer.style.cssText = 'display: none; padding-left: 20px; margin-top: 4px;';\n        \n        serverWrapper.appendChild(container);\n        serverWrapper.appendChild(channelsContainer);\n        list.appendChild(serverWrapper);\n      });\n    });\n}\n\nfunction toggleServerChannels(server, wrapper, expandBtn) {\n  const channelsContainer = wrapper.querySelector('.channels-container');\n  const isExpanded = channelsContainer.style.display !== 'none';\n  \n  if (isExpanded) {\n    channelsContainer.style.display = 'none';\n    expandBtn.innerHTML = 'â–¶';\n    expandBtn.style.transform = 'rotate(0deg)';\n  } else {\n    expandBtn.innerHTML = 'â–¼';\n    expandBtn.style.transform = 'rotate(0deg)';\n    channelsContainer.style.display = 'block';\n    \n    if (!channelsContainer.dataset.loaded) {\n      channelsContainer.innerHTML = '<div style=\"color: var(--text-light); font-size: 12px; padding: 4px;\">Loading...</div>';\n      loadServerChannels(server, channelsContainer);\n    }\n  }\n}\n\nfunction loadServerChannels(server, container) {\n  fetch(`/api/servers/${server.id}`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(serverData => {\n      container.innerHTML = '';\n      container.dataset.loaded = 'true';\n      \n      if (serverData.channels && serverData.channels.length > 0) {\n        serverData.channels.forEach(channel => {\n          const channelBtn = document.createElement('button');\n          channelBtn.className = 'channel-btn';\n          channelBtn.dataset.channelId = channel.id;\n          channelBtn.innerHTML = `<span style=\"opacity: 0.6;\">#</span> ${channel.name}`;\n          channelBtn.style.cssText = 'display: block; width: 100%; text-align: left; padding: 6px 10px; margin-bottom: 2px; background: transparent; border: none; border-radius: 4px; cursor: pointer; color: var(--text-light); font-size: 13px; transition: background 0.2s, color 0.2s;';\n          channelBtn.addEventListener('mouseenter', () => {\n            channelBtn.style.background = 'var(--accent)';\n            channelBtn.style.color = 'var(--text)';\n          });\n          channelBtn.addEventListener('mouseleave', () => {\n            if (!channelBtn.classList.contains('active')) {\n              channelBtn.style.background = 'transparent';\n              channelBtn.style.color = 'var(--text-light)';\n            }\n          });\n          channelBtn.addEventListener('click', () => selectChannel(server, channel));\n          container.appendChild(channelBtn);\n        });\n      } else {\n        container.innerHTML = '<div style=\"color: var(--text-light); font-size: 12px; padding: 4px; font-style: italic;\">No channels</div>';\n      }\n    })\n    .catch(err => {\n      console.error('Failed to load channels:', err);\n      container.innerHTML = '<div style=\"color: var(--text-light); font-size: 12px; padding: 4px;\">Failed to load</div>';\n    });\n}\n\nfunction selectChannel(server, channel) {\n  currentGroupChat = null;\n  currentFriend = null;\n  isGlobalChat = false;\n  messageOffset = 0;\n  hasMoreMessages = true;\n  \n  document.getElementById('chatTitle').textContent = `${server.name} > #${channel.name}`;\n  document.getElementById('globalChatBtn').classList.remove('active');\n  \n  document.querySelectorAll('.channel-btn').forEach(btn => {\n    btn.classList.remove('active');\n    btn.style.background = 'transparent';\n    btn.style.color = 'var(--text-light)';\n  });\n  \n  const activeBtn = document.querySelector(`.channel-btn[data-channel-id=\"${channel.id}\"]`);\n  if (activeBtn) {\n    activeBtn.classList.add('active');\n    activeBtn.style.background = 'var(--primary)';\n    activeBtn.style.color = 'white';\n  }\n  \n  currentChannel = channel.id;\n  currentMessageEndpoint = `/api/messages/channel/${channel.id}`;\n  socket.emit('join_channel', { channelId: channel.id });\n  loadMessages();\n}\n\nfunction showServerOptions(server, isOwner) {\n  if (isOwner) {\n    const action = prompt(`Manage \"${server.name}\":\\n\\n1 - Edit Server/Channels\\n2 - View/Kick Members\\n3 - Roles & Permissions\\n4 - Create Invite Link\\n5 - View Invites\\n6 - Invite Friends\\n7 - Delete Server\\n\\nEnter 1-7:`);\n    if (action === '1') {\n      openServerManageModal(server.id, server.name);\n    } else if (action === '2') {\n      manageServerMembers(server);\n    } else if (action === '3') {\n      openServerSettings(server.id);\n    } else if (action === '4') {\n      showCreateInviteModal(server.id);\n    } else if (action === '5') {\n      showServerInvites(server.id, server.name);\n    } else if (action === '6') {\n      showInviteFriendsModal('server', server.id, server.name);\n    } else if (action === '7') {\n      if (confirm(`Are you sure you want to DELETE \"${server.name}\"? This will delete all channels and messages. This cannot be undone.`)) {\n        deleteServer(server.id);\n      }\n    }\n  } else {\n    const action = prompt(`\"${server.name}\" Options:\\n\\n1 - Create Invite Link\\n2 - Invite Friends\\n3 - Leave Server\\n\\nEnter 1-3:`);\n    if (action === '1') {\n      showCreateInviteModal(server.id);\n    } else if (action === '2') {\n      showInviteFriendsModal('server', server.id, server.name);\n    } else if (action === '3') {\n      if (confirm(`Leave \"${server.name}\"?`)) {\n        leaveServer(server.id);\n      }\n    }\n  }\n}\n\nfunction manageServerMembers(server) {\n  fetch(`/api/servers/${server.id}/members`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(members => {\n      const memberList = members.map((m, i) => \n        `${i + 1}. ${m.username}${m.id === server.owner_id ? ' (Owner)' : ''}`\n      ).join('\\n');\n      \n      const choice = prompt(`Members of \"${server.name}\":\\n\\n${memberList}\\n\\nEnter member number to kick (or cancel):`);\n      if (choice) {\n        const idx = parseInt(choice) - 1;\n        if (idx >= 0 && idx < members.length) {\n          const member = members[idx];\n          if (member.id === currentUser.id) {\n            alert('Cannot kick yourself!');\n            return;\n          }\n          if (confirm(`Kick ${member.username} from the server?`)) {\n            kickFromServer(server.id, member.id);\n          }\n        }\n      }\n    });\n}\n\nfunction leaveServer(serverId) {\n  fetch(`/api/servers/${serverId}/leave`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.error) {\n        alert(data.error);\n      } else {\n        alert('Left server');\n        loadServers();\n      }\n    });\n}\n\nfunction deleteServer(serverId) {\n  fetch(`/api/servers/${serverId}`, {\n    method: 'DELETE',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.error) {\n        alert(data.error);\n      } else {\n        alert('Server deleted');\n        loadServers();\n      }\n    });\n}\n\nfunction kickFromServer(serverId, userId) {\n  fetch(`/api/servers/${serverId}/kick/${userId}`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.error) {\n        alert(data.error);\n      } else {\n        alert('Member kicked');\n      }\n    });\n}\n\nlet seenRequestIds = new Set(JSON.parse(localStorage.getItem('seenFriendRequests') || '[]'));\n\nfunction loadPendingRequests() {\n  fetch('/api/friends/pending', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(requests => {\n      const list = document.getElementById('pendingRequestsList');\n      list.innerHTML = '';\n      \n      if (requests.length === 0) {\n        list.innerHTML = '<p style=\"padding: 10px; color: var(--text-light); font-size: 12px;\">No pending requests</p>';\n        return;\n      }\n      \n      requests.forEach(req => {\n        if (!seenRequestIds.has(req.userId)) {\n          seenRequestIds.add(req.userId);\n          localStorage.setItem('seenFriendRequests', JSON.stringify([...seenRequestIds]));\n          queueInvitePopup('friend_request', {\n            userId: req.userId,\n            username: req.username,\n            profilePicture: req.profile_picture || req.profilePicture\n          });\n        }\n        \n        const container = document.createElement('div');\n        container.style.cssText = 'padding: 8px; border-bottom: 1px solid var(--accent); display: flex; gap: 8px; align-items: center;';\n        \n        const info = document.createElement('div');\n        info.style.cssText = 'flex: 1; min-width: 0;';\n        info.innerHTML = `\n          <div style=\"font-weight: 600; font-size: 13px; color: var(--text);\">${escapeHtml(req.username)}</div>\n          <div style=\"font-size: 11px; color: var(--text-light);\">wants to be friends</div>\n        `;\n        \n        const btnContainer = document.createElement('div');\n        btnContainer.style.cssText = 'display: flex; gap: 4px;';\n        \n        const acceptBtn = document.createElement('button');\n        acceptBtn.textContent = 'âœ“';\n        acceptBtn.style.cssText = 'padding: 4px 8px; background: #2ecc71; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;';\n        acceptBtn.addEventListener('click', () => acceptFriendRequest(req.userId, req.username));\n        \n        const rejectBtn = document.createElement('button');\n        rejectBtn.textContent = 'âœ•';\n        rejectBtn.style.cssText = 'padding: 4px 8px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;';\n        rejectBtn.addEventListener('click', () => rejectFriendRequest(req.userId));\n        \n        btnContainer.appendChild(acceptBtn);\n        btnContainer.appendChild(rejectBtn);\n        \n        container.appendChild(info);\n        container.appendChild(btnContainer);\n        list.appendChild(container);\n      });\n    });\n}\n\nfunction acceptFriendRequest(userId, username) {\n  fetch(`/api/friends/${userId}/accept`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(() => {\n      loadPendingRequests();\n      loadFriends();\n    })\n    .catch(() => alert('Failed to accept request'));\n}\n\nfunction rejectFriendRequest(userId) {\n  fetch(`/api/friends/${userId}/reject`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(() => {\n      loadPendingRequests();\n    })\n    .catch(() => alert('Failed to reject request'));\n}\n\nfunction loadFriendNicknames() {\n  fetch('/api/friends/nicknames/all', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(nicknames => {\n      friendNicknames = {};\n      nicknames.forEach(n => {\n        friendNicknames[n.friendId] = n.nickname;\n      });\n    })\n    .catch(() => {});\n}\n\nfunction loadFriends() {\n  fetch('/api/friends', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(friends => {\n      const list = document.getElementById('friendsList');\n      list.innerHTML = '';\n      friends.forEach(friend => {\n        const container = document.createElement('div');\n        container.style.cssText = 'display:flex;align-items:center;gap:6px;margin-bottom:4px;';\n        \n        const btn = document.createElement('button');\n        btn.className = 'friend-btn';\n        btn.style.cssText = 'flex:1;display:flex;align-items:center;gap:8px;min-width:0;';\n        \n        const statusColor = friend.is_online ? '#2ecc71' : '#7f8c8d';\n        const nickname = friendNicknames[friend.id];\n        const displayName = nickname ? `${nickname}` : friend.username;\n        \n        btn.innerHTML = `\n          <div style=\"position:relative;flex-shrink:0;\">\n            <img src=\"${friend.profilePicture || 'https://via.placeholder.com/24'}\" style=\"width:24px;height:24px;border-radius:50%;\">\n            <span style=\"position:absolute;bottom:-2px;right:-2px;width:10px;height:10px;border-radius:50%;background:${statusColor};border:2px solid var(--bg-secondary);\"></span>\n          </div>\n          <span style=\"overflow:hidden;text-overflow:ellipsis;white-space:nowrap;\" title=\"${escapeHtml(friend.username)}${nickname ? ' (' + escapeHtml(nickname) + ')' : ''}\">${escapeHtml(displayName)}</span>\n        `;\n        btn.addEventListener('click', () => selectFriend(friend));\n        btn.addEventListener('contextmenu', (e) => {\n          e.preventDefault();\n          showFriendContextMenu(e, friend);\n        });\n        \n        const unfriendBtn = document.createElement('button');\n        unfriendBtn.textContent = 'âœ•';\n        unfriendBtn.title = 'Unfriend';\n        unfriendBtn.style.cssText = 'padding:4px 6px;background:#e74c3c;border:none;border-radius:4px;cursor:pointer;font-size:10px;font-weight:bold;color:white;opacity:0.7;transition:opacity 0.2s;';\n        unfriendBtn.addEventListener('mouseenter', () => unfriendBtn.style.opacity = '1');\n        unfriendBtn.addEventListener('mouseleave', () => unfriendBtn.style.opacity = '0.7');\n        unfriendBtn.addEventListener('click', (e) => {\n          e.stopPropagation();\n          unfriendUser(friend.id, friend.username);\n        });\n        \n        const optBtn = document.createElement('button');\n        optBtn.textContent = 'â‹®';\n        optBtn.title = 'Options';\n        optBtn.style.cssText = 'padding:4px 6px;background:var(--accent);border:none;border-radius:4px;cursor:pointer;font-size:12px;font-weight:bold;color:var(--text);';\n        optBtn.addEventListener('click', (e) => {\n          e.stopPropagation();\n          showFriendContextMenu(e, friend);\n        });\n        \n        container.appendChild(btn);\n        container.appendChild(unfriendBtn);\n        container.appendChild(optBtn);\n        list.appendChild(container);\n      });\n    });\n}\n\nfunction showFriendContextMenu(e, friend) {\n  const existingMenu = document.getElementById('friendContextMenu');\n  if (existingMenu) existingMenu.remove();\n  \n  const menu = document.createElement('div');\n  menu.id = 'friendContextMenu';\n  menu.style.cssText = `position:fixed;top:${e.clientY}px;left:${e.clientX}px;background:var(--card);border:1px solid var(--accent);border-radius:8px;padding:8px 0;z-index:9999;min-width:160px;box-shadow:0 4px 12px rgba(0,0,0,0.3);`;\n  \n  const currentNickname = friendNicknames[friend.id];\n  const nicknameText = currentNickname ? 'âœï¸ Edit Nickname' : 'âœï¸ Set Nickname';\n  \n  const options = [\n    { text: 'ðŸ‘¤ View Profile', action: () => showUserProfile(friend.id) },\n    { text: 'ðŸ’¬ Send Message', action: () => selectFriend(friend) },\n    { text: nicknameText, action: () => setFriendNickname(friend.id, friend.username, currentNickname) },\n    { divider: true },\n    { text: 'ðŸ”‡ Ignore', action: () => ignoreFriend(friend.id, true) },\n    { text: 'ðŸ‘» Be Invisible', action: () => setInvisibleToFriend(friend.id, true) },\n    { divider: true },\n    { text: 'ðŸš« Block', action: () => blockFriend(friend.id), danger: true },\n    { text: 'âŒ Unfriend', action: () => unfriendUser(friend.id, friend.username), danger: true }\n  ];\n  \n  options.forEach(opt => {\n    if (opt.divider) {\n      const divider = document.createElement('div');\n      divider.style.cssText = 'height:1px;background:var(--accent);margin:4px 0;';\n      menu.appendChild(divider);\n    } else {\n      const item = document.createElement('button');\n      item.textContent = opt.text;\n      item.style.cssText = `display:block;width:100%;padding:8px 16px;background:none;border:none;text-align:left;cursor:pointer;color:${opt.danger ? '#e74c3c' : 'var(--text)'};font-size:13px;`;\n      item.addEventListener('mouseover', () => item.style.background = 'var(--bg)');\n      item.addEventListener('mouseout', () => item.style.background = 'none');\n      item.addEventListener('click', () => {\n        menu.remove();\n        opt.action();\n      });\n      menu.appendChild(item);\n    }\n  });\n  \n  document.body.appendChild(menu);\n  \n  const closeMenu = (e) => {\n    if (!menu.contains(e.target)) {\n      menu.remove();\n      document.removeEventListener('click', closeMenu);\n    }\n  };\n  setTimeout(() => document.addEventListener('click', closeMenu), 10);\n}\n\nfunction unfriendUser(userId, username) {\n  if (!confirm(`Are you sure you want to unfriend ${username}?`)) return;\n  \n  fetch(`/api/friends/${userId}/remove`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        alert('Friend removed');\n        loadFriends();\n      } else {\n        alert(data.error || 'Failed to remove friend');\n      }\n    })\n    .catch(() => alert('Failed to remove friend'));\n}\n\nfunction setFriendNickname(userId, username, currentNickname) {\n  const nickname = prompt(\n    `Set a nickname for ${username}\\n(Only you will see this)\\n\\nLeave empty to remove the nickname:`,\n    currentNickname || ''\n  );\n  \n  if (nickname === null) return;\n  \n  fetch(`/api/friends/${userId}/nickname`, {\n    method: 'POST',\n    headers: { \n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}` \n    },\n    body: JSON.stringify({ nickname: nickname.trim() })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        if (nickname.trim()) {\n          friendNicknames[userId] = nickname.trim();\n          alert(`Nickname set to \"${nickname.trim()}\"`);\n        } else {\n          delete friendNicknames[userId];\n          alert('Nickname removed');\n        }\n        loadFriends();\n      } else {\n        alert(data.error || 'Failed to set nickname');\n      }\n    })\n    .catch(() => alert('Failed to set nickname'));\n}\n\nfunction blockFriend(userId) {\n  fetch(`/api/blocks/${userId}`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        alert('User blocked');\n        loadFriends();\n      } else {\n        alert(data.error || 'Failed to block user');\n      }\n    })\n    .catch(() => alert('Failed to block user'));\n}\n\nfunction ignoreFriend(userId, ignored) {\n  fetch(`/api/friends/${userId}/ignore`, {\n    method: 'POST',\n    headers: { \n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}` \n    },\n    body: JSON.stringify({ ignored })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        alert(data.message);\n      } else {\n        alert(data.error || 'Failed to update ignore status');\n      }\n    })\n    .catch(() => alert('Failed to ignore friend'));\n}\n\nfunction setInvisibleToFriend(userId, invisible) {\n  fetch(`/api/friends/${userId}/invisible`, {\n    method: 'POST',\n    headers: { \n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}` \n    },\n    body: JSON.stringify({ invisible })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        alert(data.message);\n      } else {\n        alert(data.error || 'Failed to update visibility');\n      }\n    })\n    .catch(() => alert('Failed to update visibility'));\n}\n\nfunction showInviteFriendsModal(type, targetId, targetName) {\n  const endpoint = type === 'server' \n    ? `/api/invites/friends-to-invite/server/${targetId}`\n    : `/api/invites/friends-to-invite/group/${targetId}`;\n  \n  fetch(endpoint, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(friends => {\n      const existingModal = document.getElementById('inviteFriendsModal');\n      if (existingModal) existingModal.remove();\n      \n      const modal = document.createElement('div');\n      modal.id = 'inviteFriendsModal';\n      modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:9999;';\n      \n      const typeLabel = type === 'server' ? 'Server' : 'Group Chat';\n      \n      let content = `\n        <div style=\"background:var(--card);border-radius:12px;padding:24px;max-width:400px;width:90%;max-height:80vh;overflow-y:auto;\">\n          <h3 style=\"margin:0 0 16px;color:var(--text);\">Invite Friends to ${escapeHtml(targetName)}</h3>\n      `;\n      \n      if (friends.length === 0) {\n        content += `<p style=\"color:var(--text-light);margin:20px 0;\">No friends available to invite. All your friends are already members or you have no friends yet.</p>`;\n      } else {\n        content += `<div style=\"display:flex;flex-direction:column;gap:8px;\">`;\n        friends.forEach(friend => {\n          content += `\n            <div style=\"display:flex;align-items:center;gap:12px;padding:10px;background:var(--bg);border-radius:8px;\">\n              <img src=\"${friend.profilePicture || 'https://via.placeholder.com/32'}\" style=\"width:32px;height:32px;border-radius:50%;\">\n              <span style=\"flex:1;color:var(--text);\">${escapeHtml(friend.username)}</span>\n              <button onclick=\"inviteFriendTo('${type}', ${targetId}, ${friend.id}, '${escapeHtml(friend.username)}')\" \n                style=\"padding:6px 12px;background:var(--accent);border:none;border-radius:4px;cursor:pointer;color:var(--text);font-weight:600;\">\n                Invite\n              </button>\n            </div>\n          `;\n        });\n        content += `</div>`;\n      }\n      \n      content += `\n        <button onclick=\"document.getElementById('inviteFriendsModal').remove()\" \n          style=\"margin-top:16px;padding:10px 20px;background:var(--accent);border:none;border-radius:6px;cursor:pointer;color:var(--text);width:100%;\">\n          Close\n        </button>\n      </div>`;\n      \n      modal.innerHTML = content;\n      modal.addEventListener('click', (e) => {\n        if (e.target === modal) modal.remove();\n      });\n      \n      document.body.appendChild(modal);\n    })\n    .catch(err => {\n      console.error('Failed to load friends:', err);\n      alert('Failed to load friends list');\n    });\n}\n\nfunction inviteFriendTo(type, targetId, friendId, friendName) {\n  const endpoint = type === 'server'\n    ? `/api/invites/server/${targetId}/direct/${friendId}`\n    : `/api/invites/group/${targetId}/add/${friendId}`;\n  \n  fetch(endpoint, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        alert(data.message);\n        document.getElementById('inviteFriendsModal').remove();\n        if (type === 'server') {\n          loadServers();\n        } else {\n          loadGroupChats();\n        }\n      } else {\n        alert(data.error || 'Failed to invite friend');\n      }\n    })\n    .catch(() => alert('Failed to invite friend'));\n}\n\nfunction selectServer(server) {\n  currentGroupChat = null;\n  currentFriend = null;\n  isGlobalChat = false;\n  messageOffset = 0;\n  hasMoreMessages = true;\n  document.getElementById('chatTitle').textContent = server.name;\n  document.getElementById('globalChatBtn').classList.remove('active');\n  \n  // Fetch the actual first channel ID for this server\n  fetch(`/api/servers/${server.id}`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(serverData => {\n      if (serverData.channels && serverData.channels.length > 0) {\n        const firstChannel = serverData.channels[0];\n        currentChannel = firstChannel.id;\n        currentMessageEndpoint = `/api/messages/channel/${firstChannel.id}`;\n        socket.emit('join_channel', { channelId: firstChannel.id });\n        loadMessages();\n      } else {\n        currentChannel = null;\n        document.getElementById('messagesContainer').innerHTML = '<div class=\"welcome\">This server has no channels yet</div>';\n      }\n    })\n    .catch(() => {\n      currentChannel = server.id;\n      currentMessageEndpoint = `/api/servers/${server.id}/messages`;\n      socket.emit('join_channel', { channelId: server.id });\n      loadMessages();\n    });\n}\n\nfunction selectFriend(friend) {\n  currentFriend = friend.id;\n  currentChannel = null;\n  currentGroupChat = null;\n  isGlobalChat = false;\n  messageOffset = 0;\n  hasMoreMessages = true;\n  document.getElementById('chatTitle').textContent = `Direct Message: ${friend.username}`;\n  document.getElementById('globalChatBtn').classList.remove('active');\n  socket.emit('join_dm', { userId: currentUser.id, dmPartnerId: friend.id });\n  currentMessageEndpoint = `/api/messages/dms/${friend.id}/messages`;\n  loadMessages();\n}\n\nfunction loadMessages(loadOlder = false) {\n  if (isLoadingMessages || !currentMessageEndpoint) {\n    console.log('[DEBUG] loadMessages blocked:', { isLoadingMessages, currentMessageEndpoint });\n    return;\n  }\n  isLoadingMessages = true;\n  console.log('[DEBUG] loadMessages called:', { loadOlder, endpoint: currentMessageEndpoint });\n\n  const offset = loadOlder ? messageOffset : 0;\n  \n  fetch(`${currentMessageEndpoint}?offset=${offset}&limit=50`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => {\n      if (!r.ok) throw new Error(`HTTP ${r.status}`);\n      return r.json();\n    })\n    .then(messages => {\n      console.log('[DEBUG] Messages received:', messages?.length || 0, messages);\n      if (!Array.isArray(messages)) {\n        console.error('[ERROR] Expected array, got:', messages);\n        isLoadingMessages = false;\n        return;\n      }\n      const container = document.getElementById('messagesContainer');\n      \n      if (!loadOlder) {\n        // Initial load - clear container\n        container.innerHTML = '';\n        messageOffset = 0;\n        hasMoreMessages = true;\n      }\n      \n      if (messages.length < 50) {\n        hasMoreMessages = false;\n      }\n      \n      if (loadOlder && messages.length > 0) {\n        // Add \"Load More\" button at top\n        const loadBtn = document.createElement('button');\n        loadBtn.textContent = 'â†‘ Load older messages';\n        loadBtn.style.cssText = 'width: 100%; padding: 10px; margin-bottom: 10px; background: var(--accent); color: var(--text); border: none; border-radius: 6px; cursor: pointer;';\n        loadBtn.addEventListener('click', () => {\n          loadBtn.remove();\n          loadMessages(true);\n        });\n        container.insertBefore(loadBtn, container.firstChild);\n        \n        // Add old messages before new ones\n        const firstMessage = container.querySelector('.message');\n        messages.reverse().forEach(msg => {\n          const el = createMessageElement(msg);\n          if (firstMessage) {\n            container.insertBefore(el, firstMessage);\n          } else {\n            container.appendChild(el);\n          }\n        });\n        \n        messageOffset += messages.length;\n      } else if (!loadOlder) {\n        // New load - add messages normally\n        messages.forEach((msg, idx) => {\n          displayMessage(msg, idx === messages.length - 1);\n          // Track last message ID for polling\n          if (msg.id > lastMessageId) {\n            lastMessageId = msg.id;\n          }\n        });\n        messageOffset = messages.length;\n      }\n      \n      isLoadingMessages = false;\n    })\n    .catch(err => {\n      console.error('[ERROR] Failed to load messages:', err);\n      isLoadingMessages = false;\n    });\n}\n\nfunction createMessageElement(msg) {\n  const el = document.createElement('div');\n  el.className = 'message';\n  el.setAttribute('data-msg-id', msg.id);\n  \n  // Handle both snake_case (from DB) and camelCase (from socket) property names\n  const userId = msg.user_id || msg.userId;\n  const username = msg.username || 'Unknown';\n  const profilePicture = msg.profile_picture || msg.profilePicture || 'https://via.placeholder.com/36';\n  const createdAt = msg.created_at || msg.createdAt || new Date().toISOString();\n  \n  // Format the date properly\n  let formattedTime;\n  try {\n    formattedTime = new Date(createdAt).toLocaleTimeString();\n    if (formattedTime === 'Invalid Date') {\n      formattedTime = new Date().toLocaleTimeString();\n    }\n  } catch(e) {\n    formattedTime = new Date().toLocaleTimeString();\n  }\n  \n  el.innerHTML = `\n    <img src=\"${profilePicture}\" class=\"message-avatar\" style=\"cursor:pointer;\" onclick=\"showUserProfile(${userId})\">\n    <div class=\"message-content\">\n      <div class=\"message-header\">\n        <span class=\"message-username\" style=\"cursor:pointer;\" onclick=\"showUserProfile(${userId})\">${escapeHtml(username)}</span>\n        <span class=\"message-timestamp\">${formattedTime}</span>\n      </div>\n      <div class=\"message-text\">${escapeHtml(msg.content)}</div>\n    </div>\n  `;\n  return el;\n}\n\nfunction displayMessage(msg, shouldScroll = false) {\n  const container = document.getElementById('messagesContainer');\n  const el = document.createElement('div');\n  el.className = 'message';\n  el.style.position = 'relative';\n  el.setAttribute('data-msg-id', msg.id);\n  \n  const userId = msg.user_id || msg.userId;\n  const username = msg.username || 'Unknown';\n  const profilePicture = msg.profile_picture || msg.profilePicture || 'https://via.placeholder.com/36';\n  const createdAt = msg.created_at || msg.createdAt || new Date().toISOString();\n  const isEdited = msg.is_edited || msg.isEdited;\n  const replyTo = msg.replyTo || (msg.reply_to_id ? { id: msg.reply_to_id, content: msg.reply_content, username: msg.reply_username } : null);\n  const attachment = msg.attachment;\n  \n  let formattedTime;\n  try {\n    formattedTime = new Date(createdAt).toLocaleTimeString();\n    if (formattedTime === 'Invalid Date') formattedTime = new Date().toLocaleTimeString();\n  } catch(e) {\n    formattedTime = new Date().toLocaleTimeString();\n  }\n  \n  let replyHtml = '';\n  if (replyTo && replyTo.content) {\n    replyHtml = `<div class=\"msg-reply-preview\">â†© <strong>${escapeHtml(replyTo.username || 'User')}</strong>: ${escapeHtml(replyTo.content.substring(0, 60))}${replyTo.content.length > 60 ? '...' : ''}</div>`;\n  }\n  \n  let attachmentHtml = '';\n  if (attachment) {\n    if (attachment.type?.startsWith('image/')) {\n      attachmentHtml = `<div class=\"msg-attachment\"><img src=\"${attachment.url}\" alt=\"${escapeHtml(attachment.originalName || 'Image')}\" onclick=\"window.open('${attachment.url}','_blank')\"></div>`;\n    } else {\n      attachmentHtml = `<div class=\"msg-attachment\"><a href=\"${attachment.url}\" target=\"_blank\">ðŸ“Ž ${escapeHtml(attachment.originalName || 'File')}</a></div>`;\n    }\n  }\n  \n  const contentWithMentions = formatMessageMentions(msg.content);\n  \n  const isOwn = userId === currentUser?.id;\n  const canEdit = isOwn;\n  const canDelete = isOwn || isAdmin;\n  \n  el.innerHTML = `\n    <img src=\"${profilePicture}\" class=\"message-avatar\" style=\"cursor:pointer;\" onclick=\"showUserProfile(${userId})\">\n    <div class=\"message-content\" style=\"flex:1;\">\n      ${replyHtml}\n      <div class=\"message-header\">\n        <span class=\"message-username\" style=\"cursor:pointer;\" onclick=\"showUserProfile(${userId})\">${escapeHtml(username)}</span>\n        <span class=\"message-timestamp\">${formattedTime}</span>\n        ${isEdited ? '<span class=\"msg-edited\">(edited)</span>' : ''}\n      </div>\n      <div class=\"message-text msg-content\">${contentWithMentions}</div>\n      ${attachmentHtml}\n      <div class=\"msg-reactions\"></div>\n    </div>\n    <div class=\"msg-actions\">\n      <button class=\"msg-action-btn\" onclick=\"setReplyTo(${msg.id}, '${escapeHtml(username)}', '${escapeHtml(msg.content.replace(/'/g, \"\\\\'\"))}')\">â†©</button>\n      <button class=\"msg-action-btn\" onclick=\"showReactionPicker(${msg.id})\">ðŸ˜€</button>\n      <button class=\"msg-action-btn\" onclick=\"pinMessage(${msg.id})\">ðŸ“Œ</button>\n      ${canEdit ? `<button class=\"msg-action-btn\" onclick=\"editMessage(${msg.id})\">âœï¸</button>` : ''}\n      ${canDelete ? `<button class=\"msg-action-btn\" onclick=\"deleteMessageById(${msg.id})\" style=\"color:#e74c3c;\">ðŸ—‘</button>` : ''}\n    </div>\n  `;\n  container.appendChild(el);\n  \n  setTimeout(() => loadReactionsForMessage(msg.id), 100);\n  \n  if (shouldScroll) {\n    container.scrollTop = container.scrollHeight;\n  }\n}\n\nfunction formatMessageMentions(content) {\n  return escapeHtml(content).replace(/@(\\w+)/g, '<span class=\"mention\" onclick=\"viewUserProfile(\\'$1\\')\">@$1</span>');\n}\n\nfunction deleteMessageById(messageId) {\n  if (!confirm('Delete this message?')) return;\n  socket.emit('delete_message', { messageId, userId: currentUser.id, isAdmin });\n}\n\nfunction sendMessage() {\n  const input = document.getElementById('messageInput');\n  const content = input.value.trim();\n  \n  if (!content || (!currentChannel && !currentFriend && !currentGroupChat && !isGlobalChat)) {\n    return;\n  }\n\n  const messageData = {\n    channelId: currentChannel,\n    groupChatId: currentGroupChat,\n    dmPartnerId: currentFriend,\n    isGlobal: isGlobalChat,\n    userId: currentUser.id,\n    content\n  };\n  \n  if (replyingToMessage) {\n    messageData.replyToId = replyingToMessage.id;\n  }\n  \n  if (pendingAttachment) {\n    messageData.attachment = pendingAttachment;\n  }\n  \n  if (socket && socket.connected) {\n    socket.emit('send_message', messageData);\n  } else {\n    // Fallback: send via HTTP POST\n    fetch('/api/messages/send', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${getAuthToken()}`\n      },\n      body: JSON.stringify(messageData)\n    }).then(r => r.json()).then(data => {\n      if (data.success) {\n        displayMessage(data.message, true);\n      }\n    }).catch(err => console.error('Failed to send message:', err));\n  }\n\n  input.value = '';\n  cancelReply();\n  pendingAttachment = null;\n  stopTyping();\n  \n  fetch('/api/xp/activity/message', {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  }).catch(() => {});\n}\n\nfunction createServerRequest() {\n  currentChannel = null;\n  currentFriend = null;\n  currentGroupChat = null;\n  isGlobalChat = false;\n  \n  const container = document.getElementById('messagesContainer');\n  const header = document.getElementById('chatTitle');\n  \n  if (header) header.textContent = 'Create Server';\n  \n  container.innerHTML = `\n    <div style=\"padding:40px;max-width:600px;margin:0 auto;\">\n      <h2 style=\"color:var(--text);margin-bottom:10px;font-size:20px;\">CREATE A SERVER</h2>\n      <p style=\"color:var(--text-light);margin-bottom:20px;font-size:14px;\">Servers are where you and your friends hang out. Create yours and start chatting!</p>\n      \n      <div style=\"margin-bottom:15px;\">\n        <label style=\"display:block;color:var(--text);font-weight:600;margin-bottom:8px;font-size:13px;\">SERVER NAME</label>\n        <input type=\"text\" id=\"createServerNameInput\" placeholder=\"My Awesome Server\" maxlength=\"50\"\n          style=\"width:100%;padding:12px 16px;background:var(--bg);border:1px solid var(--accent);border-radius:8px;color:var(--text);font-size:14px;\">\n      </div>\n      \n      <div style=\"margin-bottom:20px;\">\n        <label style=\"display:block;color:var(--text);font-weight:600;margin-bottom:8px;font-size:13px;\">DESCRIPTION (optional)</label>\n        <textarea id=\"createServerDescInput\" placeholder=\"What's your server about?\" \n          style=\"width:100%;padding:12px 16px;background:var(--bg);border:1px solid var(--accent);border-radius:8px;color:var(--text);font-size:14px;min-height:80px;resize:vertical;\"></textarea>\n      </div>\n      \n      <button onclick=\"submitServerCreate()\" \n        style=\"width:100%;padding:14px;background:var(--primary);color:white;border:none;border-radius:8px;font-weight:600;cursor:pointer;font-size:15px;\">\n        Create Server\n      </button>\n      \n      <div id=\"createServerResult\" style=\"padding:12px;border-radius:8px;display:none;margin-top:15px;\"></div>\n    </div>\n  `;\n  \n  document.getElementById('createServerNameInput').focus();\n}\n\nfunction submitServerCreate() {\n  const nameInput = document.getElementById('createServerNameInput');\n  const descInput = document.getElementById('createServerDescInput');\n  const resultDiv = document.getElementById('createServerResult');\n  \n  const name = nameInput.value.trim();\n  const description = descInput.value.trim();\n  \n  if (!name) {\n    resultDiv.style.display = 'block';\n    resultDiv.style.background = 'rgba(231, 76, 60, 0.2)';\n    resultDiv.style.color = '#e74c3c';\n    resultDiv.textContent = 'Please enter a server name';\n    return;\n  }\n\n  fetch('/api/servers/create', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}`\n    },\n    body: JSON.stringify({ \n      userId: currentUser.id,\n      serverName: name,\n      description \n    })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        resultDiv.style.display = 'block';\n        resultDiv.style.background = 'rgba(46, 204, 113, 0.2)';\n        resultDiv.style.color = '#2ecc71';\n        resultDiv.textContent = 'âœ… Server created successfully!';\n        nameInput.value = '';\n        descInput.value = '';\n        loadServers();\n        setTimeout(() => {\n          selectServer(data.serverId);\n        }, 500);\n      } else {\n        throw new Error(data.error || 'Failed to create server');\n      }\n    })\n    .catch((err) => {\n      resultDiv.style.display = 'block';\n      resultDiv.style.background = 'rgba(231, 76, 60, 0.2)';\n      resultDiv.style.color = '#e74c3c';\n      resultDiv.textContent = 'âŒ ' + (err.message || 'Failed to create server');\n    });\n}\n\nfunction addFriend() {\n  currentChannel = null;\n  currentFriend = null;\n  currentGroupChat = null;\n  isGlobalChat = false;\n  \n  const container = document.getElementById('messagesContainer');\n  const header = document.getElementById('chatTitle');\n  \n  if (header) header.textContent = 'Add Friend';\n  \n  container.innerHTML = `\n    <div style=\"padding:40px;max-width:600px;margin:0 auto;\">\n      <h2 style=\"color:var(--text);margin-bottom:10px;font-size:20px;\">ADD FRIEND</h2>\n      <p style=\"color:var(--text-light);margin-bottom:20px;font-size:14px;\">You can add a friend with their username. It's cAsE sEnSiTiVe!</p>\n      \n      <div style=\"display:flex;gap:10px;margin-bottom:20px;\">\n        <input type=\"text\" id=\"addFriendInput\" placeholder=\"Enter a Username\" \n          style=\"flex:1;padding:12px 16px;background:var(--bg);border:1px solid var(--accent);border-radius:8px;color:var(--text);font-size:14px;\">\n        <button id=\"sendFriendRequestBtn\" onclick=\"sendFriendRequest()\" \n          style=\"padding:12px 24px;background:var(--primary);color:white;border:none;border-radius:8px;font-weight:600;cursor:pointer;white-space:nowrap;\">\n          Send Friend Request\n        </button>\n      </div>\n      \n      <div id=\"addFriendResult\" style=\"padding:12px;border-radius:8px;display:none;\"></div>\n      \n      <div style=\"margin-top:40px;padding:40px;text-align:center;color:var(--text-light);\">\n        <div style=\"font-size:60px;margin-bottom:20px;\">ðŸ¤</div>\n        <p>Wumpus is waiting for friends. You don't have to though!</p>\n      </div>\n    </div>\n  `;\n  \n  document.getElementById('addFriendInput').addEventListener('keypress', (e) => {\n    if (e.key === 'Enter') sendFriendRequest();\n  });\n  document.getElementById('addFriendInput').focus();\n}\n\nfunction sendFriendRequest() {\n  const input = document.getElementById('addFriendInput');\n  const resultDiv = document.getElementById('addFriendResult');\n  const username = input.value.trim();\n  \n  if (!username) {\n    resultDiv.style.display = 'block';\n    resultDiv.style.background = 'rgba(231, 76, 60, 0.2)';\n    resultDiv.style.color = '#e74c3c';\n    resultDiv.textContent = 'Please enter a username';\n    return;\n  }\n\n  const token = getAuthToken();\n  if (!token) {\n    resultDiv.style.display = 'block';\n    resultDiv.style.background = 'rgba(231, 76, 60, 0.2)';\n    resultDiv.style.color = '#e74c3c';\n    resultDiv.textContent = 'You must be logged in';\n    return;\n  }\n\n  fetch('/api/friends/request', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${token}`\n    },\n    body: JSON.stringify({ username })\n  })\n    .then(r => r.json())\n    .then(data => {\n      resultDiv.style.display = 'block';\n      if (data.success || data.message) {\n        resultDiv.style.background = 'rgba(46, 204, 113, 0.2)';\n        resultDiv.style.color = '#2ecc71';\n        resultDiv.textContent = 'âœ… Friend request sent to ' + username + '!';\n        input.value = '';\n        loadPendingRequests();\n        loadFriends();\n      } else if (data.error && data.error.includes('not found')) {\n        resultDiv.style.background = 'rgba(231, 76, 60, 0.2)';\n        resultDiv.style.color = '#e74c3c';\n        resultDiv.textContent = 'âŒ User \"' + username + '\" not found. Make sure the account exists!';\n      } else {\n        resultDiv.style.background = 'rgba(231, 76, 60, 0.2)';\n        resultDiv.style.color = '#e74c3c';\n        resultDiv.textContent = 'âŒ ' + (data.error || 'Failed to send request');\n      }\n    })\n    .catch(err => {\n      resultDiv.style.display = 'block';\n      resultDiv.style.background = 'rgba(231, 76, 60, 0.2)';\n      resultDiv.style.color = '#e74c3c';\n      resultDiv.textContent = 'âŒ Failed to send request';\n    });\n}\n\n// Fetch current user info by ID - always gets the latest username and profile picture\nasync function getCurrentUserInfo(userId) {\n  // Check cache first\n  if (userInfoCache[userId]) {\n    return userInfoCache[userId];\n  }\n  \n  try {\n    const response = await fetch(`/api/users/${userId}`, {\n      headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n    });\n    if (!response.ok) {\n      return { username: 'Unknown', profilePicture: 'https://via.placeholder.com/36' };\n    }\n    const data = await response.json();\n    userInfoCache[userId] = {\n      username: data.username || 'Unknown',\n      profilePicture: data.profilePicture || 'https://via.placeholder.com/36'\n    };\n    return userInfoCache[userId];\n  } catch (err) {\n    console.error('Error fetching user info:', err);\n    return { username: 'Unknown', profilePicture: 'https://via.placeholder.com/36' };\n  }\n}\n\nfunction escapeHtml(text) {\n  const map = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#039;'\n  };\n  return text.replace(/[&<>\"']/g, m => map[m]);\n}\n\n// ============== STATUS PICKER ==============\nconst statusConfig = {\n  online: { label: 'Online', color: '#2ecc71', icon: 'ðŸŸ¢' },\n  away: { label: 'Away', color: '#f39c12', icon: 'ðŸŸ¡' },\n  dnd: { label: 'Do Not Disturb', color: '#e74c3c', icon: 'ðŸ”´' },\n  invisible: { label: 'Invisible', color: '#95a5a6', icon: 'âš«' },\n  offline: { label: 'Offline', color: '#7f8c8d', icon: 'âšª' }\n};\n\nlet statusPickerInitialized = false;\nfunction initStatusPicker() {\n  if (statusPickerInitialized) return;\n  statusPickerInitialized = true;\n  \n  const statusBtn = document.getElementById('statusBtn');\n  if (!statusBtn) return;\n  \n  statusBtn.addEventListener('click', showStatusPicker);\n  loadCurrentStatus();\n}\n\nfunction loadCurrentStatus() {\n  fetch(`/api/users/${currentUser.id}/status`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      updateStatusDisplay(data.status || 'online', data.customStatus);\n    });\n}\n\nfunction updateStatusDisplay(status, customStatus) {\n  const indicator = document.getElementById('statusIndicator');\n  const statusText = document.getElementById('statusText');\n  if (indicator) {\n    indicator.style.background = statusConfig[status]?.color || '#2ecc71';\n  }\n  if (statusText) {\n    statusText.textContent = customStatus || statusConfig[status]?.label || 'Online';\n  }\n}\n\nfunction showStatusPicker() {\n  const existing = document.getElementById('statusPickerModal');\n  if (existing) existing.remove();\n  \n  const modal = document.createElement('div');\n  modal.id = 'statusPickerModal';\n  modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:10000;display:flex;align-items:center;justify-content:center;';\n  \n  modal.innerHTML = `\n    <div style=\"background:var(--bg-secondary);padding:25px;border-radius:12px;max-width:350px;width:90%;\">\n      <h3 style=\"margin:0 0 20px;color:var(--text);\">Set Your Status</h3>\n      <div id=\"statusOptions\" style=\"display:flex;flex-direction:column;gap:10px;margin-bottom:20px;\">\n        ${Object.entries(statusConfig).filter(([k]) => k !== 'offline').map(([key, val]) => `\n          <button onclick=\"setStatus('${key}')\" style=\"display:flex;align-items:center;gap:10px;padding:12px;background:var(--accent);border:none;border-radius:8px;cursor:pointer;color:var(--text);\">\n            <span style=\"font-size:16px;\">${val.icon}</span>\n            <span>${val.label}</span>\n          </button>\n        `).join('')}\n      </div>\n      <div style=\"margin-bottom:15px;\">\n        <label style=\"display:block;margin-bottom:5px;color:var(--text-light);font-size:12px;\">Custom Status Message</label>\n        <input type=\"text\" id=\"customStatusInput\" placeholder=\"What are you up to?\" maxlength=\"128\"\n          style=\"width:100%;padding:10px;border-radius:6px;border:1px solid var(--accent);background:var(--bg);color:var(--text);box-sizing:border-box;\">\n      </div>\n      <div style=\"display:flex;gap:10px;\">\n        <button onclick=\"saveCustomStatus()\" style=\"flex:1;padding:10px;background:var(--primary);color:white;border:none;border-radius:6px;cursor:pointer;\">Save</button>\n        <button onclick=\"clearCustomStatus()\" style=\"padding:10px;background:var(--accent);color:var(--text);border:none;border-radius:6px;cursor:pointer;\">Clear</button>\n        <button onclick=\"closeStatusPicker()\" style=\"padding:10px;background:var(--accent);color:var(--text);border:none;border-radius:6px;cursor:pointer;\">Close</button>\n      </div>\n    </div>\n  `;\n  \n  modal.addEventListener('click', (e) => {\n    if (e.target === modal) closeStatusPicker();\n  });\n  \n  document.body.appendChild(modal);\n}\n\nfunction setStatus(status) {\n  fetch(`/api/users/${currentUser.id}/status`, {\n    method: 'PATCH',\n    headers: { \n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}` \n    },\n    body: JSON.stringify({ status })\n  })\n    .then(r => r.json())\n    .then(() => {\n      updateStatusDisplay(status, null);\n      closeStatusPicker();\n    });\n}\n\nfunction saveCustomStatus() {\n  const input = document.getElementById('customStatusInput');\n  const customStatus = input.value.trim();\n  \n  fetch(`/api/users/${currentUser.id}/status`, {\n    method: 'PATCH',\n    headers: { \n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}` \n    },\n    body: JSON.stringify({ customStatus })\n  })\n    .then(r => r.json())\n    .then(() => {\n      loadCurrentStatus();\n      closeStatusPicker();\n    });\n}\n\nfunction clearCustomStatus() {\n  fetch(`/api/users/${currentUser.id}/status`, {\n    method: 'PATCH',\n    headers: { \n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}` \n    },\n    body: JSON.stringify({ customStatus: null })\n  })\n    .then(r => r.json())\n    .then(() => {\n      loadCurrentStatus();\n      closeStatusPicker();\n    });\n}\n\nfunction closeStatusPicker() {\n  const modal = document.getElementById('statusPickerModal');\n  if (modal) modal.remove();\n}\n\n// ============== USER PROFILE MODAL ==============\nfunction showUserProfile(userId) {\n  // Guard against undefined or invalid userId\n  if (!userId || userId === 'undefined' || isNaN(userId)) {\n    return;\n  }\n  \n  fetch(`/api/users/${userId}/profile`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(profile => {\n      if (profile.error) {\n        alert(profile.error);\n        return;\n      }\n      renderProfileModal(profile);\n    });\n}\n\nfunction renderProfileModal(profile) {\n  const existing = document.getElementById('profileModal');\n  if (existing) existing.remove();\n  \n  const statusInfo = statusConfig[profile.status] || statusConfig.offline;\n  const isOwnProfile = profile.id === currentUser.id;\n  \n  const modal = document.createElement('div');\n  modal.id = 'profileModal';\n  modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:10000;display:flex;align-items:center;justify-content:center;';\n  \n  modal.innerHTML = `\n    <div style=\"background:var(--bg-secondary);border-radius:12px;max-width:400px;width:90%;overflow:hidden;\">\n      <div style=\"background:linear-gradient(135deg,var(--primary),var(--accent));padding:40px 20px 20px;text-align:center;position:relative;\">\n        <img src=\"${profile.profilePicture || 'https://via.placeholder.com/80'}\" \n          style=\"width:80px;height:80px;border-radius:50%;border:4px solid var(--bg-secondary);\">\n        <div style=\"position:absolute;bottom:15px;right:calc(50% - 50px);width:16px;height:16px;border-radius:50%;background:${statusInfo.color};border:3px solid var(--bg-secondary);\"></div>\n      </div>\n      <div style=\"padding:20px;\">\n        <h2 style=\"margin:0 0 5px;color:var(--text);text-align:center;\">${escapeHtml(profile.username)}</h2>\n        <p style=\"margin:0 0 15px;color:var(--text-light);text-align:center;font-size:13px;\">\n          ${statusInfo.icon} ${profile.customStatus || statusInfo.label}\n        </p>\n        \n        ${profile.mutualServers?.length > 0 ? `\n          <div style=\"margin-bottom:15px;\">\n            <h4 style=\"margin:0 0 8px;color:var(--text);font-size:12px;text-transform:uppercase;\">Mutual Servers (${profile.mutualServers.length})</h4>\n            <div style=\"display:flex;flex-wrap:wrap;gap:5px;\">\n              ${profile.mutualServers.map(s => `<span style=\"background:var(--accent);padding:4px 8px;border-radius:4px;font-size:11px;color:var(--text);\">${escapeHtml(s.name)}</span>`).join('')}\n            </div>\n          </div>\n        ` : ''}\n        \n        ${profile.mutualFriends?.length > 0 ? `\n          <div style=\"margin-bottom:15px;\">\n            <h4 style=\"margin:0 0 8px;color:var(--text);font-size:12px;text-transform:uppercase;\">Mutual Friends (${profile.mutualFriends.length})</h4>\n            <div style=\"display:flex;flex-wrap:wrap;gap:5px;\">\n              ${profile.mutualFriends.map(f => `<span style=\"background:var(--accent);padding:4px 8px;border-radius:4px;font-size:11px;color:var(--text);\">${escapeHtml(f.username)}</span>`).join('')}\n            </div>\n          </div>\n        ` : ''}\n        \n        <p style=\"margin:0 0 15px;color:var(--text-light);font-size:11px;text-align:center;\">\n          Member since ${new Date(profile.createdAt).toLocaleDateString()}\n        </p>\n        \n        ${!isOwnProfile ? `\n          <div style=\"display:flex;gap:10px;justify-content:center;\">\n            ${!profile.friendshipStatus ? `\n              <button onclick=\"sendFriendRequestToUser(${profile.id})\" style=\"padding:10px 20px;background:var(--primary);color:white;border:none;border-radius:6px;cursor:pointer;\">Add Friend</button>\n            ` : profile.friendshipStatus === 'pending' ? `\n              <button disabled style=\"padding:10px 20px;background:var(--accent);color:var(--text-light);border:none;border-radius:6px;\">Pending</button>\n            ` : `\n              <button onclick=\"startDM(${profile.id}, '${escapeHtml(profile.username)}')\" style=\"padding:10px 20px;background:var(--primary);color:white;border:none;border-radius:6px;cursor:pointer;\">Message</button>\n            `}\n            <button onclick=\"toggleBlock(${profile.id}, ${profile.isBlocked})\" style=\"padding:10px 20px;background:${profile.isBlocked ? '#e74c3c' : 'var(--accent)'};color:${profile.isBlocked ? 'white' : 'var(--text)'};border:none;border-radius:6px;cursor:pointer;\">\n              ${profile.isBlocked ? 'Unblock' : 'Block'}\n            </button>\n          </div>\n        ` : ''}\n        \n        <button onclick=\"closeProfileModal()\" style=\"margin-top:15px;width:100%;padding:10px;background:var(--accent);color:var(--text);border:none;border-radius:6px;cursor:pointer;\">Close</button>\n      </div>\n    </div>\n  `;\n  \n  modal.addEventListener('click', (e) => {\n    if (e.target === modal) closeProfileModal();\n  });\n  \n  document.body.appendChild(modal);\n}\n\nfunction closeProfileModal() {\n  const modal = document.getElementById('profileModal');\n  if (modal) modal.remove();\n}\n\nfunction sendFriendRequestToUser(userId) {\n  fetch(`/api/friends/${userId}/request`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        alert('Friend request sent!');\n        closeProfileModal();\n      } else {\n        alert(data.error || 'Failed to send request');\n      }\n    });\n}\n\nfunction startDM(userId, username) {\n  closeProfileModal();\n  selectFriend({ id: userId, username });\n}\n\n// ============== BLOCK SYSTEM ==============\nlet blockedUsers = [];\n\nfunction loadBlockedUsers() {\n  fetch('/api/blocks', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(blocks => {\n      blockedUsers = blocks.map(b => b.blocked_id);\n    });\n}\n\nfunction toggleBlock(userId, currentlyBlocked) {\n  if (currentlyBlocked) {\n    unblockUser(userId);\n  } else {\n    blockUser(userId);\n  }\n}\n\nfunction blockUser(userId) {\n  if (!confirm('Are you sure you want to block this user? They will not be able to message you.')) return;\n  \n  fetch(`/api/blocks/${userId}`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        alert(data.message);\n        blockedUsers.push(userId);\n        closeProfileModal();\n        loadFriends();\n      } else {\n        alert(data.error || 'Failed to block user');\n      }\n    });\n}\n\nfunction unblockUser(userId) {\n  fetch(`/api/blocks/${userId}`, {\n    method: 'DELETE',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        alert('User unblocked');\n        blockedUsers = blockedUsers.filter(id => id !== userId);\n        closeProfileModal();\n      } else {\n        alert(data.error || 'Failed to unblock user');\n      }\n    });\n}\n\nfunction showBlockedUsersList() {\n  fetch('/api/blocks', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(blocks => {\n      const existing = document.getElementById('blockedListModal');\n      if (existing) existing.remove();\n      \n      const modal = document.createElement('div');\n      modal.id = 'blockedListModal';\n      modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:10000;display:flex;align-items:center;justify-content:center;';\n      \n      modal.innerHTML = `\n        <div style=\"background:var(--bg-secondary);padding:25px;border-radius:12px;max-width:350px;width:90%;max-height:60vh;overflow-y:auto;\">\n          <h3 style=\"margin:0 0 20px;color:var(--text);\">Blocked Users (${blocks.length})</h3>\n          ${blocks.length === 0 ? '<p style=\"color:var(--text-light);\">No blocked users</p>' : \n            blocks.map(b => `\n              <div style=\"display:flex;align-items:center;gap:10px;padding:10px;background:var(--accent);border-radius:8px;margin-bottom:8px;\">\n                <img src=\"${b.profile_picture || 'https://via.placeholder.com/32'}\" style=\"width:32px;height:32px;border-radius:50%;\">\n                <span style=\"flex:1;color:var(--text);\">${escapeHtml(b.username)}</span>\n                <button onclick=\"unblockUser(${b.blocked_id});document.getElementById('blockedListModal').remove();\" \n                  style=\"padding:6px 12px;background:#e74c3c;color:white;border:none;border-radius:4px;cursor:pointer;font-size:12px;\">Unblock</button>\n              </div>\n            `).join('')\n          }\n          <button onclick=\"document.getElementById('blockedListModal').remove()\" \n            style=\"margin-top:15px;width:100%;padding:10px;background:var(--accent);color:var(--text);border:none;border-radius:6px;cursor:pointer;\">Close</button>\n        </div>\n      `;\n      \n      modal.addEventListener('click', (e) => {\n        if (e.target === modal) modal.remove();\n      });\n      \n      document.body.appendChild(modal);\n    });\n}\n\n// Initialize new features when page loads\nif (typeof initStatusPicker === 'function') {\n  document.addEventListener('DOMContentLoaded', () => {\n    setTimeout(() => {\n      initStatusPicker();\n      loadBlockedUsers();\n      checkPendingServerSetup();\n    }, 500);\n  });\n}\n\n// ============== SERVER SETUP & CHANNEL MANAGEMENT ==============\nlet currentSetupServerId = null;\nlet currentManageServerId = null;\nlet setupChannels = [];\n\n// Check if user has any servers pending setup\nfunction checkPendingServerSetup() {\n  if (!currentUser) return;\n  \n  fetch(`/api/servers/pending-setup/${currentUser.id}`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(servers => {\n      if (servers && servers.length > 0) {\n        showServerSetupModal(servers[0]);\n      }\n    })\n    .catch(() => {});\n}\n\n// Show server setup modal\nfunction showServerSetupModal(server) {\n  currentSetupServerId = server.id;\n  setupChannels = [{ name: '', id: null }];\n  \n  document.getElementById('setupServerName').textContent = server.name;\n  document.getElementById('serverSetupOverlay').style.display = 'block';\n  document.getElementById('serverSetupModal').style.display = 'block';\n  \n  renderSetupChannels();\n  \n  document.getElementById('addMoreChannelsBtn').onclick = () => {\n    setupChannels.push({ name: '', id: null });\n    renderSetupChannels();\n  };\n  \n  document.getElementById('completeSetupBtn').onclick = completeServerSetup;\n  document.getElementById('serverSetupOverlay').onclick = () => {};\n}\n\nfunction renderSetupChannels() {\n  const list = document.getElementById('channelSetupList');\n  list.innerHTML = setupChannels.map((ch, i) => `\n    <div style=\"display:flex;gap:10px;margin-bottom:10px;align-items:center;\">\n      <span style=\"color:var(--text-light);font-size:18px;\">#</span>\n      <input type=\"text\" \n        class=\"setup-channel-input\" \n        data-index=\"${i}\" \n        value=\"${ch.name}\" \n        placeholder=\"channel-name\"\n        style=\"flex:1;padding:10px;background:var(--bg);border:1px solid var(--accent);border-radius:6px;color:var(--text);\">\n      ${setupChannels.length > 1 ? `<button onclick=\"removeSetupChannel(${i})\" style=\"padding:8px 12px;background:#e74c3c;color:white;border:none;border-radius:6px;cursor:pointer;\">Ã—</button>` : ''}\n    </div>\n  `).join('');\n  \n  document.querySelectorAll('.setup-channel-input').forEach(input => {\n    input.addEventListener('input', (e) => {\n      const idx = parseInt(e.target.dataset.index);\n      setupChannels[idx].name = e.target.value;\n    });\n  });\n}\n\nfunction removeSetupChannel(index) {\n  if (setupChannels.length > 1) {\n    setupChannels.splice(index, 1);\n    renderSetupChannels();\n  }\n}\n\nasync function completeServerSetup() {\n  const validChannels = setupChannels.filter(ch => ch.name.trim().length > 0);\n  \n  if (validChannels.length === 0) {\n    alert('Please name at least one channel');\n    return;\n  }\n  \n  const btn = document.getElementById('completeSetupBtn');\n  btn.disabled = true;\n  btn.textContent = 'Setting up...';\n  \n  try {\n    for (const channel of validChannels) {\n      await fetch(`/api/servers/${currentSetupServerId}/channels`, {\n        method: 'POST',\n        headers: { \n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${getAuthToken()}` \n        },\n        body: JSON.stringify({ name: channel.name })\n      });\n    }\n    \n    await fetch(`/api/servers/${currentSetupServerId}/complete-setup`, {\n      method: 'POST',\n      headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n    });\n    \n    closeServerSetupModal();\n    loadServers();\n    alert('Server setup complete!');\n  } catch (err) {\n    alert('Failed to complete setup. Please try again.');\n  }\n  \n  btn.disabled = false;\n  btn.textContent = 'Complete Setup';\n}\n\nfunction closeServerSetupModal() {\n  document.getElementById('serverSetupOverlay').style.display = 'none';\n  document.getElementById('serverSetupModal').style.display = 'none';\n  currentSetupServerId = null;\n  setupChannels = [];\n}\n\n// Server management modal (for owners)\nfunction openServerManageModal(serverId, serverName) {\n  currentManageServerId = serverId;\n  document.getElementById('manageServerTitle').textContent = serverName + ' Settings';\n  document.getElementById('manageServerNameInput').value = serverName;\n  document.getElementById('serverManageOverlay').style.display = 'block';\n  document.getElementById('serverManageModal').style.display = 'block';\n  \n  loadManageChannels();\n  \n  document.getElementById('serverManageOverlay').onclick = closeServerManageModal;\n}\n\nfunction closeServerManageModal() {\n  document.getElementById('serverManageOverlay').style.display = 'none';\n  document.getElementById('serverManageModal').style.display = 'none';\n  currentManageServerId = null;\n}\n\nfunction loadManageChannels() {\n  fetch(`/api/servers/${currentManageServerId}/channels`)\n    .then(r => r.json())\n    .then(channels => {\n      const list = document.getElementById('manageChannelsList');\n      list.innerHTML = channels.map(ch => `\n        <div style=\"display:flex;gap:10px;margin-bottom:8px;align-items:center;padding:8px;background:var(--bg);border-radius:6px;\">\n          <span style=\"color:var(--text-light);font-size:16px;\">#</span>\n          <input type=\"text\" \n            id=\"channel-name-${ch.id}\" \n            value=\"${escapeHtml(ch.name)}\" \n            style=\"flex:1;padding:8px;background:var(--card);border:1px solid var(--accent);border-radius:4px;color:var(--text);font-size:13px;\">\n          <button onclick=\"renameChannel(${ch.id})\" style=\"padding:6px 12px;background:var(--primary);color:white;border:none;border-radius:4px;cursor:pointer;font-size:12px;\">Save</button>\n          <button onclick=\"openPermissionsModal(${ch.id})\" style=\"padding:6px 12px;background:#9b59b6;color:white;border:none;border-radius:4px;cursor:pointer;font-size:12px;\" title=\"Manage Permissions\">ðŸ”</button>\n          <button onclick=\"deleteChannel(${ch.id})\" style=\"padding:6px 12px;background:#e74c3c;color:white;border:none;border-radius:4px;cursor:pointer;font-size:12px;\">Ã—</button>\n        </div>\n      `).join('');\n    });\n}\n\nfunction renameServer() {\n  const newName = document.getElementById('manageServerNameInput').value.trim();\n  if (!newName) {\n    alert('Server name cannot be empty');\n    return;\n  }\n  \n  fetch(`/api/servers/${currentManageServerId}/rename`, {\n    method: 'PUT',\n    headers: { \n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}` \n    },\n    body: JSON.stringify({ name: newName })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        document.getElementById('manageServerTitle').textContent = newName + ' Settings';\n        loadServers();\n        alert('Server renamed!');\n      } else {\n        alert(data.error || 'Failed to rename server');\n      }\n    });\n}\n\nfunction renameChannel(channelId) {\n  const input = document.getElementById(`channel-name-${channelId}`);\n  const newName = input.value.trim();\n  if (!newName) {\n    alert('Channel name cannot be empty');\n    return;\n  }\n  \n  fetch(`/api/servers/${currentManageServerId}/channels/${channelId}/rename`, {\n    method: 'PUT',\n    headers: { \n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}` \n    },\n    body: JSON.stringify({ name: newName })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        loadServers();\n        loadManageChannels();\n      } else {\n        alert(data.error || 'Failed to rename channel');\n      }\n    });\n}\n\nfunction deleteChannel(channelId) {\n  if (!confirm('Delete this channel? All messages will be lost.')) return;\n  \n  fetch(`/api/servers/${currentManageServerId}/channels/${channelId}`, {\n    method: 'DELETE',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        loadServers();\n        loadManageChannels();\n      } else {\n        alert(data.error || 'Failed to delete channel');\n      }\n    });\n}\n\nfunction addNewChannel() {\n  const input = document.getElementById('newChannelNameInput');\n  const name = input.value.trim();\n  if (!name) {\n    alert('Channel name cannot be empty');\n    return;\n  }\n  \n  fetch(`/api/servers/${currentManageServerId}/channels`, {\n    method: 'POST',\n    headers: { \n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}` \n    },\n    body: JSON.stringify({ name })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        input.value = '';\n        loadServers();\n        loadManageChannels();\n      } else {\n        alert(data.error || 'Failed to add channel');\n      }\n    });\n}\n\n// ============== DISCORD FEATURES ==============\n\n// Reply system\nlet replyingToMessage = null;\nlet pendingAttachment = null;\nlet typingTimeout = null;\nlet unreadCounts = {};\n\n// Common emojis for picker\nconst commonEmojis = ['ðŸ˜€','ðŸ˜‚','ðŸ˜','ðŸ¥°','ðŸ˜Ž','ðŸ¤”','ðŸ˜¢','ðŸ˜¡','ðŸ‘','ðŸ‘Ž','â¤ï¸','ðŸ”¥','â­','ðŸŽ‰','ðŸ’¯','ðŸ™','ðŸ‘','ðŸ¤','ðŸ’ª','âœ¨','ðŸŽ®','ðŸ†','ðŸ’¬','ðŸ“Œ','ðŸ”','âš¡','ðŸ’¡','ðŸŒŸ','ðŸš€','ðŸ’Ž'];\n\n// Initialize Discord features\nfunction initDiscordFeatures() {\n  initEmojiPicker();\n  initTypingIndicator();\n  initFileUpload();\n  initSearchModal();\n  initReplySystem();\n  loadUnreadCounts();\n  \n  document.getElementById('pinsBtn')?.addEventListener('click', openPinsModal);\n  document.getElementById('searchBtn')?.addEventListener('click', openSearchModal);\n}\n\n// Call after DOM is ready\nsetTimeout(initDiscordFeatures, 1000);\n\n// Emoji Picker\nfunction initEmojiPicker() {\n  const grid = document.getElementById('emojiGrid');\n  const btn = document.getElementById('emojiBtn');\n  const picker = document.getElementById('emojiPicker');\n  \n  if (!grid || !btn) return;\n  \n  grid.innerHTML = commonEmojis.map(e => `<button class=\"emoji-btn\" onclick=\"insertEmoji('${e}')\">${e}</button>`).join('');\n  \n  btn.addEventListener('click', () => picker.classList.toggle('active'));\n  \n  document.addEventListener('click', (e) => {\n    if (!picker.contains(e.target) && e.target !== btn) {\n      picker.classList.remove('active');\n    }\n  });\n}\n\nfunction insertEmoji(emoji) {\n  const input = document.getElementById('messageInput');\n  input.value += emoji;\n  input.focus();\n  document.getElementById('emojiPicker').classList.remove('active');\n}\n\n// Typing Indicator\nfunction initTypingIndicator() {\n  const input = document.getElementById('messageInput');\n  if (!input) return;\n  \n  input.addEventListener('input', () => {\n    emitTyping();\n  });\n  \n  input.addEventListener('keydown', (e) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      stopTyping();\n    }\n  });\n}\n\nfunction emitTyping() {\n  if (!socket || !currentUser) return;\n  \n  socket.emit('user_typing', {\n    channelId: currentChannel,\n    groupChatId: currentGroupChat,\n    dmPartnerId: currentFriend,\n    isGlobal: isGlobalChat,\n    userId: currentUser.id,\n    username: currentUser.username\n  });\n  \n  clearTimeout(typingTimeout);\n  typingTimeout = setTimeout(stopTyping, 3000);\n}\n\nfunction stopTyping() {\n  if (!socket || !currentUser) return;\n  \n  socket.emit('user_stop_typing', {\n    channelId: currentChannel,\n    groupChatId: currentGroupChat,\n    dmPartnerId: currentFriend,\n    isGlobal: isGlobalChat,\n    userId: currentUser.id\n  });\n}\n\n// Reply System\nfunction initReplySystem() {\n  document.getElementById('cancelReply')?.addEventListener('click', cancelReply);\n}\n\nfunction setReplyTo(messageId, username, content) {\n  replyingToMessage = { id: messageId, username, content };\n  document.getElementById('replyUsername').textContent = username;\n  document.getElementById('replyContent').textContent = content.substring(0, 100);\n  document.getElementById('replyBar').classList.add('active');\n  document.getElementById('messageInput').focus();\n}\n\nfunction cancelReply() {\n  replyingToMessage = null;\n  document.getElementById('replyBar').classList.remove('active');\n}\n\n// File Upload\nfunction initFileUpload() {\n  const uploadBtn = document.getElementById('uploadBtn');\n  const fileInput = document.getElementById('fileInput');\n  \n  if (!uploadBtn || !fileInput) return;\n  \n  uploadBtn.addEventListener('click', () => fileInput.click());\n  \n  fileInput.addEventListener('change', async (e) => {\n    const file = e.target.files[0];\n    if (!file) return;\n    \n    if (file.size > 10 * 1024 * 1024) {\n      alert('File too large. Max 10MB');\n      return;\n    }\n    \n    const formData = new FormData();\n    formData.append('file', file);\n    \n    try {\n      const res = await fetch('/api/upload', {\n        method: 'POST',\n        headers: { 'Authorization': `Bearer ${getAuthToken()}` },\n        body: formData\n      });\n      const data = await res.json();\n      \n      if (data.success) {\n        pendingAttachment = {\n          url: data.url,\n          filename: data.filename,\n          originalName: data.originalName,\n          type: data.type,\n          size: data.size\n        };\n        \n        const input = document.getElementById('messageInput');\n        if (!input.value.trim()) {\n          input.value = `[Attached: ${data.originalName}]`;\n        }\n        input.focus();\n      }\n    } catch (err) {\n      alert('Failed to upload file');\n    }\n    \n    fileInput.value = '';\n  });\n}\n\n// Search Modal\nfunction initSearchModal() {\n  const input = document.getElementById('searchInput');\n  if (!input) return;\n  \n  let searchTimeout;\n  input.addEventListener('input', () => {\n    clearTimeout(searchTimeout);\n    searchTimeout = setTimeout(() => performSearch(input.value), 300);\n  });\n}\n\nfunction openSearchModal() {\n  document.getElementById('searchOverlay').style.display = 'block';\n  document.getElementById('searchModal').classList.add('active');\n  document.getElementById('searchInput').focus();\n}\n\nfunction closeSearchModal() {\n  document.getElementById('searchOverlay').style.display = 'none';\n  document.getElementById('searchModal').classList.remove('active');\n  document.getElementById('searchInput').value = '';\n  document.getElementById('searchResults').innerHTML = '<p style=\"color:var(--text-light);text-align:center;\">Enter at least 2 characters to search</p>';\n}\n\nfunction performSearch(query) {\n  const results = document.getElementById('searchResults');\n  if (query.length < 2) {\n    results.innerHTML = '<p style=\"color:var(--text-light);text-align:center;\">Enter at least 2 characters to search</p>';\n    return;\n  }\n  \n  fetch(`/api/search/messages?q=${encodeURIComponent(query)}&channelId=${currentChannel || ''}&limit=20`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(messages => {\n      if (messages.length === 0) {\n        results.innerHTML = '<p style=\"color:var(--text-light);text-align:center;\">No messages found</p>';\n        return;\n      }\n      \n      results.innerHTML = messages.map(m => `\n        <div class=\"search-result\" onclick=\"jumpToMessage(${m.id})\">\n          <div style=\"display:flex;align-items:center;gap:8px;margin-bottom:4px;\">\n            <img src=\"${m.profile_picture || 'https://via.placeholder.com/24'}\" style=\"width:24px;height:24px;border-radius:50%;\">\n            <strong style=\"color:var(--text);\">${escapeHtml(m.username)}</strong>\n            <span style=\"font-size:11px;color:var(--text-light);\">${formatDate(m.created_at)}</span>\n          </div>\n          <div style=\"color:var(--text);\">${highlightSearch(escapeHtml(m.content), query)}</div>\n          ${m.server_name ? `<div style=\"font-size:11px;color:var(--text-light);\">in #${m.channel_name} - ${m.server_name}</div>` : ''}\n        </div>\n      `).join('');\n    });\n}\n\nfunction highlightSearch(text, query) {\n  const regex = new RegExp(`(${query})`, 'gi');\n  return text.replace(regex, '<mark style=\"background:var(--primary);color:white;padding:0 2px;border-radius:2px;\">$1</mark>');\n}\n\nfunction jumpToMessage(messageId) {\n  closeSearchModal();\n  const msgEl = document.querySelector(`[data-msg-id=\"${messageId}\"]`);\n  if (msgEl) {\n    msgEl.scrollIntoView({ behavior: 'smooth', block: 'center' });\n    msgEl.style.animation = 'flash 1s';\n    setTimeout(() => msgEl.style.animation = '', 1000);\n  }\n}\n\n// Pins Modal\nfunction openPinsModal() {\n  document.getElementById('pinsOverlay').style.display = 'block';\n  document.getElementById('pinsModal').classList.add('active');\n  loadPinnedMessages();\n}\n\nfunction closePinsModal() {\n  document.getElementById('pinsOverlay').style.display = 'none';\n  document.getElementById('pinsModal').classList.remove('active');\n}\n\nfunction loadPinnedMessages() {\n  const list = document.getElementById('pinnedMessagesList');\n  const endpoint = currentChannel ? `/api/pins/channel/${currentChannel}` : \n                   currentGroupChat ? `/api/pins/group/${currentGroupChat}` : null;\n  \n  if (!endpoint) {\n    list.innerHTML = '<p style=\"color:var(--text-light);text-align:center;\">Select a channel to view pins</p>';\n    return;\n  }\n  \n  fetch(endpoint, { headers: { 'Authorization': `Bearer ${getAuthToken()}` } })\n    .then(r => r.json())\n    .then(pins => {\n      if (pins.length === 0) {\n        list.innerHTML = '<p style=\"color:var(--text-light);text-align:center;\">No pinned messages</p>';\n        return;\n      }\n      \n      list.innerHTML = pins.map(p => `\n        <div class=\"search-result\">\n          <div style=\"display:flex;align-items:center;gap:8px;margin-bottom:4px;\">\n            <img src=\"${p.profile_picture || 'https://via.placeholder.com/24'}\" style=\"width:24px;height:24px;border-radius:50%;\">\n            <strong style=\"color:var(--text);\">${escapeHtml(p.username)}</strong>\n          </div>\n          <div style=\"color:var(--text);\">${escapeHtml(p.content)}</div>\n          <div style=\"font-size:11px;color:var(--text-light);margin-top:4px;\">Pinned by ${p.pinned_by_username}</div>\n        </div>\n      `).join('');\n    });\n}\n\nfunction pinMessage(messageId) {\n  fetch(`/api/pins/${messageId}`, {\n    method: 'POST',\n    headers: { \n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}` \n    },\n    body: JSON.stringify({ \n      channelId: currentChannel, \n      groupChatId: currentGroupChat \n    })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        alert('Message pinned!');\n      } else {\n        alert(data.error || 'Failed to pin message');\n      }\n    });\n}\n\nfunction unpinMessage(messageId) {\n  fetch(`/api/pins/${messageId}`, {\n    method: 'DELETE',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        alert('Message unpinned');\n        loadPinnedMessages();\n      }\n    });\n}\n\n// Invite System\nlet currentInviteServerId = null;\nlet previewTimeout = null;\n\nfunction showCreateInviteModal(serverId) {\n  currentInviteServerId = serverId;\n  document.getElementById('inviteExpiry').value = '24';\n  document.getElementById('inviteMaxUses').value = '0';\n  document.getElementById('createInviteOverlay').style.display = 'block';\n  document.getElementById('createInviteModal').classList.add('active');\n}\n\nfunction closeCreateInviteModal() {\n  document.getElementById('createInviteOverlay').style.display = 'none';\n  document.getElementById('createInviteModal').classList.remove('active');\n  currentInviteServerId = null;\n}\n\nfunction generateInvite() {\n  if (!currentInviteServerId) return;\n  \n  const expiresIn = document.getElementById('inviteExpiry').value;\n  const maxUses = document.getElementById('inviteMaxUses').value;\n  \n  fetch(`/api/invites/server/${currentInviteServerId}`, {\n    method: 'POST',\n    headers: { \n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}` \n    },\n    body: JSON.stringify({ maxUses: parseInt(maxUses), expiresIn: parseInt(expiresIn) })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        closeCreateInviteModal();\n        document.getElementById('inviteCode').textContent = data.code;\n        \n        let details = [];\n        if (expiresIn === '0') {\n          details.push('Never expires');\n        } else if (expiresIn === '1') {\n          details.push('Expires in 1 hour');\n        } else if (expiresIn === '24') {\n          details.push('Expires in 24 hours');\n        } else if (expiresIn === '168') {\n          details.push('Expires in 7 days');\n        } else {\n          details.push(`Expires in ${expiresIn} hours`);\n        }\n        if (maxUses === '0') {\n          details.push('Unlimited uses');\n        } else {\n          details.push(`${maxUses} use${maxUses === '1' ? '' : 's'} max`);\n        }\n        document.getElementById('inviteDetails').textContent = details.join(' â€¢ ');\n        \n        document.getElementById('inviteOverlay').style.display = 'block';\n        document.getElementById('inviteModal').classList.add('active');\n      } else {\n        alert(data.error || 'Failed to create invite. Please try again.');\n      }\n    })\n    .catch(() => {\n      alert('Network error. Please try again.');\n    });\n}\n\nfunction createServerInvite(serverId) {\n  showCreateInviteModal(serverId);\n}\n\nfunction closeInviteModal() {\n  document.getElementById('inviteOverlay').style.display = 'none';\n  document.getElementById('inviteModal').classList.remove('active');\n}\n\nfunction copyInviteCode() {\n  const code = document.getElementById('inviteCode').textContent;\n  navigator.clipboard.writeText(code).then(() => {\n    alert('Invite code copied to clipboard!');\n  });\n}\n\nfunction showServerInvites(serverId, serverName) {\n  const list = document.getElementById('invitesList');\n  list.innerHTML = '<p style=\"color:var(--text-light);text-align:center;\">Loading invites...</p>';\n  document.getElementById('viewInvitesOverlay').style.display = 'block';\n  document.getElementById('viewInvitesModal').classList.add('active');\n  \n  fetch(`/api/invites/server/${serverId}`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(invites => {\n      if (!invites || invites.length === 0) {\n        list.innerHTML = `\n          <div style=\"text-align:center;padding:20px;\">\n            <p style=\"color:var(--text-light);margin-bottom:15px;\">No active invites for this server</p>\n            <button onclick=\"closeViewInvitesModal();showCreateInviteModal(${serverId})\" \n                    style=\"padding:10px 20px;background:var(--primary);color:white;border:none;border-radius:6px;cursor:pointer;\">\n              Create New Invite\n            </button>\n          </div>\n        `;\n      } else {\n        list.innerHTML = invites.map(inv => {\n          if (!inv || !inv.code) return '';\n          const expiresText = inv.expires_at ? \n            `Expires: ${new Date(inv.expires_at).toLocaleString()}` : \n            'Never expires';\n          const usesText = inv.max_uses > 0 ? \n            `${inv.uses || 0}/${inv.max_uses} uses` : \n            `${inv.uses || 0} uses`;\n          const createdBy = inv.created_by_username ? escapeHtml(inv.created_by_username) : 'Unknown';\n          return `\n            <div style=\"display:flex;align-items:center;justify-content:space-between;padding:12px;background:var(--bg);border-radius:8px;margin-bottom:8px;\">\n              <div>\n                <div style=\"font-family:monospace;font-size:16px;color:var(--primary);letter-spacing:2px;\">${inv.code}</div>\n                <div style=\"font-size:11px;color:var(--text-light);margin-top:4px;\">\n                  Created by ${createdBy} â€¢ ${usesText}\n                </div>\n                <div style=\"font-size:10px;color:var(--text-light);\">${expiresText}</div>\n              </div>\n              <div style=\"display:flex;gap:6px;\">\n                <button onclick=\"navigator.clipboard.writeText('${inv.code}').then(()=>alert('Copied!'))\" \n                        style=\"padding:6px 12px;background:var(--primary);color:white;border:none;border-radius:4px;cursor:pointer;font-size:11px;\">\n                  Copy\n                </button>\n                <button onclick=\"deleteInvite(${inv.id})\" \n                        style=\"padding:6px 12px;background:#e74c3c;color:white;border:none;border-radius:4px;cursor:pointer;font-size:11px;\">\n                  Delete\n                </button>\n              </div>\n            </div>\n          `;\n        }).join('');\n      }\n    })\n    .catch(() => {\n      list.innerHTML = '<p style=\"color:#e74c3c;text-align:center;\">Failed to load invites. Please try again.</p>';\n    });\n}\n\nfunction closeViewInvitesModal() {\n  document.getElementById('viewInvitesOverlay').style.display = 'none';\n  document.getElementById('viewInvitesModal').classList.remove('active');\n}\n\nfunction deleteInvite(inviteId) {\n  if (!confirm('Delete this invite?')) return;\n  \n  fetch(`/api/invites/${inviteId}`, {\n    method: 'DELETE',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        closeViewInvitesModal();\n      } else {\n        alert(data.error || 'Failed to delete invite');\n      }\n    });\n}\n\nfunction resetJoinPreview() {\n  if (previewTimeout) {\n    clearTimeout(previewTimeout);\n    previewTimeout = null;\n  }\n  const preview = document.getElementById('invitePreview');\n  const error = document.getElementById('inviteError');\n  if (preview) {\n    preview.style.display = 'none';\n    document.getElementById('previewServerName').textContent = '';\n    document.getElementById('previewMemberCount').textContent = '';\n    document.getElementById('previewCreatedBy').textContent = '';\n  }\n  if (error) {\n    error.style.display = 'none';\n    error.textContent = '';\n  }\n}\n\nfunction openJoinServerModal() {\n  resetJoinPreview();\n  document.getElementById('joinCodeInput').value = '';\n  document.getElementById('joinServerOverlay').style.display = 'block';\n  document.getElementById('joinServerModal').classList.add('active');\n  document.getElementById('joinCodeInput').focus();\n}\n\nfunction closeJoinServerModal() {\n  resetJoinPreview();\n  document.getElementById('joinServerOverlay').style.display = 'none';\n  document.getElementById('joinServerModal').classList.remove('active');\n  document.getElementById('joinCodeInput').value = '';\n}\n\nfunction previewInvite(code) {\n  if (previewTimeout) {\n    clearTimeout(previewTimeout);\n    previewTimeout = null;\n  }\n  \n  const preview = document.getElementById('invitePreview');\n  const error = document.getElementById('inviteError');\n  \n  const trimmedCode = code.trim();\n  if (trimmedCode.length < 8) {\n    preview.style.display = 'none';\n    error.style.display = 'none';\n    document.getElementById('previewServerName').textContent = '';\n    document.getElementById('previewMemberCount').textContent = '';\n    document.getElementById('previewCreatedBy').textContent = '';\n    return;\n  }\n  \n  previewTimeout = setTimeout(() => {\n    fetch(`/api/invites/code/${trimmedCode.toUpperCase()}`)\n      .then(r => r.json())\n      .then(data => {\n        if (data.error) {\n          preview.style.display = 'none';\n          error.style.display = 'block';\n          error.textContent = data.error;\n        } else {\n          error.style.display = 'none';\n          preview.style.display = 'block';\n          document.getElementById('previewServerName').textContent = data.server_name || 'Unknown Server';\n          document.getElementById('previewMemberCount').textContent = `${data.member_count || 0} member${data.member_count !== 1 ? 's' : ''}`;\n          document.getElementById('previewCreatedBy').textContent = `Invited by ${data.created_by_username || 'Unknown'}`;\n        }\n      })\n      .catch(() => {\n        preview.style.display = 'none';\n        error.style.display = 'block';\n        error.textContent = 'Unable to verify invite code';\n      });\n  }, 300);\n}\n\nfunction joinServerByCode() {\n  const code = document.getElementById('joinCodeInput').value.trim();\n  if (!code) {\n    alert('Please enter an invite code');\n    return;\n  }\n  \n  fetch(`/api/invites/join/${code}`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        alert(data.message || 'Successfully joined the server!');\n        closeJoinServerModal();\n        loadServers();\n      } else {\n        document.getElementById('inviteError').style.display = 'block';\n        document.getElementById('inviteError').textContent = data.error || 'Failed to join server';\n      }\n    });\n}\n\n// Reactions\nfunction addReaction(messageId, emoji) {\n  fetch(`/api/reactions/${messageId}`, {\n    method: 'POST',\n    headers: { \n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}` \n    },\n    body: JSON.stringify({ emoji })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        socket.emit(data.action === 'added' ? 'add_reaction' : 'remove_reaction', {\n          messageId, emoji, userId: currentUser.id, username: currentUser.username\n        });\n        loadReactionsForMessage(messageId);\n      }\n    });\n}\n\nfunction loadReactionsForMessage(messageId) {\n  fetch(`/api/reactions/${messageId}`)\n    .then(r => r.json())\n    .then(reactions => {\n      const container = document.querySelector(`[data-msg-id=\"${messageId}\"] .msg-reactions`);\n      if (!container) return;\n      \n      container.innerHTML = reactions.map(r => `\n        <button class=\"msg-reaction ${r.userIds.includes(currentUser.id) ? 'user-reacted' : ''}\"\n                onclick=\"addReaction(${messageId}, '${r.emoji}')\"\n                title=\"${r.users.join(', ')}\">\n          ${r.emoji} ${r.count}\n        </button>\n      `).join('') + `<button class=\"msg-reaction\" onclick=\"showReactionPicker(${messageId})\">+</button>`;\n    });\n}\n\nfunction showReactionPicker(messageId) {\n  const picker = prompt('Enter an emoji:');\n  if (picker && picker.trim()) {\n    addReaction(messageId, picker.trim());\n  }\n}\n\n// Message Editing\nfunction editMessage(messageId) {\n  const msgEl = document.querySelector(`[data-msg-id=\"${messageId}\"] .msg-content`);\n  if (!msgEl) return;\n  \n  const currentContent = msgEl.textContent;\n  const newContent = prompt('Edit message:', currentContent);\n  \n  if (newContent !== null && newContent !== currentContent) {\n    socket.emit('edit_message', {\n      messageId,\n      newContent,\n      userId: currentUser.id\n    });\n  }\n}\n\n// Unread Counts\nfunction loadUnreadCounts() {\n  if (!currentUser) return;\n  \n  fetch(`/api/messages/unread/${currentUser.id}`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(counts => {\n      unreadCounts = counts;\n      updateUnreadBadges();\n    })\n    .catch(() => {});\n}\n\nfunction updateUnreadBadges() {\n  document.querySelectorAll('.unread-badge').forEach(b => b.remove());\n  \n  for (const [key, count] of Object.entries(unreadCounts)) {\n    if (count > 0) {\n      let selector = null;\n      if (key === 'global') {\n        selector = '#globalChatBtn';\n      } else if (key.startsWith('channel-')) {\n        const channelId = key.split('-')[1];\n        selector = `.channel-btn[data-channel-id=\"${channelId}\"]`;\n      } else if (key.startsWith('group-')) {\n        const groupId = key.split('-')[1];\n        selector = `.group-btn[data-group-id=\"${groupId}\"]`;\n      }\n      \n      if (selector) {\n        const el = document.querySelector(selector);\n        if (el && !el.querySelector('.unread-badge')) {\n          const badge = document.createElement('span');\n          badge.className = 'unread-badge';\n          badge.textContent = count > 99 ? '99+' : count;\n          el.appendChild(badge);\n        }\n      }\n    }\n  }\n}\n\nfunction markAsRead() {\n  if (!currentUser) return;\n  \n  const lastMsg = document.querySelector('.message:last-child');\n  const lastMessageId = lastMsg ? parseInt(lastMsg.dataset.msgId) : 0;\n  \n  socket.emit('mark_read', {\n    userId: currentUser.id,\n    channelId: currentChannel,\n    groupChatId: currentGroupChat,\n    dmPartnerId: currentFriend,\n    isGlobal: isGlobalChat,\n    lastMessageId\n  });\n  \n  const key = currentChannel ? `channel-${currentChannel}` :\n              currentGroupChat ? `group-${currentGroupChat}` :\n              currentFriend ? `dm-${currentFriend}` :\n              isGlobalChat ? 'global' : null;\n  \n  if (key) {\n    delete unreadCounts[key];\n    updateUnreadBadges();\n  }\n}\n\n// Format mentions in message content\nfunction formatMentions(content) {\n  return content.replace(/@(\\w+)/g, '<span class=\"mention\" onclick=\"viewUserProfile(\\'$1\\')\">@$1</span>');\n}\n\n// Socket listeners for Discord features\nlet discordSocketListenersInitialized = false;\nfunction setupDiscordSocketListeners() {\n  if (!socket) return;\n  if (discordSocketListenersInitialized) return;\n  discordSocketListenersInitialized = true;\n  \n  socket.on('user_typing', (data) => {\n    if (data.userId === currentUser?.id) return;\n    const indicator = document.getElementById('typingIndicator');\n    if (indicator) {\n      indicator.textContent = `${data.username} is typing...`;\n      indicator.classList.add('active');\n    }\n  });\n  \n  socket.on('user_stop_typing', (data) => {\n    const indicator = document.getElementById('typingIndicator');\n    if (indicator) {\n      indicator.classList.remove('active');\n    }\n  });\n  \n  socket.on('reaction_added', (data) => {\n    loadReactionsForMessage(data.messageId);\n  });\n  \n  socket.on('reaction_removed', (data) => {\n    loadReactionsForMessage(data.messageId);\n  });\n  \n  socket.on('message_edited', (data) => {\n    const msgEl = document.querySelector(`[data-msg-id=\"${data.messageId}\"] .msg-content`);\n    if (msgEl) {\n      msgEl.textContent = data.newContent;\n      const editedSpan = msgEl.parentElement.querySelector('.msg-edited');\n      if (!editedSpan) {\n        const span = document.createElement('span');\n        span.className = 'msg-edited';\n        span.textContent = '(edited)';\n        msgEl.after(span);\n      }\n    }\n  });\n  \n  socket.on('mention_notification', (data) => {\n    if (Notification.permission === 'granted') {\n      new Notification(`${data.fromUsername} mentioned you`, {\n        body: data.content,\n        icon: '/favicon.ico'\n      });\n    }\n    showMentionToast(data);\n  });\n}\n\nfunction showMentionToast(data) {\n  const toast = document.createElement('div');\n  toast.style.cssText = 'position:fixed;bottom:80px;right:20px;background:var(--primary);color:white;padding:12px 20px;border-radius:8px;z-index:1000;animation:slideIn 0.3s ease;';\n  toast.innerHTML = `<strong>@${escapeHtml(data.fromUsername)}</strong> mentioned you`;\n  document.body.appendChild(toast);\n  setTimeout(() => toast.remove(), 4000);\n}\n\n// Request notification permission\nif (Notification.permission === 'default') {\n  Notification.requestPermission();\n}\n\n// Call socket setup after socket is initialized\nsetTimeout(setupDiscordSocketListeners, 1500);\n\n// ============== PHASE 2: ROLES & PERMISSIONS ==============\n\nlet currentSettingsServerId = null;\nlet currentSelectedRole = null;\nlet serverRoles = [];\nlet serverMembers = [];\n\n// PERMISSION_LABELS is defined in permissions.js\n\nfunction openServerSettings(serverId) {\n  currentSettingsServerId = serverId;\n  document.getElementById('serverSettingsOverlay').style.display = 'block';\n  document.getElementById('serverSettingsModal').classList.add('active');\n  \n  document.querySelectorAll('.settings-tab').forEach(tab => {\n    tab.addEventListener('click', () => switchSettingsTab(tab.dataset.tab));\n  });\n  \n  loadRoles();\n}\n\nfunction closeServerSettings() {\n  document.getElementById('serverSettingsOverlay').style.display = 'none';\n  document.getElementById('serverSettingsModal').classList.remove('active');\n  currentSettingsServerId = null;\n  currentSelectedRole = null;\n}\n\nfunction switchSettingsTab(tabName) {\n  document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));\n  document.querySelectorAll('.settings-panel').forEach(p => p.classList.remove('active'));\n  \n  document.querySelector(`.settings-tab[data-tab=\"${tabName}\"]`).classList.add('active');\n  document.getElementById(`${tabName}Panel`).classList.add('active');\n  \n  if (tabName === 'roles') loadRoles();\n  else if (tabName === 'categories') loadCategories();\n  else if (tabName === 'members') loadServerMembers();\n  else if (tabName === 'audit') loadAuditLog();\n}\n\nfunction loadRoles() {\n  if (!currentSettingsServerId) return;\n  \n  fetch(`/api/roles/server/${currentSettingsServerId}`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(roles => {\n      serverRoles = roles;\n      const list = document.getElementById('rolesList');\n      list.innerHTML = roles.map(role => `\n        <div class=\"role-item ${currentSelectedRole?.id === role.id ? 'active' : ''}\" \n             onclick=\"selectRole(${role.id})\" data-role-id=\"${role.id}\">\n          <div class=\"role-color\" style=\"background:${role.color}\"></div>\n          <span class=\"role-name\">${escapeHtml(role.name)}</span>\n        </div>\n      `).join('');\n    });\n}\n\nfunction selectRole(roleId) {\n  currentSelectedRole = serverRoles.find(r => r.id === roleId);\n  if (!currentSelectedRole) return;\n  \n  document.querySelectorAll('.role-item').forEach(item => {\n    item.classList.toggle('active', parseInt(item.dataset.roleId) === roleId);\n  });\n  \n  const editor = document.getElementById('roleEditor');\n  const permissions = currentSelectedRole.permissions || {};\n  const isEveryone = currentSelectedRole.name === '@everyone';\n  \n  editor.innerHTML = `\n    <div class=\"role-form\">\n      <div class=\"form-group\">\n        <label>Role Name</label>\n        <input type=\"text\" id=\"roleName\" value=\"${escapeHtml(currentSelectedRole.name)}\" ${isEveryone ? 'disabled' : ''}>\n      </div>\n      <div class=\"form-group\">\n        <label>Role Color</label>\n        <input type=\"color\" id=\"roleColor\" value=\"${currentSelectedRole.color || '#99AAB5'}\">\n      </div>\n      <div class=\"form-group\">\n        <label>Permissions</label>\n        <div class=\"permissions-grid\">\n          ${Object.entries(PERMISSION_LABELS).map(([key, label]) => `\n            <div class=\"permission-item\">\n              <input type=\"checkbox\" id=\"perm_${key}\" ${permissions[key] ? 'checked' : ''}>\n              <label for=\"perm_${key}\">${label}</label>\n            </div>\n          `).join('')}\n        </div>\n      </div>\n      <div class=\"role-actions\">\n        <button class=\"save-role-btn\" onclick=\"saveRole()\">Save Changes</button>\n        ${!isEveryone ? `<button class=\"delete-role-btn\" onclick=\"deleteRole(${roleId})\">Delete Role</button>` : ''}\n      </div>\n    </div>\n  `;\n}\n\nfunction createNewRole() {\n  const name = prompt('Role name:');\n  if (!name) return;\n  \n  fetch(`/api/roles/server/${currentSettingsServerId}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}`\n    },\n    body: JSON.stringify({ name, color: '#99AAB5' })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        loadRoles();\n        alert('Role created!');\n      } else {\n        alert(data.error || 'Failed to create role');\n      }\n    });\n}\n\nfunction saveRole() {\n  if (!currentSelectedRole) return;\n  \n  const name = document.getElementById('roleName').value;\n  const color = document.getElementById('roleColor').value;\n  const permissions = {};\n  \n  Object.keys(PERMISSION_LABELS).forEach(key => {\n    const checkbox = document.getElementById(`perm_${key}`);\n    if (checkbox?.checked) permissions[key] = true;\n  });\n  \n  fetch(`/api/roles/server/${currentSettingsServerId}/${currentSelectedRole.id}`, {\n    method: 'PUT',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}`\n    },\n    body: JSON.stringify({ name, color, permissions })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        loadRoles();\n        alert('Role saved!');\n      } else {\n        alert(data.error || 'Failed to save role');\n      }\n    });\n}\n\nfunction deleteRole(roleId) {\n  if (!confirm('Delete this role? Members will lose it.')) return;\n  \n  fetch(`/api/roles/server/${currentSettingsServerId}/${roleId}`, {\n    method: 'DELETE',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        currentSelectedRole = null;\n        document.getElementById('roleEditor').innerHTML = '<p class=\"no-role-selected\">Select a role to edit</p>';\n        loadRoles();\n      } else {\n        alert(data.error || 'Failed to delete role');\n      }\n    });\n}\n\nfunction loadCategories() {\n  if (!currentSettingsServerId) return;\n  \n  fetch(`/api/categories/server/${currentSettingsServerId}`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(categories => {\n      const list = document.getElementById('categoriesList');\n      if (categories.length === 0) {\n        list.innerHTML = '<p style=\"color:var(--text-light);text-align:center;\">No categories yet</p>';\n        return;\n      }\n      \n      list.innerHTML = categories.map(cat => `\n        <div class=\"category-item\" data-category-id=\"${cat.id}\">\n          <input type=\"text\" value=\"${escapeHtml(cat.name)}\" id=\"cat_${cat.id}\">\n          <button onclick=\"renameCategory(${cat.id})\" style=\"background:var(--primary);color:white;\">Save</button>\n          <button onclick=\"deleteCategory(${cat.id})\" style=\"background:#e74c3c;color:white;\">Delete</button>\n        </div>\n      `).join('');\n    });\n}\n\nfunction createNewCategory() {\n  const name = prompt('Category name:');\n  if (!name) return;\n  \n  fetch(`/api/categories/server/${currentSettingsServerId}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}`\n    },\n    body: JSON.stringify({ name })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        loadCategories();\n        loadServers();\n      } else {\n        alert(data.error || 'Failed to create category');\n      }\n    });\n}\n\nfunction renameCategory(categoryId) {\n  const name = document.getElementById(`cat_${categoryId}`).value.trim();\n  if (!name) return;\n  \n  fetch(`/api/categories/server/${currentSettingsServerId}/${categoryId}`, {\n    method: 'PUT',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}`\n    },\n    body: JSON.stringify({ name })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        loadServers();\n        alert('Category renamed!');\n      }\n    });\n}\n\nfunction deleteCategory(categoryId) {\n  if (!confirm('Delete this category? Channels will be moved to uncategorized.')) return;\n  \n  fetch(`/api/categories/server/${currentSettingsServerId}/${categoryId}`, {\n    method: 'DELETE',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        loadCategories();\n        loadServers();\n      }\n    });\n}\n\nfunction loadServerMembers() {\n  if (!currentSettingsServerId) return;\n  \n  fetch(`/api/roles/server/${currentSettingsServerId}/members`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(members => {\n      serverMembers = members;\n      renderMembers(members);\n    });\n}\n\nfunction renderMembers(members) {\n  const list = document.getElementById('membersList');\n  list.innerHTML = members.map(m => `\n    <div class=\"member-item\">\n      <img src=\"${m.profilePicture || 'https://via.placeholder.com/36'}\" alt=\"\">\n      <div class=\"member-info\">\n        <div class=\"member-name\" style=\"color:${m.color}\">${escapeHtml(m.username)}</div>\n        <div class=\"member-roles\">\n          ${m.roles.map(r => `<span class=\"member-role-tag\">${escapeHtml(r.name)}</span>`).join('')}\n        </div>\n      </div>\n      <button onclick=\"manageMemberRoles(${m.id})\" style=\"padding:6px 12px;background:var(--accent);border:none;border-radius:4px;cursor:pointer;\">Manage</button>\n    </div>\n  `).join('');\n}\n\nfunction filterMembers(query) {\n  const filtered = serverMembers.filter(m => \n    m.username.toLowerCase().includes(query.toLowerCase())\n  );\n  renderMembers(filtered);\n}\n\nfunction manageMemberRoles(userId) {\n  const member = serverMembers.find(m => m.id === userId);\n  if (!member) return;\n  \n  const memberRoleIds = member.roles.map(r => r.id);\n  const options = serverRoles.map(role => {\n    const hasRole = memberRoleIds.includes(role.id);\n    return `${role.name}: ${hasRole ? 'Has' : 'No'}`;\n  }).join('\\n');\n  \n  const action = prompt(`Roles for ${member.username}:\\n${options}\\n\\nEnter role name to toggle:`);\n  if (!action) return;\n  \n  const role = serverRoles.find(r => r.name.toLowerCase() === action.toLowerCase());\n  if (!role) {\n    alert('Role not found');\n    return;\n  }\n  \n  const hasRole = memberRoleIds.includes(role.id);\n  const method = hasRole ? 'DELETE' : 'POST';\n  const url = hasRole \n    ? `/api/roles/server/${currentSettingsServerId}/member/${userId}/${role.id}`\n    : `/api/roles/server/${currentSettingsServerId}/member/${userId}`;\n  \n  fetch(url, {\n    method,\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${getAuthToken()}`\n    },\n    body: hasRole ? null : JSON.stringify({ roleId: role.id })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        loadServerMembers();\n      } else {\n        alert(data.error || 'Failed to update role');\n      }\n    });\n}\n\nfunction loadAuditLog() {\n  if (!currentSettingsServerId) return;\n  \n  fetch(`/api/audit/server/${currentSettingsServerId}?limit=50`, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(logs => {\n      const list = document.getElementById('auditLogList');\n      if (logs.length === 0) {\n        list.innerHTML = '<p style=\"color:var(--text-light);text-align:center;\">No audit log entries</p>';\n        return;\n      }\n      \n      list.innerHTML = logs.map(log => `\n        <div class=\"audit-item\">\n          <img src=\"${log.actor.profilePicture || 'https://via.placeholder.com/32'}\" alt=\"\">\n          <div class=\"audit-info\">\n            <div class=\"audit-action\">\n              <strong>${escapeHtml(log.actor.username)}</strong> ${formatAuditAction(log)}\n            </div>\n            <div class=\"audit-time\">${new Date(log.createdAt).toLocaleString()}</div>\n          </div>\n        </div>\n      `).join('');\n    })\n    .catch(() => {\n      document.getElementById('auditLogList').innerHTML = '<p style=\"color:var(--text-light);text-align:center;\">Unable to load audit log</p>';\n    });\n}\n\nfunction formatAuditAction(log) {\n  const actions = {\n    ROLE_CREATE: 'created a role',\n    ROLE_UPDATE: 'updated a role',\n    ROLE_DELETE: 'deleted a role',\n    ROLE_ASSIGN: 'assigned a role',\n    ROLE_REMOVE: 'removed a role',\n    CHANNEL_CREATE: 'created a channel',\n    CHANNEL_DELETE: 'deleted a channel',\n    MEMBER_KICK: 'kicked a member',\n    MEMBER_BAN: 'banned a member'\n  };\n  return actions[log.actionType] || log.actionType.toLowerCase().replace(/_/g, ' ');\n}\n\n// ============== SHOP SYSTEM ==============\nlet shopCategories = [];\nlet shopItems = [];\nlet userInventory = [];\nlet userEquipped = {};\nlet currentShopCategory = null;\nlet userCoins = 0;\n\nlet shopInitialized = false;\nfunction initShop() {\n  if (shopInitialized) return;\n  shopInitialized = true;\n  \n  const shopBtn = document.getElementById('openShopBtn');\n  if (shopBtn) shopBtn.addEventListener('click', openShop);\n  loadUserCoins();\n  loadUserEquipped();\n}\n\nfunction loadUserCoins() {\n  fetch('/api/shop/wallet', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      userCoins = data.coins || 0;\n      updateCoinDisplays();\n    })\n    .catch(() => {});\n}\n\nfunction updateCoinDisplays() {\n  const coinDisplay = document.getElementById('coinDisplay');\n  const shopBalance = document.getElementById('shopCoinBalance');\n  if (coinDisplay) coinDisplay.textContent = `${userCoins} ðŸª™`;\n  if (shopBalance) shopBalance.textContent = userCoins;\n}\n\nfunction openShop() {\n  document.getElementById('shopOverlay').style.display = 'block';\n  document.getElementById('shopModal').style.display = 'block';\n  loadShopCategories();\n  loadUserCoins();\n  checkDailyRewardStatus();\n  \n  fetch('/api/shop/inventory', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(items => {\n      userInventory = items || [];\n      loadShopItems();\n    })\n    .catch(() => {\n      userInventory = [];\n      loadShopItems();\n    });\n}\n\nfunction closeShop() {\n  document.getElementById('shopOverlay').style.display = 'none';\n  document.getElementById('shopModal').style.display = 'none';\n}\n\nfunction switchShopTab(tab) {\n  document.querySelectorAll('.shop-tab').forEach(btn => {\n    btn.style.background = btn.dataset.tab === tab ? 'var(--primary)' : 'var(--bg)';\n    btn.style.color = btn.dataset.tab === tab ? 'white' : 'var(--text)';\n  });\n  \n  document.getElementById('browseTab').style.display = tab === 'browse' ? 'flex' : 'none';\n  document.getElementById('inventoryTab').style.display = tab === 'inventory' ? 'block' : 'none';\n  \n  if (tab === 'inventory') {\n    loadUserInventory();\n  }\n}\n\nfunction loadShopCategories() {\n  fetch('/api/shop/categories', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(categories => {\n      shopCategories = categories;\n      const list = document.getElementById('shopCategoriesList');\n      list.innerHTML = `\n        <button class=\"shop-category-btn active\" onclick=\"selectCategory(null)\" style=\"width:100%;padding:12px;margin-bottom:8px;background:var(--primary);color:white;border:none;border-radius:8px;cursor:pointer;text-align:left;font-weight:600;\">\n          All Items\n        </button>\n      ` + categories.map(cat => `\n        <button class=\"shop-category-btn\" onclick=\"selectCategory('${cat.slug}')\" data-category=\"${cat.slug}\" style=\"width:100%;padding:12px;margin-bottom:8px;background:var(--card);color:var(--text);border:1px solid var(--accent);border-radius:8px;cursor:pointer;text-align:left;\">\n          ${cat.icon} ${cat.name}\n        </button>\n      `).join('');\n    });\n}\n\nfunction selectCategory(categorySlug) {\n  currentShopCategory = categorySlug;\n  \n  document.querySelectorAll('.shop-category-btn').forEach(btn => {\n    const isSelected = btn.dataset.category === categorySlug || (!categorySlug && !btn.dataset.category);\n    btn.style.background = isSelected ? 'var(--primary)' : 'var(--card)';\n    btn.style.color = isSelected ? 'white' : 'var(--text)';\n  });\n  \n  const category = shopCategories.find(c => c.slug === categorySlug);\n  document.getElementById('shopCategoryTitle').textContent = category ? `${category.icon} ${category.name}` : 'All Items';\n  \n  loadShopItems(categorySlug);\n}\n\nfunction loadShopItems(category = null) {\n  const rarity = document.getElementById('shopRarityFilter')?.value || '';\n  let url = '/api/shop/items?';\n  if (category) url += `category=${category}&`;\n  if (rarity) url += `rarity=${rarity}&`;\n  \n  fetch(url, {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(items => {\n      shopItems = items;\n      renderShopItems(items);\n    });\n}\n\nfunction filterShopItems() {\n  loadShopItems(currentShopCategory);\n}\n\nfunction renderShopItems(items) {\n  const grid = document.getElementById('shopItemsGrid');\n  \n  if (items.length === 0) {\n    grid.innerHTML = '<p style=\"color:var(--text-light);text-align:center;grid-column:1/-1;\">No items found</p>';\n    return;\n  }\n  \n  grid.innerHTML = items.map(item => {\n    const rarityColors = {\n      common: '#9e9e9e',\n      uncommon: '#4caf50',\n      rare: '#2196f3',\n      epic: '#9c27b0',\n      legendary: '#ff9800'\n    };\n    const rarityColor = rarityColors[item.rarity] || '#9e9e9e';\n    const isOwned = userInventory.some(i => i.id === item.id);\n    \n    return `\n      <div class=\"shop-item-card\" onclick=\"showItemPreview(${item.id})\" style=\"background:var(--bg);border-radius:12px;padding:15px;cursor:pointer;border:2px solid ${rarityColor}30;transition:transform 0.2s;\">\n        <div style=\"display:flex;justify-content:space-between;align-items:start;margin-bottom:10px;\">\n          <span style=\"font-size:24px;\">${getCategoryIcon(item.item_type)}</span>\n          <span style=\"background:${rarityColor};color:white;padding:2px 8px;border-radius:12px;font-size:10px;text-transform:uppercase;\">${item.rarity}</span>\n        </div>\n        <h4 style=\"margin:0 0 5px;color:var(--text);font-size:14px;\">${escapeHtml(item.name)}</h4>\n        <p style=\"margin:0 0 10px;color:var(--text-light);font-size:11px;line-height:1.4;\">${escapeHtml(item.description || '')}</p>\n        <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n          <span style=\"color:var(--primary);font-weight:600;\">${item.price} ðŸª™</span>\n          ${item.is_animated ? '<span style=\"font-size:10px;color:var(--secondary);\">âœ¨ Animated</span>' : ''}\n        </div>\n        ${isOwned ? '<div style=\"margin-top:8px;text-align:center;background:var(--accent);color:var(--text);padding:4px;border-radius:6px;font-size:11px;\">Owned</div>' : ''}\n      </div>\n    `;\n  }).join('');\n}\n\nfunction getCategoryIcon(itemType) {\n  const icons = {\n    theme: 'ðŸŽ¨',\n    frame: 'ðŸ–¼ï¸',\n    badge: 'ðŸ…',\n    bubble: 'ðŸ’¬',\n    sound: 'ðŸ”Š',\n    avatar: 'âœ¨',\n    server_icon: 'ðŸ ',\n    server_banner: 'ðŸ ',\n    status: 'ðŸ”´',\n    bio_upgrade: 'ðŸ“',\n    boost: 'ðŸš€'\n  };\n  return icons[itemType] || 'ðŸ“¦';\n}\n\nfunction showItemPreview(itemId) {\n  const item = shopItems.find(i => i.id === itemId);\n  if (!item) return;\n  \n  const isOwned = userInventory.some(i => i.id === itemId);\n  const isEquipped = Object.values(userEquipped).some(e => e.item_id === itemId);\n  const canAfford = userCoins >= item.price;\n  \n  const rarityColors = {\n    common: '#9e9e9e',\n    uncommon: '#4caf50',\n    rare: '#2196f3',\n    epic: '#9c27b0',\n    legendary: '#ff9800'\n  };\n  const rarityColor = rarityColors[item.rarity] || '#9e9e9e';\n  \n  let previewContent = '';\n  if (item.item_type === 'theme' && item.css_vars) {\n    try {\n      const vars = JSON.parse(item.css_vars);\n      previewContent = `\n        <div style=\"display:flex;gap:5px;justify-content:center;margin:15px 0;\">\n          ${Object.entries(vars).map(([key, val]) => `\n            <div style=\"width:30px;height:30px;background:${val};border-radius:50%;border:2px solid white;\"></div>\n          `).join('')}\n        </div>\n      `;\n    } catch(e) {}\n  } else if (item.item_type === 'badge' && item.metadata) {\n    try {\n      const meta = JSON.parse(item.metadata);\n      previewContent = `<div style=\"font-size:48px;margin:15px 0;\">${meta.emoji || 'ðŸ…'}</div>`;\n    } catch(e) {}\n  }\n  \n  document.getElementById('itemPreviewContent').innerHTML = `\n    <div style=\"font-size:48px;margin-bottom:15px;\">${getCategoryIcon(item.item_type)}</div>\n    <h2 style=\"margin:0 0 10px;color:var(--text);\">${escapeHtml(item.name)}</h2>\n    <span style=\"display:inline-block;background:${rarityColor};color:white;padding:4px 12px;border-radius:12px;font-size:12px;text-transform:uppercase;margin-bottom:15px;\">${item.rarity}</span>\n    <p style=\"color:var(--text-light);margin:0 0 15px;\">${escapeHtml(item.description || '')}</p>\n    ${previewContent}\n    <div style=\"font-size:24px;color:var(--primary);font-weight:700;margin:15px 0;\">${item.price} ðŸª™</div>\n    ${item.is_animated ? '<p style=\"color:var(--secondary);font-size:12px;margin-bottom:15px;\">âœ¨ This item is animated!</p>' : ''}\n    ${isOwned ? `\n      <button onclick=\"equipItem(${item.id}, '${item.item_type}')\" style=\"width:100%;padding:12px;background:${isEquipped ? 'var(--accent)' : 'var(--primary)'};color:${isEquipped ? 'var(--text)' : 'white'};border:none;border-radius:8px;cursor:pointer;font-weight:600;margin-bottom:10px;\">\n        ${isEquipped ? 'Unequip' : 'Equip'}\n      </button>\n    ` : `\n      <button onclick=\"purchaseItem(${item.id})\" style=\"width:100%;padding:12px;background:${canAfford ? 'var(--primary)' : '#666'};color:white;border:none;border-radius:8px;cursor:pointer;font-weight:600;margin-bottom:10px;\" ${canAfford ? '' : 'disabled'}>\n        ${canAfford ? 'Purchase' : 'Not Enough Coins'}\n      </button>\n    `}\n    <button onclick=\"closeItemPreview()\" style=\"width:100%;padding:10px;background:var(--accent);color:var(--text);border:none;border-radius:8px;cursor:pointer;\">Close</button>\n  `;\n  \n  document.getElementById('itemPreviewOverlay').style.display = 'block';\n  document.getElementById('itemPreviewModal').style.display = 'block';\n}\n\nfunction closeItemPreview() {\n  document.getElementById('itemPreviewOverlay').style.display = 'none';\n  document.getElementById('itemPreviewModal').style.display = 'none';\n}\n\nfunction purchaseItem(itemId) {\n  fetch(`/api/shop/purchase/${itemId}`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        userCoins = data.newBalance;\n        updateCoinDisplays();\n        userInventory.push(data.item);\n        closeItemPreview();\n        loadShopItems(currentShopCategory);\n        alert(data.message);\n      } else {\n        alert(data.error || 'Purchase failed');\n      }\n    })\n    .catch(() => alert('Purchase failed'));\n}\n\nfunction loadUserInventory() {\n  fetch('/api/shop/inventory', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(items => {\n      userInventory = items;\n      renderInventory(items);\n    });\n}\n\nfunction renderInventory(items) {\n  const grid = document.getElementById('inventoryGrid');\n  \n  if (items.length === 0) {\n    grid.innerHTML = '<p style=\"color:var(--text-light);text-align:center;grid-column:1/-1;\">You don\\'t own any items yet. Browse the shop to get started!</p>';\n    return;\n  }\n  \n  const rarityColors = {\n    common: '#9e9e9e',\n    uncommon: '#4caf50',\n    rare: '#2196f3',\n    epic: '#9c27b0',\n    legendary: '#ff9800'\n  };\n  \n  grid.innerHTML = items.map(item => {\n    const rarityColor = rarityColors[item.rarity] || '#9e9e9e';\n    const isEquipped = Object.values(userEquipped).some(e => e.item_id === item.id);\n    \n    return `\n      <div class=\"inventory-item-card\" style=\"background:var(--bg);border-radius:12px;padding:15px;border:2px solid ${isEquipped ? 'var(--primary)' : rarityColor + '30'};\">\n        <div style=\"display:flex;justify-content:space-between;align-items:start;margin-bottom:10px;\">\n          <span style=\"font-size:24px;\">${getCategoryIcon(item.item_type)}</span>\n          ${isEquipped ? '<span style=\"background:var(--primary);color:white;padding:2px 8px;border-radius:12px;font-size:10px;\">EQUIPPED</span>' : ''}\n        </div>\n        <h4 style=\"margin:0 0 5px;color:var(--text);font-size:14px;\">${escapeHtml(item.name)}</h4>\n        <p style=\"margin:0 0 10px;color:var(--text-light);font-size:11px;\">${item.category_name}</p>\n        <button onclick=\"equipItem(${item.id}, '${item.item_type}')\" style=\"width:100%;padding:8px;background:${isEquipped ? 'var(--accent)' : 'var(--primary)'};color:${isEquipped ? 'var(--text)' : 'white'};border:none;border-radius:6px;cursor:pointer;font-size:12px;\">\n          ${isEquipped ? 'Unequip' : 'Equip'}\n        </button>\n      </div>\n    `;\n  }).join('');\n}\n\nfunction loadUserEquipped() {\n  fetch('/api/shop/equipped', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(equipped => {\n      userEquipped = equipped;\n      applyEquippedCosmetics();\n    });\n}\n\nfunction equipItem(itemId, itemType) {\n  const isCurrentlyEquipped = Object.values(userEquipped).some(e => e.item_id === itemId);\n  \n  if (isCurrentlyEquipped) {\n    fetch('/api/shop/unequip', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${getAuthToken()}`\n      },\n      body: JSON.stringify({ slot: itemType })\n    })\n      .then(r => r.json())\n      .then(data => {\n        if (data.success) {\n          delete userEquipped[itemType];\n          applyEquippedCosmetics();\n          closeItemPreview();\n          if (document.getElementById('inventoryTab').style.display !== 'none') {\n            loadUserInventory();\n          }\n          loadShopItems(currentShopCategory);\n        } else {\n          alert(data.error || 'Failed to unequip');\n        }\n      });\n  } else {\n    fetch('/api/shop/equip', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${getAuthToken()}`\n      },\n      body: JSON.stringify({ itemId, slot: itemType })\n    })\n      .then(r => r.json())\n      .then(data => {\n        if (data.success) {\n          userEquipped[itemType] = { item_id: itemId, ...data.item };\n          applyEquippedCosmetics();\n          closeItemPreview();\n          if (document.getElementById('inventoryTab').style.display !== 'none') {\n            loadUserInventory();\n          }\n          loadShopItems(currentShopCategory);\n        } else {\n          alert(data.error || 'Failed to equip');\n        }\n      });\n  }\n}\n\nfunction applyEquippedCosmetics() {\n  if (userEquipped.theme && userEquipped.theme.css_vars) {\n    try {\n      const vars = JSON.parse(userEquipped.theme.css_vars);\n      Object.entries(vars).forEach(([key, value]) => {\n        document.documentElement.style.setProperty(key, value);\n      });\n    } catch(e) {}\n  }\n  \n  localStorage.setItem('equippedCosmetics', JSON.stringify(userEquipped));\n}\n\nlet dailyRewardData = null;\n\nfunction checkDailyRewardStatus() {\n  fetch('/api/shop/daily/status', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      dailyRewardData = data;\n      const btn = document.getElementById('dailyRewardBtn');\n      if (data.claimed) {\n        btn.style.background = 'var(--accent)';\n        btn.style.color = 'var(--text)';\n        btn.textContent = 'âœ“ Claimed';\n        btn.disabled = false;\n      } else {\n        btn.style.background = 'linear-gradient(135deg,#f7931e,#ff6b35)';\n        btn.style.color = 'white';\n        btn.textContent = 'ðŸŽ Daily';\n        btn.disabled = false;\n      }\n    });\n}\n\nfunction openDailyRewardsModal() {\n  if (!dailyRewardData) {\n    checkDailyRewardStatus();\n    setTimeout(openDailyRewardsModal, 300);\n    return;\n  }\n  \n  const rewards = dailyRewardData.rewards || [\n    { day: 1, coins: 50 }, { day: 2, coins: 150 }, { day: 3, coins: 200 }, { day: 4, coins: 250 },\n    { day: 5, coins: 300 }, { day: 6, coins: 350 }, { day: 7, coins: 400 }, { day: 8, coins: 0, item: 'daily-special-badge' }\n  ];\n  \n  const currentDay = dailyRewardData.currentDay || 1;\n  const claimed = dailyRewardData.claimed;\n  \n  let existingModal = document.getElementById('dailyRewardsModal');\n  if (existingModal) existingModal.remove();\n  \n  const modal = document.createElement('div');\n  modal.id = 'dailyRewardsModal';\n  modal.innerHTML = `\n    <div class=\"daily-modal-overlay\" onclick=\"closeDailyRewardsModal()\"></div>\n    <div class=\"daily-modal-content\">\n      <div class=\"daily-modal-header\">\n        <h2>ðŸŽ Daily Reward</h2>\n        <span class=\"daily-modal-close\" onclick=\"closeDailyRewardsModal()\">&times;</span>\n      </div>\n      <p class=\"daily-subtitle\">${claimed ? 'Come back tomorrow for your next reward!' : 'You can claim your reward!'}</p>\n      <div class=\"daily-rewards-grid\">\n        ${rewards.map((r, i) => {\n          const dayNum = i + 1;\n          const isPast = currentDay > dayNum || (currentDay === dayNum && claimed);\n          const isCurrent = currentDay === dayNum && !claimed;\n          const isLocked = currentDay < dayNum;\n          const isSpecial = r.item !== null && r.item !== undefined;\n          \n          return `\n            <div class=\"daily-reward-day ${isPast ? 'claimed' : ''} ${isCurrent ? 'current' : ''} ${isLocked ? 'locked' : ''} ${isSpecial ? 'special' : ''}\">\n              <div class=\"day-label\">Day ${dayNum}</div>\n              <div class=\"reward-icon\">\n                ${isSpecial ? 'ðŸ†' : 'ðŸª™'}\n              </div>\n              <div class=\"reward-amount\">${isSpecial ? 'Badge' : r.coins}</div>\n              ${isPast ? '<div class=\"claimed-check\">âœ“</div>' : ''}\n            </div>\n          `;\n        }).join('')}\n      </div>\n      <button class=\"daily-claim-btn ${claimed ? 'disabled' : ''}\" onclick=\"${claimed ? '' : 'claimDailyReward()'}\" ${claimed ? 'disabled' : ''}>\n        ${claimed ? 'Already Claimed' : 'Claim'}\n      </button>\n    </div>\n  `;\n  \n  const style = document.createElement('style');\n  style.id = 'dailyRewardsStyle';\n  if (!document.getElementById('dailyRewardsStyle')) {\n    style.textContent = `\n      #dailyRewardsModal { position:fixed; top:0; left:0; width:100%; height:100%; z-index:10000; display:flex; align-items:center; justify-content:center; }\n      .daily-modal-overlay { position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); }\n      .daily-modal-content { position:relative; background:linear-gradient(135deg, #4a7c59 0%, #6b9b4e 50%, #8fbc8f 100%); border-radius:20px; padding:25px; max-width:420px; width:90%; box-shadow:0 10px 40px rgba(0,0,0,0.4); border:4px solid #3d5c40; }\n      .daily-modal-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; }\n      .daily-modal-header h2 { color:#fff; margin:0; font-size:24px; text-shadow:2px 2px 4px rgba(0,0,0,0.3); }\n      .daily-modal-close { color:#fff; font-size:28px; cursor:pointer; opacity:0.8; }\n      .daily-modal-close:hover { opacity:1; }\n      .daily-subtitle { color:#fff; text-align:center; margin:0 0 20px; font-size:14px; opacity:0.9; }\n      .daily-rewards-grid { display:grid; grid-template-columns:repeat(4, 1fr); gap:10px; margin-bottom:20px; }\n      .daily-reward-day { background:linear-gradient(180deg, #8fbc8f 0%, #6b9b4e 100%); border-radius:12px; padding:12px 8px; text-align:center; border:3px solid #5a8055; position:relative; transition:all 0.2s; }\n      .daily-reward-day.current { border-color:#ffd700; box-shadow:0 0 15px rgba(255,215,0,0.5); animation:pulse 1.5s infinite; }\n      .daily-reward-day.claimed { opacity:0.7; }\n      .daily-reward-day.locked { opacity:0.5; filter:grayscale(50%); }\n      .daily-reward-day.special { background:linear-gradient(180deg, #87ceeb 0%, #4169e1 100%); border-color:#1e90ff; }\n      .day-label { font-size:11px; font-weight:bold; color:#fff; text-shadow:1px 1px 2px rgba(0,0,0,0.3); margin-bottom:6px; }\n      .reward-icon { font-size:28px; margin:5px 0; }\n      .reward-amount { font-size:13px; font-weight:bold; color:#fff; text-shadow:1px 1px 2px rgba(0,0,0,0.3); }\n      .claimed-check { position:absolute; top:5px; right:5px; color:#fff; font-size:14px; background:#27ae60; width:20px; height:20px; border-radius:50%; display:flex; align-items:center; justify-content:center; }\n      .daily-claim-btn { width:100%; padding:15px; font-size:18px; font-weight:bold; color:#fff; background:linear-gradient(180deg, #f7931e 0%, #e67e22 100%); border:3px solid #d35400; border-radius:12px; cursor:pointer; text-shadow:1px 1px 2px rgba(0,0,0,0.3); transition:all 0.2s; }\n      .daily-claim-btn:hover:not(.disabled) { transform:scale(1.02); box-shadow:0 5px 15px rgba(0,0,0,0.3); }\n      .daily-claim-btn.disabled { background:#95a5a6; border-color:#7f8c8d; cursor:not-allowed; opacity:0.8; }\n      @keyframes pulse { 0%, 100% { box-shadow:0 0 15px rgba(255,215,0,0.5); } 50% { box-shadow:0 0 25px rgba(255,215,0,0.8); } }\n    `;\n    document.head.appendChild(style);\n  }\n  \n  document.body.appendChild(modal);\n}\n\nfunction closeDailyRewardsModal() {\n  const modal = document.getElementById('dailyRewardsModal');\n  if (modal) modal.remove();\n}\n\nfunction claimDailyReward() {\n  fetch('/api/shop/daily', {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        userCoins = data.newBalance;\n        updateCoinDisplays();\n        dailyRewardData = null;\n        checkDailyRewardStatus();\n        closeDailyRewardsModal();\n        \n        setTimeout(() => {\n          if (data.itemAwarded) {\n            alert(`ðŸ† Day ${data.day} reward!\\n\\nYou earned the Daily Champion badge!`);\n          } else {\n            alert(`ðŸª™ Day ${data.day} reward!\\n\\n+${data.amount} coins`);\n          }\n        }, 200);\n      } else {\n        alert(data.error || 'Could not claim daily reward');\n      }\n    });\n}\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  setTimeout(initShop, 500);\n});\n\nlet userShortcuts = {};\nlet shortcutsEnabled = true;\n\nfunction openChangelog() {\n  document.getElementById('changelogOverlay').style.display = 'block';\n  document.getElementById('changelogModal').style.display = 'block';\n  loadChangelogs();\n}\n\nfunction closeChangelog() {\n  document.getElementById('changelogOverlay').style.display = 'none';\n  document.getElementById('changelogModal').style.display = 'none';\n}\n\nfunction loadChangelogs() {\n  fetch('/api/changelogs')\n    .then(r => r.json())\n    .then(changelogs => {\n      const container = document.getElementById('changelogContent');\n      if (!changelogs.length) {\n        container.innerHTML = '<p style=\"color:var(--text-light);text-align:center;\">No changelog entries yet.</p>';\n        return;\n      }\n      \n      container.innerHTML = changelogs.map(log => {\n        const typeColors = {\n          feature: '#2ecc71',\n          bugfix: '#e74c3c',\n          improvement: '#3498db',\n          security: '#f39c12',\n          removed: '#95a5a6',\n          ui: '#9b59b6'\n        };\n        const typeLabels = {\n          feature: 'âœ¨ New Feature',\n          bugfix: 'ðŸ› Bug Fix',\n          improvement: 'ðŸ“ˆ Improvement',\n          security: 'ðŸ”’ Security',\n          removed: 'ðŸ—‘ï¸ Removed',\n          ui: 'ðŸŽ¨ UI Update'\n        };\n        const date = new Date(log.created_at).toLocaleDateString('en-US', { \n          year: 'numeric', month: 'short', day: 'numeric' \n        });\n        \n        return `\n          <div style=\"margin-bottom:20px;padding:20px;background:var(--bg);border-radius:12px;border-left:4px solid ${typeColors[log.change_type] || '#3498db'};\">\n            <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;\">\n              <div style=\"display:flex;align-items:center;gap:10px;\">\n                ${log.version ? `<span style=\"background:var(--primary);color:white;padding:4px 10px;border-radius:20px;font-size:12px;font-weight:600;\">v${log.version}</span>` : ''}\n                <span style=\"background:${typeColors[log.change_type] || '#3498db'}20;color:${typeColors[log.change_type] || '#3498db'};padding:4px 10px;border-radius:20px;font-size:12px;\">${typeLabels[log.change_type] || log.change_type}</span>\n              </div>\n              <span style=\"color:var(--text-light);font-size:12px;\">${date}</span>\n            </div>\n            <h3 style=\"margin:0 0 10px;color:var(--text);font-size:18px;\">${log.title}</h3>\n            <p style=\"margin:0;color:var(--text-light);line-height:1.6;\">${log.content}</p>\n            ${log.author_name ? `<p style=\"margin:10px 0 0;color:var(--text-light);font-size:12px;\">â€” ${log.author_name}</p>` : ''}\n          </div>\n        `;\n      }).join('');\n    })\n    .catch(() => {\n      document.getElementById('changelogContent').innerHTML = '<p style=\"color:var(--text-light);text-align:center;\">Failed to load changelogs.</p>';\n    });\n}\n\nfunction openShortcuts() {\n  document.getElementById('shortcutsOverlay').style.display = 'block';\n  document.getElementById('shortcutsModal').style.display = 'block';\n  loadShortcuts();\n}\n\nfunction closeShortcuts() {\n  document.getElementById('shortcutsOverlay').style.display = 'none';\n  document.getElementById('shortcutsModal').style.display = 'none';\n}\n\nfunction loadShortcuts() {\n  fetch('/api/shortcuts', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(shortcuts => {\n      const container = document.getElementById('shortcutsContent');\n      const categories = {};\n      \n      shortcuts.forEach(s => {\n        if (!categories[s.category]) categories[s.category] = [];\n        categories[s.category].push(s);\n        userShortcuts[s.action] = { shortcut: s.shortcut, enabled: s.is_enabled };\n      });\n      \n      const categoryLabels = {\n        navigation: 'ðŸ§­ Navigation',\n        ui: 'ðŸ–¥ï¸ User Interface',\n        chat: 'ðŸ’¬ Chat',\n        advanced: 'âš¡ Advanced'\n      };\n      \n      container.innerHTML = Object.entries(categories).map(([cat, items]) => `\n        <div style=\"margin-bottom:25px;\">\n          <h3 style=\"margin:0 0 15px;color:var(--text);font-size:14px;text-transform:uppercase;letter-spacing:1px;\">${categoryLabels[cat] || cat}</h3>\n          ${items.map(s => `\n            <div style=\"display:flex;align-items:center;justify-content:space-between;padding:12px;background:var(--bg);border-radius:8px;margin-bottom:8px;\">\n              <div style=\"display:flex;align-items:center;gap:12px;\">\n                <label style=\"display:flex;align-items:center;cursor:pointer;\">\n                  <input type=\"checkbox\" ${s.is_enabled ? 'checked' : ''} onchange=\"toggleShortcut('${s.action}')\" \n                    style=\"width:18px;height:18px;cursor:pointer;\">\n                </label>\n                <span style=\"color:var(--text);${!s.is_enabled ? 'opacity:0.5;' : ''}\">${s.description}</span>\n              </div>\n              <div style=\"display:flex;align-items:center;gap:8px;\">\n                <kbd onclick=\"editShortcut('${s.action}', this)\" style=\"background:var(--card);padding:6px 12px;border-radius:6px;font-family:monospace;font-size:13px;color:var(--primary);border:1px solid var(--accent);cursor:pointer;${!s.is_enabled ? 'opacity:0.5;' : ''}\">${formatShortcut(s.shortcut)}</kbd>\n              </div>\n            </div>\n          `).join('')}\n        </div>\n      `).join('');\n    })\n    .catch(() => {\n      document.getElementById('shortcutsContent').innerHTML = '<p style=\"color:var(--text-light);text-align:center;\">Failed to load shortcuts.</p>';\n    });\n}\n\nfunction formatShortcut(shortcut) {\n  return shortcut\n    .replace('ctrl+', 'Ctrl + ')\n    .replace('alt+', 'Alt + ')\n    .replace('shift+', 'Shift + ')\n    .toUpperCase();\n}\n\nfunction toggleShortcut(action) {\n  fetch(`/api/shortcuts/${action}/toggle`, {\n    method: 'PUT',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        userShortcuts[action].enabled = data.is_enabled;\n        loadShortcuts();\n      }\n    });\n}\n\nfunction editShortcut(action, element) {\n  const originalText = element.textContent;\n  element.textContent = 'Press key...';\n  element.style.background = 'var(--primary)';\n  element.style.color = 'white';\n  \n  const handler = (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    let key = e.key.toLowerCase();\n    if (key === 'escape') {\n      element.textContent = originalText;\n      element.style.background = 'var(--card)';\n      element.style.color = 'var(--primary)';\n      document.removeEventListener('keydown', handler);\n      return;\n    }\n    \n    let shortcut = '';\n    if (e.ctrlKey) shortcut += 'ctrl+';\n    if (e.altKey) shortcut += 'alt+';\n    if (e.shiftKey && key !== 'shift') shortcut += 'shift+';\n    if (!['control', 'alt', 'shift', 'meta'].includes(key)) {\n      shortcut += key;\n    }\n    \n    if (!shortcut || shortcut.endsWith('+')) {\n      return;\n    }\n    \n    document.removeEventListener('keydown', handler);\n    \n    fetch(`/api/shortcuts/${action}`, {\n      method: 'PUT',\n      headers: { \n        'Authorization': `Bearer ${getAuthToken()}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ shortcut })\n    })\n      .then(r => r.json())\n      .then(data => {\n        if (data.success) {\n          userShortcuts[action].shortcut = shortcut;\n          element.textContent = formatShortcut(shortcut);\n        } else {\n          alert(data.error || 'Failed to update shortcut');\n          element.textContent = originalText;\n        }\n        element.style.background = 'var(--card)';\n        element.style.color = 'var(--primary)';\n      });\n  };\n  \n  document.addEventListener('keydown', handler);\n}\n\nfunction resetShortcuts() {\n  if (!confirm('Reset all shortcuts to defaults?')) return;\n  \n  fetch('/api/shortcuts/reset', {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        loadShortcuts();\n        initKeyboardShortcuts();\n      }\n    });\n}\n\nfunction initKeyboardShortcuts() {\n  fetch('/api/shortcuts', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(shortcuts => {\n      if (Array.isArray(shortcuts)) {\n        shortcuts.forEach(s => {\n          userShortcuts[s.action] = { shortcut: s.shortcut, enabled: s.is_enabled };\n        });\n      }\n    })\n    .catch(err => console.log('Failed to load shortcuts'));\n}\n\ndocument.addEventListener('keydown', (e) => {\n  if (!shortcutsEnabled) return;\n  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;\n  \n  const key = e.key.toLowerCase();\n  let pressed = '';\n  if (e.ctrlKey) pressed += 'ctrl+';\n  if (e.altKey) pressed += 'alt+';\n  if (e.shiftKey && key !== 'shift') pressed += 'shift+';\n  pressed += key;\n  \n  for (const [action, config] of Object.entries(userShortcuts)) {\n    if (!config.enabled) continue;\n    if (config.shortcut === pressed) {\n      e.preventDefault();\n      executeShortcutAction(action);\n      return;\n    }\n  }\n});\n\nfunction executeShortcutAction(action) {\n  const actions = {\n    'open_chat': () => document.querySelector('.dm-header')?.click(),\n    'open_games': () => window.location.href = '/private/games.html',\n    'open_profile': () => window.location.href = '/private/profile.html',\n    'focus_search': () => document.getElementById('messageSearchInput')?.focus(),\n    'return_dashboard': () => window.location.href = '/private/dashboard.html',\n    'open_shop': () => openShop(),\n    'toggle_sidebar': () => {\n      const sidebar = document.querySelector('.servers-sidebar');\n      if (sidebar) sidebar.style.display = sidebar.style.display === 'none' ? 'flex' : 'none';\n    },\n    'quick_switcher': () => document.getElementById('messageSearchInput')?.focus(),\n    'new_message': () => document.getElementById('messageInput')?.focus(),\n    'mark_read': () => {},\n    'next_channel': () => {},\n    'prev_channel': () => {}\n  };\n  \n  if (actions[action]) actions[action]();\n}\n\nfunction openArchiveModal() {\n  document.getElementById('archiveOverlay').style.display = 'block';\n  document.getElementById('archiveModal').style.display = 'block';\n  loadArchivedChats();\n}\n\nfunction closeArchiveModal() {\n  document.getElementById('archiveOverlay').style.display = 'none';\n  document.getElementById('archiveModal').style.display = 'none';\n}\n\nfunction loadArchivedChats() {\n  fetch('/api/archive', {\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(archived => {\n      const container = document.getElementById('archiveContent');\n      \n      if (!archived.length) {\n        container.innerHTML = '<p style=\"color:var(--text-light);text-align:center;\">No archived chats. Right-click on a DM or channel to archive it.</p>';\n        return;\n      }\n      \n      container.innerHTML = archived.map(chat => {\n        const typeIcons = { dm: 'ðŸ‘¤', group: 'ðŸ‘¥', channel: '#' };\n        const date = new Date(chat.archived_at).toLocaleDateString();\n        \n        return `\n          <div style=\"display:flex;align-items:center;justify-content:space-between;padding:12px;background:var(--bg);border-radius:8px;margin-bottom:8px;\">\n            <div style=\"display:flex;align-items:center;gap:12px;\">\n              <span style=\"font-size:20px;\">${typeIcons[chat.chat_type] || 'ðŸ’¬'}</span>\n              <div>\n                <div style=\"color:var(--text);font-weight:500;\">${chat.chat_name || 'Unknown'}</div>\n                <div style=\"color:var(--text-light);font-size:12px;\">Archived ${date}</div>\n              </div>\n            </div>\n            <button onclick=\"unarchiveChat('${chat.chat_type}', ${chat.chat_id})\" \n              style=\"padding:8px 16px;background:var(--primary);color:white;border:none;border-radius:6px;cursor:pointer;font-size:12px;\">\n              Unarchive\n            </button>\n          </div>\n        `;\n      }).join('');\n    })\n    .catch(() => {\n      document.getElementById('archiveContent').innerHTML = '<p style=\"color:var(--text-light);text-align:center;\">Failed to load archived chats.</p>';\n    });\n}\n\nfunction archiveChat(chatType, chatId) {\n  fetch('/api/archive/archive', {\n    method: 'POST',\n    headers: { \n      'Authorization': `Bearer ${getAuthToken()}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ chat_type: chatType, chat_id: chatId })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        loadConversations();\n      } else {\n        alert(data.error || 'Failed to archive chat');\n      }\n    });\n}\n\nfunction unarchiveChat(chatType, chatId) {\n  fetch('/api/archive/unarchive', {\n    method: 'POST',\n    headers: { \n      'Authorization': `Bearer ${getAuthToken()}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ chat_type: chatType, chat_id: chatId })\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.success) {\n        loadArchivedChats();\n        loadConversations();\n      } else {\n        alert(data.error || 'Failed to unarchive chat');\n      }\n    });\n}\n\nsetTimeout(initKeyboardShortcuts, 1000);\n\n// ========== DISCORD-STYLE INVITE POPUP ==========\nlet pendingInviteQueue = [];\nlet invitePopupVisible = false;\nlet lastSeenRequests = new Set(JSON.parse(localStorage.getItem('seenFriendRequests') || '[]'));\n\nfunction showInvitePopup(type, data) {\n  const overlay = document.getElementById('invitePopupOverlay');\n  const modal = document.getElementById('invitePopupModal');\n  const icon = document.getElementById('invitePopupIcon');\n  const title = document.getElementById('invitePopupTitle');\n  const subtitle = document.getElementById('invitePopupSubtitle');\n  const details = document.getElementById('invitePopupDetails');\n  const acceptBtn = document.getElementById('inviteAcceptBtn');\n  const declineBtn = document.getElementById('inviteDeclineBtn');\n  \n  if (type === 'friend_request') {\n    icon.textContent = 'ðŸ‘‹';\n    icon.style.background = 'linear-gradient(135deg, #5865F2 0%, #7289DA 100%)';\n    title.textContent = 'Friend Request';\n    subtitle.textContent = 'Someone wants to be your friend!';\n    details.innerHTML = `\n      <div style=\"display:flex;align-items:center;gap:12px;\">\n        <img src=\"${data.profilePicture || 'https://via.placeholder.com/48'}\" style=\"width:48px;height:48px;border-radius:50%;border:2px solid var(--primary);\">\n        <div>\n          <div style=\"font-weight:700;color:var(--text);font-size:16px;\">${escapeHtml(data.username)}</div>\n          <div style=\"color:var(--text-light);font-size:12px;\">wants to add you as a friend</div>\n        </div>\n      </div>\n    `;\n    acceptBtn.textContent = 'Accept';\n    acceptBtn.onclick = () => {\n      acceptFriendRequest(data.userId, data.username);\n      closeInvitePopup();\n    };\n  } else if (type === 'server_invite') {\n    icon.textContent = 'ðŸ°';\n    icon.style.background = 'linear-gradient(135deg, #57F287 0%, #3BA55C 100%)';\n    title.textContent = 'Server Invite';\n    subtitle.textContent = 'You\\'ve been invited to join a server!';\n    details.innerHTML = `\n      <div style=\"display:flex;align-items:center;gap:12px;\">\n        <div style=\"width:48px;height:48px;border-radius:12px;background:var(--primary);display:flex;align-items:center;justify-content:center;font-size:20px;font-weight:700;color:white;\">${(data.serverName || 'S')[0].toUpperCase()}</div>\n        <div>\n          <div style=\"font-weight:700;color:var(--text);font-size:16px;\">${escapeHtml(data.serverName)}</div>\n          <div style=\"color:var(--text-light);font-size:12px;\">Invited by ${escapeHtml(data.inviterName || 'a friend')}</div>\n        </div>\n      </div>\n    `;\n    acceptBtn.textContent = 'Join Server';\n    acceptBtn.onclick = () => {\n      joinServerByInvite(data.inviteCode);\n      closeInvitePopup();\n    };\n  } else if (type === 'group_invite') {\n    icon.textContent = 'ðŸ‘¥';\n    icon.style.background = 'linear-gradient(135deg, #FEE75C 0%, #F0B232 100%)';\n    title.textContent = 'Group Chat Invite';\n    subtitle.textContent = 'You\\'ve been invited to a group chat!';\n    details.innerHTML = `\n      <div style=\"display:flex;align-items:center;gap:12px;\">\n        <div style=\"width:48px;height:48px;border-radius:50%;background:var(--secondary);display:flex;align-items:center;justify-content:center;font-size:20px;\">ðŸ‘¥</div>\n        <div>\n          <div style=\"font-weight:700;color:var(--text);font-size:16px;\">${escapeHtml(data.groupName)}</div>\n          <div style=\"color:var(--text-light);font-size:12px;\">Invited by ${escapeHtml(data.inviterName || 'a friend')}</div>\n        </div>\n      </div>\n    `;\n    acceptBtn.textContent = 'Join Group';\n    acceptBtn.onclick = () => {\n      joinGroupByInvite(data.inviteCode);\n      closeInvitePopup();\n    };\n  }\n  \n  declineBtn.onclick = () => {\n    if (type === 'friend_request') {\n      rejectFriendRequest(data.userId);\n    }\n    closeInvitePopup();\n  };\n  \n  overlay.style.display = 'flex';\n  modal.style.display = 'block';\n  invitePopupVisible = true;\n  \n  modal.style.animation = 'popIn 0.3s ease-out';\n}\n\nfunction closeInvitePopup() {\n  const overlay = document.getElementById('invitePopupOverlay');\n  const modal = document.getElementById('invitePopupModal');\n  overlay.style.display = 'none';\n  modal.style.display = 'none';\n  invitePopupVisible = false;\n  \n  if (pendingInviteQueue.length > 0) {\n    const next = pendingInviteQueue.shift();\n    setTimeout(() => showInvitePopup(next.type, next.data), 300);\n  }\n}\n\nfunction queueInvitePopup(type, data) {\n  if (invitePopupVisible) {\n    pendingInviteQueue.push({ type, data });\n  } else {\n    showInvitePopup(type, data);\n  }\n}\n\nfunction joinServerByInvite(code) {\n  fetch(`/api/invites/join/${code}`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.error) {\n        alert(data.error);\n      } else {\n        loadServers();\n      }\n    });\n}\n\nfunction joinGroupByInvite(code) {\n  fetch(`/api/invites/join/${code}`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n  })\n    .then(r => r.json())\n    .then(data => {\n      if (data.error) {\n        alert(data.error);\n      } else {\n        loadGroupChats();\n      }\n    });\n}\n\ndocument.getElementById('invitePopupOverlay')?.addEventListener('click', closeInvitePopup);\n\nconst style = document.createElement('style');\nstyle.textContent = `\n  @keyframes popIn {\n    0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }\n    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }\n  }\n  #inviteAcceptBtn:hover { transform: translateY(-2px); box-shadow: 0 6px 16px rgba(0,0,0,0.4); }\n  #inviteDeclineBtn:hover { background: var(--accent); }\n`;\ndocument.head.appendChild(style);\n","path":null,"size_bytes":182286,"size_tokens":null},"backend/routes/messages.js":{"content":"const express = require('express');\nconst db = require('../db');\nconst permissions = require('../permissions');\nconst jwt = require('jsonwebtoken');\n\nconst router = express.Router();\nconst JWT_SECRET = process.env.JWT_SECRET || 'real_user_auth_secret_2025';\n\n// Get global chat messages with pagination (includes replies, reactions, attachments)\nrouter.get('/global', (req, res) => {\n  const offset = parseInt(req.query.offset) || 0;\n  const limit = parseInt(req.query.limit) || 50;\n  const afterId = parseInt(req.query.after) || 0;\n  \n  // If after parameter is provided, fetch only new messages\n  if (afterId > 0) {\n    db.all(`\n      SELECT m.*, u.username, u.profile_picture,\n             rm.content as reply_content, ru.username as reply_username,\n             a.url as attachment_url, a.original_name as attachment_name, a.file_type as attachment_type\n      FROM messages m\n      JOIN users u ON m.user_id = u.id\n      LEFT JOIN messages rm ON m.reply_to_id = rm.id\n      LEFT JOIN users ru ON rm.user_id = ru.id\n      LEFT JOIN attachments a ON a.message_id = m.id\n      WHERE m.is_global = TRUE AND m.id > ?\n      ORDER BY m.created_at ASC\n    `, [afterId], (err, messages) => {\n      if (err) return res.json([]);\n      const formatted = (messages || []).map(m => ({\n        ...m,\n        replyTo: m.reply_to_id ? { id: m.reply_to_id, content: m.reply_content, username: m.reply_username } : null,\n        attachment: m.attachment_url ? { url: m.attachment_url, originalName: m.attachment_name, type: m.attachment_type } : null\n      }));\n      res.json(formatted);\n    });\n    return;\n  }\n  \n  db.all(`\n    SELECT m.*, u.username, u.profile_picture,\n           rm.content as reply_content, ru.username as reply_username,\n           a.url as attachment_url, a.original_name as attachment_name, a.file_type as attachment_type\n    FROM messages m\n    JOIN users u ON m.user_id = u.id\n    LEFT JOIN messages rm ON m.reply_to_id = rm.id\n    LEFT JOIN users ru ON rm.user_id = ru.id\n    LEFT JOIN attachments a ON a.message_id = m.id\n    WHERE m.is_global = TRUE\n    ORDER BY m.created_at DESC\n    LIMIT ? OFFSET ?\n  `, [limit, offset], (err, messages) => {\n    if (err) {\n      console.error('Global messages error:', err);\n      return res.json([]);\n    }\n    \n    const formatted = (messages || []).reverse().map(m => ({\n      ...m,\n      replyTo: m.reply_to_id ? { id: m.reply_to_id, content: m.reply_content, username: m.reply_username } : null,\n      attachment: m.attachment_url ? { url: m.attachment_url, originalName: m.attachment_name, type: m.attachment_type } : null\n    }));\n    \n    res.json(formatted);\n  });\n});\n\n// Get channel messages with pagination (includes replies, attachments)\nrouter.get('/channel/:channelId', async (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  let userId;\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  const { channelId } = req.params;\n  const offset = parseInt(req.query.offset) || 0;\n  const limit = parseInt(req.query.limit) || 50;\n  const afterId = parseInt(req.query.after) || 0;\n  \n  try {\n    const channel = await new Promise((resolve, reject) => {\n      db.get('SELECT server_id FROM channels WHERE id = ?', [channelId], (err, ch) => {\n        if (err) reject(err);\n        else resolve(ch);\n      });\n    });\n\n    if (!channel) {\n      return res.status(404).json({ error: 'Channel not found' });\n    }\n\n    const canView = await permissions.canViewChannel(channel.server_id, channelId, userId);\n    if (!canView) {\n      return res.status(403).json({ error: 'You do not have permission to view this channel' });\n    }\n    \n    // If after parameter is provided, fetch only new messages\n    if (afterId > 0) {\n      db.all(`\n        SELECT m.*, u.username, u.profile_picture,\n               rm.content as reply_content, ru.username as reply_username,\n               a.url as attachment_url, a.original_name as attachment_name, a.file_type as attachment_type\n        FROM messages m\n        JOIN users u ON m.user_id = u.id\n        LEFT JOIN messages rm ON m.reply_to_id = rm.id\n        LEFT JOIN users ru ON rm.user_id = ru.id\n        LEFT JOIN attachments a ON a.message_id = m.id\n        WHERE m.channel_id = ? AND m.id > ?\n        ORDER BY m.created_at ASC\n      `, [channelId, afterId], (err, messages) => {\n        if (err) return res.json([]);\n        const formatted = (messages || []).map(m => ({\n          ...m,\n          replyTo: m.reply_to_id ? { id: m.reply_to_id, content: m.reply_content, username: m.reply_username } : null,\n          attachment: m.attachment_url ? { url: m.attachment_url, originalName: m.attachment_name, type: m.attachment_type } : null\n        }));\n        res.json(formatted);\n      });\n      return;\n    }\n  \n    db.all(`\n      SELECT m.*, u.username, u.profile_picture,\n             rm.content as reply_content, ru.username as reply_username,\n             a.url as attachment_url, a.original_name as attachment_name, a.file_type as attachment_type\n      FROM messages m\n      JOIN users u ON m.user_id = u.id\n      LEFT JOIN messages rm ON m.reply_to_id = rm.id\n      LEFT JOIN users ru ON rm.user_id = ru.id\n      LEFT JOIN attachments a ON a.message_id = m.id\n      WHERE m.channel_id = ?\n      ORDER BY m.created_at DESC\n      LIMIT ? OFFSET ?\n    `, [channelId, limit, offset], (err, messages) => {\n      const formatted = (messages || []).reverse().map(m => ({\n        ...m,\n        replyTo: m.reply_to_id ? { id: m.reply_to_id, content: m.reply_content, username: m.reply_username } : null,\n        attachment: m.attachment_url ? { url: m.attachment_url, originalName: m.attachment_name, type: m.attachment_type } : null\n      }));\n      res.json(formatted);\n    });\n  } catch (err) {\n    console.error('Error checking channel permissions:', err);\n    res.status(500).json({ error: 'Failed to check permissions' });\n  }\n});\n\n// Get group chat messages with pagination (includes replies, attachments)\nrouter.get('/group/:groupChatId', (req, res) => {\n  const offset = parseInt(req.query.offset) || 0;\n  const limit = parseInt(req.query.limit) || 50;\n  const afterId = parseInt(req.query.after) || 0;\n  \n  // If after parameter is provided, fetch only new messages\n  if (afterId > 0) {\n    db.all(`\n      SELECT m.*, u.username, u.profile_picture,\n             rm.content as reply_content, ru.username as reply_username,\n             a.url as attachment_url, a.original_name as attachment_name, a.file_type as attachment_type\n      FROM messages m\n      JOIN users u ON m.user_id = u.id\n      LEFT JOIN messages rm ON m.reply_to_id = rm.id\n      LEFT JOIN users ru ON rm.user_id = ru.id\n      LEFT JOIN attachments a ON a.message_id = m.id\n      WHERE m.group_chat_id = ? AND m.id > ?\n      ORDER BY m.created_at ASC\n    `, [req.params.groupChatId, afterId], (err, messages) => {\n      if (err) return res.json([]);\n      const formatted = (messages || []).map(m => ({\n        ...m,\n        replyTo: m.reply_to_id ? { id: m.reply_to_id, content: m.reply_content, username: m.reply_username } : null,\n        attachment: m.attachment_url ? { url: m.attachment_url, originalName: m.attachment_name, type: m.attachment_type } : null\n      }));\n      res.json(formatted);\n    });\n    return;\n  }\n  \n  db.all(`\n    SELECT m.*, u.username, u.profile_picture,\n           rm.content as reply_content, ru.username as reply_username,\n           a.url as attachment_url, a.original_name as attachment_name, a.file_type as attachment_type\n    FROM messages m\n    JOIN users u ON m.user_id = u.id\n    LEFT JOIN messages rm ON m.reply_to_id = rm.id\n    LEFT JOIN users ru ON rm.user_id = ru.id\n    LEFT JOIN attachments a ON a.message_id = m.id\n    WHERE m.group_chat_id = ?\n    ORDER BY m.created_at DESC\n    LIMIT ? OFFSET ?\n  `, [req.params.groupChatId, limit, offset], (err, messages) => {\n    const formatted = (messages || []).reverse().map(m => ({\n      ...m,\n      replyTo: m.reply_to_id ? { id: m.reply_to_id, content: m.reply_content, username: m.reply_username } : null,\n      attachment: m.attachment_url ? { url: m.attachment_url, originalName: m.attachment_name, type: m.attachment_type } : null\n    }));\n    res.json(formatted);\n  });\n});\n\n// Create group chat\nrouter.post('/group-chat', (req, res) => {\n  const { name, memberIds } = req.body;\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  // Get owner from JWT token, not from client\n  let ownerId;\n  try {\n    const decoded = require('jsonwebtoken').verify(token, 'real_user_auth_secret_2025');\n    ownerId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  // Ensure owner is included in members\n  const allMemberIds = [ownerId, ...memberIds.filter(id => id !== ownerId)];\n\n  db.run(\n    'INSERT INTO group_chats (name, owner_id) VALUES (?, ?)',\n    [name, ownerId],\n    function(err) {\n      if (err) {\n        return res.status(400).json({ error: 'Failed to create group chat' });\n      }\n\n      const groupChatId = this.lastID;\n      let completed = 0;\n\n      allMemberIds.forEach(memberId => {\n        db.run('INSERT INTO group_chat_members (group_chat_id, user_id) VALUES (?, ?)', [groupChatId, memberId], (err) => {\n          completed++;\n          if (completed === allMemberIds.length) {\n            res.json({ success: true, groupChatId });\n          }\n        });\n      });\n    }\n  );\n});\n\n// Get group chat details (including owner and members) - requires membership\nrouter.get('/group-chat/:groupChatId/details', (req, res) => {\n  const { groupChatId } = req.params;\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  let userId;\n  try {\n    const decoded = require('jsonwebtoken').verify(token, 'real_user_auth_secret_2025');\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  // Verify user is a member of this group\n  db.get('SELECT * FROM group_chat_members WHERE group_chat_id = ? AND user_id = ?', \n    [groupChatId, userId], (err, membership) => {\n      if (!membership) {\n        return res.status(403).json({ error: 'You are not a member of this group chat' });\n      }\n      \n      db.get('SELECT * FROM group_chats WHERE id = ?', [groupChatId], (err, groupChat) => {\n        if (!groupChat) {\n          return res.status(404).json({ error: 'Group chat not found' });\n        }\n        \n        db.all(`\n          SELECT u.id, u.username, u.profile_picture \n          FROM group_chat_members gcm\n          JOIN users u ON gcm.user_id = u.id\n          WHERE gcm.group_chat_id = ?\n        `, [groupChatId], (err, members) => {\n          res.json({\n            ...groupChat,\n            members: members || []\n          });\n        });\n      });\n    });\n});\n\n// Kick member from group chat (owner only)\nrouter.post('/group-chat/:groupChatId/kick/:userId', (req, res) => {\n  const { groupChatId, userId } = req.params;\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  let requesterId;\n  try {\n    const decoded = require('jsonwebtoken').verify(token, 'real_user_auth_secret_2025');\n    requesterId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  // Check if requester is the owner\n  db.get('SELECT owner_id FROM group_chats WHERE id = ?', [groupChatId], (err, groupChat) => {\n    if (!groupChat) {\n      return res.status(404).json({ error: 'Group chat not found' });\n    }\n    if (groupChat.owner_id !== requesterId) {\n      return res.status(403).json({ error: 'Only the group owner can kick members' });\n    }\n    if (parseInt(userId) === requesterId) {\n      return res.status(400).json({ error: 'Cannot kick yourself. Use leave instead.' });\n    }\n    \n    db.run('DELETE FROM group_chat_members WHERE group_chat_id = ? AND user_id = ?', \n      [groupChatId, userId], (err) => {\n        if (err) {\n          return res.status(500).json({ error: 'Failed to kick member' });\n        }\n        res.json({ success: true, message: 'Member kicked from group chat' });\n      });\n  });\n});\n\n// Leave group chat (any member)\nrouter.post('/group-chat/:groupChatId/leave', (req, res) => {\n  const { groupChatId } = req.params;\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  let userId;\n  try {\n    const decoded = require('jsonwebtoken').verify(token, 'real_user_auth_secret_2025');\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  // Check if user is the owner - if so, they must delete the group instead\n  db.get('SELECT owner_id FROM group_chats WHERE id = ?', [groupChatId], (err, groupChat) => {\n    if (!groupChat) {\n      return res.status(404).json({ error: 'Group chat not found' });\n    }\n    if (groupChat.owner_id === userId) {\n      return res.status(400).json({ error: 'Owner cannot leave. Delete the group chat instead.' });\n    }\n    \n    db.run('DELETE FROM group_chat_members WHERE group_chat_id = ? AND user_id = ?', \n      [groupChatId, userId], (err) => {\n        if (err) {\n          return res.status(500).json({ error: 'Failed to leave group chat' });\n        }\n        res.json({ success: true, message: 'Left group chat successfully' });\n      });\n  });\n});\n\n// Delete group chat (owner only)\nrouter.delete('/group-chat/:groupChatId', (req, res) => {\n  const { groupChatId } = req.params;\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  let userId;\n  try {\n    const decoded = require('jsonwebtoken').verify(token, 'real_user_auth_secret_2025');\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  // Check if user is the owner\n  db.get('SELECT owner_id FROM group_chats WHERE id = ?', [groupChatId], (err, groupChat) => {\n    if (!groupChat) {\n      return res.status(404).json({ error: 'Group chat not found' });\n    }\n    if (groupChat.owner_id !== userId) {\n      return res.status(403).json({ error: 'Only the group owner can delete the group chat' });\n    }\n    \n    // Delete all members first\n    db.run('DELETE FROM group_chat_members WHERE group_chat_id = ?', [groupChatId], (err) => {\n      // Delete all messages in the group\n      db.run('DELETE FROM messages WHERE group_chat_id = ?', [groupChatId], (err) => {\n        // Delete the group chat\n        db.run('DELETE FROM group_chats WHERE id = ?', [groupChatId], (err) => {\n          if (err) {\n            return res.status(500).json({ error: 'Failed to delete group chat' });\n          }\n          res.json({ success: true, message: 'Group chat deleted successfully' });\n        });\n      });\n    });\n  });\n});\n\n// Get user's group chats\nrouter.get('/user/:userId/group-chats', (req, res) => {\n  db.all(`\n    SELECT gc.*, u.username as owner_name FROM group_chats gc\n    JOIN group_chat_members gcm ON gc.id = gcm.group_chat_id\n    LEFT JOIN users u ON gc.owner_id = u.id\n    WHERE gcm.user_id = ?\n  `, [req.params.userId], (err, groupChats) => {\n    res.json(groupChats || []);\n  });\n});\n\n// Get DM messages with pagination\nrouter.get('/dms/:dmPartnerId/messages', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  let userId;\n  try {\n    const decoded = require('jsonwebtoken').verify(token, 'real_user_auth_secret_2025');\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  const dmPartnerId = parseInt(req.params.dmPartnerId);\n  const offset = parseInt(req.query.offset) || 0;\n  const limit = parseInt(req.query.limit) || 50;\n\n  // Check if either user has blocked the other\n  db.get('SELECT id FROM user_blocks WHERE (blocker_id = ? AND blocked_id = ?) OR (blocker_id = ? AND blocked_id = ?)',\n    [userId, dmPartnerId, dmPartnerId, userId], (err, block) => {\n      if (block) {\n        return res.json([]); // Return empty if blocked\n      }\n\n      db.all(`\n        SELECT m.*, u.username, u.profile_picture\n        FROM messages m\n        JOIN users u ON m.user_id = u.id\n        WHERE m.channel_id IS NULL AND m.group_chat_id IS NULL\n          AND ((m.user_id = ? AND m.dm_partner_id = ?) OR (m.user_id = ? AND m.dm_partner_id = ?))\n        ORDER BY m.created_at DESC\n        LIMIT ? OFFSET ?\n      `, [userId, dmPartnerId, dmPartnerId, userId, limit, offset], (err, messages) => {\n        if (err) return res.status(500).json({ error: err.message });\n        res.json((messages || []).reverse());\n      });\n    });\n});\n\n// Get unread counts for user\nrouter.get('/unread/:userId', (req, res) => {\n  const { userId } = req.params;\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  let requesterId;\n  try {\n    const decoded = require('jsonwebtoken').verify(token, 'real_user_auth_secret_2025');\n    requesterId = decoded.userId;\n    if (requesterId !== parseInt(userId)) {\n      return res.status(403).json({ error: 'Cannot view other users unread counts' });\n    }\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  const unreadCounts = {};\n  \n  db.all(`\n    SELECT c.id as channel_id, c.server_id,\n           COALESCE(mrs.last_read_message_id, 0) as last_read,\n           (SELECT COUNT(*) FROM messages WHERE channel_id = c.id AND id > COALESCE(mrs.last_read_message_id, 0)) as unread_count\n    FROM channels c\n    JOIN server_members sm ON c.server_id = sm.server_id AND sm.user_id = ?\n    LEFT JOIN message_read_status mrs ON mrs.channel_id = c.id AND mrs.user_id = ?\n  `, [userId, userId], (err, channels) => {\n    channels?.forEach(c => {\n      if (c.unread_count > 0) {\n        unreadCounts[`channel-${c.channel_id}`] = c.unread_count;\n      }\n    });\n    \n    db.all(`\n      SELECT gc.id as group_chat_id,\n             COALESCE(mrs.last_read_message_id, 0) as last_read,\n             (SELECT COUNT(*) FROM messages WHERE group_chat_id = gc.id AND id > COALESCE(mrs.last_read_message_id, 0)) as unread_count\n      FROM group_chats gc\n      JOIN group_chat_members gcm ON gc.id = gcm.group_chat_id AND gcm.user_id = ?\n      LEFT JOIN message_read_status mrs ON mrs.group_chat_id = gc.id AND mrs.user_id = ?\n    `, [userId, userId], (err, groups) => {\n      groups?.forEach(g => {\n        if (g.unread_count > 0) {\n          unreadCounts[`group-${g.group_chat_id}`] = g.unread_count;\n        }\n      });\n      \n      db.get(`\n        SELECT COALESCE(mrs.last_read_message_id, 0) as last_read,\n               (SELECT COUNT(*) FROM messages WHERE is_global = TRUE AND id > COALESCE(mrs.last_read_message_id, 0)) as unread_count\n        FROM message_read_status mrs\n        WHERE mrs.user_id = ? AND mrs.is_global = TRUE\n      `, [userId], (err, global) => {\n        if (global?.unread_count > 0) {\n          unreadCounts['global'] = global.unread_count;\n        }\n        res.json(unreadCounts);\n      });\n    });\n  });\n});\n\n// HTTP fallback for sending messages when socket is disconnected\nrouter.post('/send', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  let userId;\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  const { channelId, groupChatId, dmPartnerId, isGlobal, content, replyToId } = req.body;\n  \n  if (!content || (!channelId && !groupChatId && !dmPartnerId && !isGlobal)) {\n    return res.status(400).json({ error: 'Missing content or target' });\n  }\n  \n  db.run(`\n    INSERT INTO messages (channel_id, group_chat_id, dm_partner_id, user_id, content, is_global, reply_to_id)\n    VALUES (?, ?, ?, ?, ?, ?, ?)\n  `, [channelId || null, groupChatId || null, dmPartnerId || null, userId, content, isGlobal ? true : false, replyToId || null],\n  function(err) {\n    if (err) {\n      console.error('Send message error:', err);\n      return res.status(500).json({ error: 'Failed to send message' });\n    }\n    \n    const messageId = this.lastID;\n    \n    db.get(`\n      SELECT m.*, u.username, u.profile_picture\n      FROM messages m\n      JOIN users u ON m.user_id = u.id\n      WHERE m.id = ?\n    `, [messageId], (err, message) => {\n      if (err || !message) {\n        return res.status(500).json({ error: 'Failed to fetch message' });\n      }\n      \n      message.isGlobal = isGlobal;\n      message.channelId = channelId;\n      message.groupChatId = groupChatId;\n      message.dmPartnerId = dmPartnerId;\n      message.createdAt = new Date(message.created_at).toISOString();\n      \n      res.json({ success: true, message });\n    });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":20526,"size_tokens":null},"backend/routes/features.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst db = require('../db');\n\n// ========== 1. ROLES & PERMISSIONS ==========\n\nrouter.get('/roles', (req, res) => {\n  db.all('SELECT * FROM roles', (err, roles) => {\n    res.json(roles || []);\n  });\n});\n\nrouter.get('/user/:userId/role', (req, res) => {\n  db.get('SELECT role FROM users WHERE id = ?', [req.params.userId], (err, user) => {\n    res.json({ role: user?.role || 'member' });\n  });\n});\n\n// ========== 2. USER REPORTING & MODERATION ==========\n\nrouter.post('/report', (req, res) => {\n  const { reportType, reportedUserId, messageId, serverId, reporterId, reason } = req.body;\n  db.run(`\n    INSERT INTO reports (report_type, reported_user_id, message_id, server_id, reporter_id, reason)\n    VALUES (?, ?, ?, ?, ?, ?)\n  `, [reportType, reportedUserId, messageId, serverId, reporterId, reason], function(err) {\n    if (err) return res.status(400).json({ error: err.message });\n    res.json({ success: true, reportId: this.lastID });\n  });\n});\n\nrouter.get('/reports', (req, res) => {\n  db.all(`\n    SELECT r.*, u.username as reporter_name, r.reported_user_id\n    FROM reports r\n    LEFT JOIN users u ON r.reporter_id = u.id\n    WHERE r.status = 'pending'\n    ORDER BY r.created_at DESC\n  `, (err, reports) => {\n    res.json(reports || []);\n  });\n});\n\nrouter.post('/report/:reportId/resolve', (req, res) => {\n  const { actionTaken, resolvedBy } = req.body;\n  db.run(`\n    UPDATE reports \n    SET status = 'resolved', action_taken = ?, resolved_by = ?, resolved_at = CURRENT_TIMESTAMP\n    WHERE id = ?\n  `, [actionTaken, resolvedBy, req.params.reportId], (err) => {\n    if (err) {\n      return res.status(400).json({ error: 'Failed to resolve report' });\n    }\n    res.json({ success: true });\n  });\n});\n\n// ========== 3. MESSAGE FILTERS ==========\n\nrouter.get('/filters', (req, res) => {\n  db.all('SELECT * FROM message_filters', (err, filters) => {\n    res.json(filters || []);\n  });\n});\n\nrouter.post('/filter/:filterId/toggle', (req, res) => {\n  const { enabled } = req.body;\n  db.run('UPDATE message_filters SET enabled = ? WHERE id = ?', [enabled ? 1 : 0, req.params.filterId], (err) => {\n    if (err) {\n      return res.status(400).json({ error: 'Failed to toggle filter' });\n    }\n    res.json({ success: true });\n  });\n});\n\nrouter.get('/blocked-words', (req, res) => {\n  db.all('SELECT word FROM blocked_words', (err, rows) => {\n    const words = rows?.map(r => r.word) || [];\n    res.json({ words });\n  });\n});\n\nrouter.post('/blocked-words/add', (req, res) => {\n  const { word } = req.body;\n  db.run('INSERT INTO blocked_words (word) VALUES (?)', [word], function(err) {\n    if (err) return res.status(400).json({ error: 'Word already blocked' });\n    res.json({ success: true });\n  });\n});\n\nrouter.post('/blocked-words/remove', (req, res) => {\n  const { word } = req.body;\n  db.run('DELETE FROM blocked_words WHERE word = ?', [word], (err) => {\n    if (err) {\n      return res.status(400).json({ error: 'Failed to remove word' });\n    }\n    res.json({ success: true });\n  });\n});\n\n// Filter message content\nfunction filterMessage(content, blockedWords = []) {\n  let filtered = content;\n  blockedWords.forEach(word => {\n    const regex = new RegExp(word, 'gi');\n    filtered = filtered.replace(regex, '*'.repeat(word.length));\n  });\n  return filtered;\n}\n\n// ========== 4. GAME CATEGORIES & GAMES ==========\n\nrouter.get('/game-categories', (req, res) => {\n  db.all('SELECT * FROM game_categories', (err, categories) => {\n    res.json(categories || []);\n  });\n});\n\nrouter.get('/games', (req, res) => {\n  const { categoryId, sort } = req.query;\n  let query = 'SELECT * FROM games WHERE 1=1';\n  const params = [];\n\n  if (categoryId) {\n    query += ' AND category_id = ?';\n    params.push(categoryId);\n  }\n\n  if (sort === 'popular') {\n    query += ' ORDER BY play_count DESC';\n  } else if (sort === 'newest') {\n    query += ' ORDER BY created_at DESC';\n  } else if (sort === 'favorited') {\n    query = `\n      SELECT g.* FROM games g\n      LEFT JOIN favorites f ON g.id = f.game_id\n      ${categoryId ? 'WHERE g.category_id = ?' : ''}\n      GROUP BY g.id\n      ORDER BY COUNT(f.id) DESC\n    `;\n  }\n\n  db.all(query, params, (err, games) => {\n    res.json(games || []);\n  });\n});\n\n// ========== 5. FAVORITES ==========\n\nrouter.post('/favorites/:gameId', (req, res) => {\n  const { userId } = req.body;\n  const stmt = db.prepare(`\n    INSERT INTO favorites (user_id, game_id)\n    VALUES (?, ?)\n  `);\n  stmt.run([userId, req.params.gameId], function(err) {\n    if (err) return res.json({ success: false, error: 'Already favorited' });\n    res.json({ success: true });\n    stmt.finalize();\n  });\n});\n\nrouter.delete('/favorites/:gameId', (req, res) => {\n  const { userId } = req.body;\n  const stmt = db.prepare('DELETE FROM favorites WHERE user_id = ? AND game_id = ?');\n  stmt.run([userId, req.params.gameId], () => {\n    res.json({ success: true });\n    stmt.finalize();\n  });\n});\n\nrouter.get('/favorites/:userId', (req, res) => {\n  db.all(`\n    SELECT g.* FROM games g\n    JOIN favorites f ON g.id = f.game_id\n    WHERE f.user_id = ?\n  `, [req.params.userId], (err, games) => {\n    res.json(games || []);\n  });\n});\n\n// ========== 6. STATUS SYSTEM ==========\n\nrouter.post('/status/:userId', (req, res) => {\n  const { status, customStatus, expiry } = req.body;\n  const stmt = db.prepare(`\n    UPDATE users \n    SET status = ?, custom_status = ?, custom_status_expiry = ?\n    WHERE id = ?\n  `);\n  stmt.run([status, customStatus || null, expiry || null, req.params.userId], () => {\n    res.json({ success: true });\n    stmt.finalize();\n  });\n});\n\nrouter.get('/status/:userId', (req, res) => {\n  db.get('SELECT status, custom_status, custom_status_expiry FROM users WHERE id = ?', \n    [req.params.userId], (err, user) => {\n      res.json(user || { status: 'offline' });\n    });\n});\n\n// ========== 7. BADGES & ACHIEVEMENTS ==========\n\nrouter.get('/badges', (req, res) => {\n  db.all('SELECT * FROM badges', (err, badges) => {\n    res.json(badges || []);\n  });\n});\n\nrouter.get('/user-badges/:userId', (req, res) => {\n  db.all(`\n    SELECT b.* FROM badges b\n    JOIN user_badges ub ON b.id = ub.badge_id\n    WHERE ub.user_id = ?\n  `, [req.params.userId], (err, badges) => {\n    res.json(badges || []);\n  });\n});\n\nrouter.post('/award-badge', (req, res) => {\n  const { userId, badgeId } = req.body;\n  const stmt = db.prepare(`\n    INSERT INTO user_badges (user_id, badge_id)\n    VALUES (?, ?)\n  `);\n  stmt.run([userId, badgeId], function(err) {\n    if (err) return res.json({ success: false });\n    res.json({ success: true });\n    stmt.finalize();\n  });\n});\n\n// ========== 8. EMOJI REACTIONS ==========\n\nrouter.post('/reactions', (req, res) => {\n  const { messageId, userId, emoji } = req.body;\n  const stmt = db.prepare(`\n    INSERT INTO message_reactions (message_id, user_id, emoji)\n    VALUES (?, ?, ?)\n  `);\n  stmt.run([messageId, userId, emoji], function(err) {\n    if (err) return res.json({ success: false });\n    res.json({ success: true });\n    stmt.finalize();\n  });\n});\n\nrouter.delete('/reactions/:messageId/:userId/:emoji', (req, res) => {\n  const stmt = db.prepare(`\n    DELETE FROM message_reactions \n    WHERE message_id = ? AND user_id = ? AND emoji = ?\n  `);\n  stmt.run([req.params.messageId, req.params.userId, req.params.emoji], () => {\n    res.json({ success: true });\n    stmt.finalize();\n  });\n});\n\nrouter.get('/reactions/:messageId', (req, res) => {\n  db.all(`\n    SELECT emoji, COUNT(*) as count, GROUP_CONCAT(user_id) as users\n    FROM message_reactions\n    WHERE message_id = ?\n    GROUP BY emoji\n  `, [req.params.messageId], (err, reactions) => {\n    res.json(reactions || []);\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":7707,"size_tokens":null},"replit.md":{"content":"# K-12 Learning Portal\n\n## Overview\nA comprehensive K-12 learning portal designed to provide educational resources, a chat system, and a game library for students. The platform aims to offer an engaging and interactive learning environment with features like gamification, robust communication tools, and administrative control. It is built to support a large user base with persistent data storage and real-time functionalities.\n\n## User Preferences\nI prefer detailed explanations.\nI want iterative development.\nAsk before making major changes.\nDo not make changes to the folder `Z`.\nDo not make changes to the file `Y`.\n\n## System Architecture\n\n### UI/UX Decisions\n- **Theming System**: Comprehensive theming with 36 options, persistence via localStorage, and a default \"NebulaCore\" theme featuring cyan/purple neon glows and glassmorphism.\n- **Panic Button**: Stealth mode activation (via ` key or double-ESC) to disguise the portal as common educational sites (Google Docs, Classroom, etc.), with tab title and favicon cloaking.\n- **Quick Switcher**: Ctrl+K or / activated search for pages, commands, users, and servers with keyboard navigation.\n- **Public Landing Page**: Professional, institutional branding with stock images, hero section, statistics, academic programs, testimonials, and a comprehensive footer.\n- **Admin Control Center**: Dashboard with real-time metrics, user management, content management placeholders, permission/role editors, analytics, site settings, security features (XP rate limiting, activity status auto-expiry), and communication tools.\n- **Friend Management**: Context menu for friend actions (View Profile, Send Message, Ignore, Be Invisible, Block, Unfriend).\n- **Invite System**: UI for creating server/group invites with expiry options and max uses, invite previews, and error handling.\n\n### Technical Implementations\n- **Backend**: Node.js with Express.js for routing and business logic.\n- **Database**: PostgreSQL for persistent data storage, replacing SQLite.\n- **Real-time Communication**: Socket.io for chat, online/offline status, typing indicators, reactions, editing, deletion, @mentions, and read receipts.\n- **Gamification**: XP and leveling system, 22 achievements across 5 categories, global leaderboards, activity status, and a personal task system.\n- **Permission System**: Discord-style channel-level permissions with overrides, hierarchy (user > channel role > server role > defaults), and deny-over-allow precedence.\n- **Web Proxy**: Dual-engine proxy system with Ultraviolet (UV) as primary and Server-side fallback. UV uses service workers for URL rewriting with broad website compatibility. Server proxy provides basic fallback for simpler pages.\n- **Authentication**: JWT for secure user authentication.\n- **File Uploads**: Multer middleware for handling file uploads (max 10MB).\n- **Cosmetic Shop**: Virtual currency, 10 categories of items, daily rewards, purchase/equip functionality, and rarity system.\n- **Custom Keyboard Shortcuts**: Editable, enable/disable, and reset options with conflict detection.\n- **Archive Mode**: Ability to archive DMs, group chats, and channels.\n- **Polls System**: In-channel polls with various options.\n- **Friend Notes**: Private notes on user profiles.\n- **Auto Theme**: Automatic theme switching based on system preference or time.\n- **Game Rating System**: Star rating (1-5) for games with user reviews and average rating display.\n- **Recently Played Games**: Tracks last 10 played games in a carousel display on the games page.\n- **Game Categories**: Filter games by 10 categories (Action, Racing, Puzzle, Sports, Strategy, Adventure, Arcade, Shooter, Simulation, Multiplayer).\n- **Profile Banner**: Custom banner image upload for user profiles.\n- **Custom Wallpaper**: Upload background images for dashboard pages.\n- **YouTube Video Library**: Search and watch educational videos with category filtering (Education, Science, Music, Gaming, Entertainment).\n- **Game Leaderboards**: High score tracking per game with global rankings and personal bests.\n- **Speedrun Timer**: Built-in stopwatch with millisecond precision for speedrunning, submit times to leaderboard.\n- **Dashboard Widgets**: Customizable widget system with 10 widget types (stats, recent games, leaderboard, friends, announcements, tasks, clock, calendar, notes, weather).\n- **Theme Creator**: Full theme customization with live preview, color pickers, save/export functionality, and public theme gallery.\n- **Anonymous Forums**: Discussion boards where users can post anonymously with categories (General Discussion, Homework Help, Study Tips, Game Requests, Bug Reports, Off Topic), voting system, replies, search, and sorting options.\n- **OS-Style Interface (New)**: Optional desktop-style interface with taskbar, windowed apps, start menu, and notifications panel. Switchable via Settings.\n- **Universal Settings App (New)**: Centralized settings page with layout toggle, theme selection, font customization, accessibility options, and notification preferences.\n- **Guest Mode (New)**: Users can browse as guests without creating an account. Guests have limited access (cannot save progress, post content, or access admin features).\n- **Pin/Like Games (New)**: Games can be pinned and liked with localStorage persistence and dedicated filter categories.\n- **Apps Page (New)**: Utility apps including Calculator, Stopwatch, Timer, Quick Notes, Coin Flip, and Dice Roller.\n- **YouTube Privacy Mode (New)**: Videos embed using youtube-nocookie.com for enhanced privacy.\n- **Music App (New)**: YouTube-based music streaming with search, genre filters, play queue, and currently playing display using youtube-nocookie.com embeds.\n- **Bug Report System (New)**: User submission form with category/priority selection, screenshot upload, admin review queue with status management (pending/investigating/resolved/closed), filtering, and statistics dashboard.\n- **OS-Style Notifications (New)**: Toast notification system with info/success/warning/error types, auto-dismiss, action buttons, slide-in animations, and max 3 concurrent notifications.\n- **Advanced Tab Cloaking**: Tab disguise with custom icon (My Apps) and title, about:blank wrapper, blob: URL wrapper, and auto-cloak on site open. Settings to enable/disable each cloaking method.\n- **Nova AI Chat**: AI-powered study buddy using OpenAI GPT-4o-mini. Conversational interface for homework help, study tips, and general chat. Session-based conversation history with typing indicators and error handling.\n- **Pomodoro Timer**: Study timer with work/short break/long break modes, session tracking, streak counter, and stats persistence.\n- **Custom Cursors**: Selectable cursor styles including custom SVG cursors (neon glow, retro pixel, minimal dot) with persistence.\n- **Sound Effects**: Configurable notification and click sounds using Web Audio API with volume control.\n- **Bookmark Manager**: Save and organize proxy site URLs for quick access.\n\n### System Design Choices\n- **Port**: Server runs on port 5000 for Replit compatibility.\n- **Database Schema**: Includes tables for users, servers, channels, messages, friends, group_chats, roles, badges, games, user_xp, achievements, user_activity, tasks, announcements, channel_permissions, friend_notes, polls, poll_options, poll_votes, user_preferences, changelogs, user_shortcuts, default_shortcuts, archived_chats, shop_categories, shop_items, user_purchases, user_equipped, coin_transactions, daily_rewards, game_ratings, recently_played, game_leaderboards, speedrun_records, user_widgets, custom_themes, forum_categories, forum_posts, forum_replies, forum_votes, and bug_reports.\n- **Security**: Pre-seeded admin accounts (admin, Yusoff(ADMIN)) with default passwords for initial setup (requires immediate change for production). CORS configured to allow all origins during development, needing restriction for production. JWT secret should be an environment variable.\n\n## External Dependencies\n- `express`: Web server framework.\n- `socket.io`: Real-time bidirectional communication.\n- `pg`: PostgreSQL client for Node.js.\n- `bcryptjs`: Password hashing library.\n- `jsonwebtoken`: JSON Web Token implementation for authentication.\n- `multer`: Middleware for handling `multipart/form-data` (file uploads).\n- `cors`: Middleware for enabling Cross-Origin Resource Sharing.","path":null,"size_bytes":8355,"size_tokens":null},"backend/routes/roles.js":{"content":"const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst db = require('../db');\n\nconst router = express.Router();\n\nconst JWT_SECRET = 'real_user_auth_secret_2025';\n\nfunction getUserFromToken(req) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return null;\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch {\n    return null;\n  }\n}\n\nconst PERMISSION_FLAGS = {\n  ADMINISTRATOR: 'administrator',\n  MANAGE_SERVER: 'manage_server',\n  MANAGE_ROLES: 'manage_roles',\n  MANAGE_CHANNELS: 'manage_channels',\n  KICK_MEMBERS: 'kick_members',\n  BAN_MEMBERS: 'ban_members',\n  CREATE_INVITES: 'create_invites',\n  MANAGE_MESSAGES: 'manage_messages',\n  SEND_MESSAGES: 'send_messages',\n  VIEW_CHANNELS: 'view_channels',\n  READ_HISTORY: 'read_history',\n  MENTION_EVERYONE: 'mention_everyone',\n  ADD_REACTIONS: 'add_reactions',\n  ATTACH_FILES: 'attach_files'\n};\n\nfunction hasPermission(permissions, permission) {\n  if (!permissions) return false;\n  const perms = typeof permissions === 'string' ? JSON.parse(permissions) : permissions;\n  return perms[PERMISSION_FLAGS.ADMINISTRATOR] === true || perms[permission] === true;\n}\n\nfunction canManageRoles(serverId, userId, callback) {\n  db.get('SELECT owner_id FROM servers WHERE id = ?', [serverId], (err, server) => {\n    if (err || !server) return callback(false);\n    if (server.owner_id === userId) return callback(true);\n    \n    db.all(`\n      SELECT sr.permissions FROM server_roles sr\n      JOIN server_member_roles smr ON sr.id = smr.role_id\n      WHERE smr.server_id = ? AND smr.user_id = ?\n      ORDER BY sr.position DESC\n    `, [serverId, userId], (err, roles) => {\n      if (err) return callback(false);\n      for (const role of roles) {\n        if (hasPermission(role.permissions, PERMISSION_FLAGS.MANAGE_ROLES) ||\n            hasPermission(role.permissions, PERMISSION_FLAGS.ADMINISTRATOR)) {\n          return callback(true);\n        }\n      }\n      callback(false);\n    });\n  });\n}\n\nrouter.get('/server/:serverId', (req, res) => {\n  const serverId = req.params.serverId;\n  \n  db.all(`\n    SELECT * FROM server_roles \n    WHERE server_id = ? \n    ORDER BY position DESC\n  `, [serverId], (err, roles) => {\n    if (err) return res.status(500).json({ error: 'Failed to load roles' });\n    \n    const parsedRoles = roles.map(role => ({\n      ...role,\n      permissions: typeof role.permissions === 'string' ? JSON.parse(role.permissions) : role.permissions\n    }));\n    \n    res.json(parsedRoles);\n  });\n});\n\nrouter.get('/server/:serverId/members', (req, res) => {\n  const serverId = req.params.serverId;\n  \n  db.all(`\n    SELECT \n      u.id, u.username, u.profile_picture, u.is_online,\n      GROUP_CONCAT(sr.id) as role_ids,\n      GROUP_CONCAT(sr.name) as role_names,\n      MAX(sr.color) as top_color\n    FROM server_members sm\n    JOIN users u ON sm.user_id = u.id\n    LEFT JOIN server_member_roles smr ON sm.user_id = smr.user_id AND sm.server_id = smr.server_id\n    LEFT JOIN server_roles sr ON smr.role_id = sr.id\n    WHERE sm.server_id = ?\n    GROUP BY u.id\n    ORDER BY u.username\n  `, [serverId], (err, members) => {\n    if (err) return res.status(500).json({ error: 'Failed to load members' });\n    \n    const formatted = members.map(m => ({\n      id: m.id,\n      username: m.username,\n      profilePicture: m.profile_picture,\n      isOnline: m.is_online,\n      roles: m.role_ids ? m.role_ids.split(',').map((id, i) => ({\n        id: parseInt(id),\n        name: m.role_names.split(',')[i]\n      })) : [],\n      color: m.top_color || '#99AAB5'\n    }));\n    \n    res.json(formatted);\n  });\n});\n\nrouter.post('/server/:serverId', (req, res) => {\n  const user = getUserFromToken(req);\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const serverId = req.params.serverId;\n  const { name, color, permissions } = req.body;\n  \n  if (!name) return res.status(400).json({ error: 'Role name is required' });\n  \n  canManageRoles(serverId, user.userId, (canManage) => {\n    if (!canManage) return res.status(403).json({ error: 'No permission to manage roles' });\n    \n    db.get('SELECT MAX(position) as maxPos FROM server_roles WHERE server_id = ?', [serverId], (err, result) => {\n      const position = (result?.maxPos || 0) + 1;\n      const permissionsJson = JSON.stringify(permissions || {\n        view_channels: true,\n        send_messages: true,\n        read_history: true\n      });\n      \n      db.run(`\n        INSERT INTO server_roles (server_id, name, color, permissions, position)\n        VALUES (?, ?, ?, ?, ?)\n      `, [serverId, name, color || '#99AAB5', permissionsJson, position], function(err) {\n        if (err) return res.status(500).json({ error: 'Failed to create role' });\n        \n        logAuditAction(serverId, user.userId, 'ROLE_CREATE', 'role', this.lastID, { name, color });\n        \n        res.json({ \n          success: true, \n          roleId: this.lastID,\n          message: `Role \"${name}\" created` \n        });\n      });\n    });\n  });\n});\n\nrouter.put('/server/:serverId/:roleId', (req, res) => {\n  const user = getUserFromToken(req);\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { serverId, roleId } = req.params;\n  const { name, color, permissions, hoist, mentionable } = req.body;\n  \n  canManageRoles(serverId, user.userId, (canManage) => {\n    if (!canManage) return res.status(403).json({ error: 'No permission to manage roles' });\n    \n    db.get('SELECT * FROM server_roles WHERE id = ? AND server_id = ?', [roleId, serverId], (err, role) => {\n      if (!role) return res.status(404).json({ error: 'Role not found' });\n      \n      if (role.name === '@everyone' && name && name !== '@everyone') {\n        return res.status(400).json({ error: 'Cannot rename @everyone role' });\n      }\n      \n      const updates = [];\n      const params = [];\n      const changes = {};\n      \n      if (name !== undefined) { updates.push('name = ?'); params.push(name); changes.name = { old: role.name, new: name }; }\n      if (color !== undefined) { updates.push('color = ?'); params.push(color); changes.color = { old: role.color, new: color }; }\n      if (permissions !== undefined) { \n        updates.push('permissions = ?'); \n        params.push(JSON.stringify(permissions)); \n        changes.permissions = { old: role.permissions, new: permissions }; \n      }\n      if (hoist !== undefined) { updates.push('hoist = ?'); params.push(hoist ? 1 : 0); }\n      if (mentionable !== undefined) { updates.push('mentionable = ?'); params.push(mentionable ? 1 : 0); }\n      \n      if (updates.length === 0) return res.json({ success: true, message: 'No changes' });\n      \n      params.push(roleId);\n      \n      db.run(`UPDATE server_roles SET ${updates.join(', ')} WHERE id = ?`, params, (err) => {\n        if (err) return res.status(500).json({ error: 'Failed to update role' });\n        \n        logAuditAction(serverId, user.userId, 'ROLE_UPDATE', 'role', roleId, changes);\n        \n        res.json({ success: true, message: 'Role updated' });\n      });\n    });\n  });\n});\n\nrouter.delete('/server/:serverId/:roleId', (req, res) => {\n  const user = getUserFromToken(req);\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { serverId, roleId } = req.params;\n  \n  canManageRoles(serverId, user.userId, (canManage) => {\n    if (!canManage) return res.status(403).json({ error: 'No permission to manage roles' });\n    \n    db.get('SELECT * FROM server_roles WHERE id = ? AND server_id = ?', [roleId, serverId], (err, role) => {\n      if (!role) return res.status(404).json({ error: 'Role not found' });\n      if (role.name === '@everyone') return res.status(400).json({ error: 'Cannot delete @everyone role' });\n      \n      db.run('DELETE FROM server_member_roles WHERE role_id = ?', [roleId], () => {\n        db.run('DELETE FROM server_roles WHERE id = ?', [roleId], (err) => {\n          if (err) return res.status(500).json({ error: 'Failed to delete role' });\n          \n          logAuditAction(serverId, user.userId, 'ROLE_DELETE', 'role', roleId, { name: role.name });\n          \n          res.json({ success: true, message: `Role \"${role.name}\" deleted` });\n        });\n      });\n    });\n  });\n});\n\nrouter.post('/server/:serverId/member/:userId', (req, res) => {\n  const user = getUserFromToken(req);\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { serverId, userId } = req.params;\n  const { roleId } = req.body;\n  \n  if (!roleId) return res.status(400).json({ error: 'Role ID is required' });\n  \n  canManageRoles(serverId, user.userId, (canManage) => {\n    if (!canManage) return res.status(403).json({ error: 'No permission to manage roles' });\n    \n    db.get('SELECT * FROM server_roles WHERE id = ? AND server_id = ?', [roleId, serverId], (err, role) => {\n      if (!role) return res.status(404).json({ error: 'Role not found' });\n      \n      db.run(`\n        INSERT INTO server_member_roles (server_id, user_id, role_id)\n        VALUES (?, ?, ?) ON CONFLICT DO NOTHING\n      `, [serverId, userId, roleId], function(err) {\n        if (err) return res.status(500).json({ error: 'Failed to assign role' });\n        \n        logAuditAction(serverId, user.userId, 'ROLE_ASSIGN', 'user', userId, { role: role.name });\n        \n        res.json({ success: true, message: `Role assigned` });\n      });\n    });\n  });\n});\n\nrouter.delete('/server/:serverId/member/:userId/:roleId', (req, res) => {\n  const user = getUserFromToken(req);\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { serverId, userId, roleId } = req.params;\n  \n  canManageRoles(serverId, user.userId, (canManage) => {\n    if (!canManage) return res.status(403).json({ error: 'No permission to manage roles' });\n    \n    db.get('SELECT name FROM server_roles WHERE id = ?', [roleId], (err, role) => {\n      db.run(`\n        DELETE FROM server_member_roles \n        WHERE server_id = ? AND user_id = ? AND role_id = ?\n      `, [serverId, userId, roleId], (err) => {\n        if (err) return res.status(500).json({ error: 'Failed to remove role' });\n        \n        logAuditAction(serverId, user.userId, 'ROLE_REMOVE', 'user', userId, { role: role?.name });\n        \n        res.json({ success: true, message: 'Role removed' });\n      });\n    });\n  });\n});\n\nrouter.put('/server/:serverId/reorder', (req, res) => {\n  const user = getUserFromToken(req);\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const serverId = req.params.serverId;\n  const { roleOrder } = req.body;\n  \n  if (!Array.isArray(roleOrder)) return res.status(400).json({ error: 'Invalid role order' });\n  \n  canManageRoles(serverId, user.userId, (canManage) => {\n    if (!canManage) return res.status(403).json({ error: 'No permission to manage roles' });\n    \n    let completed = 0;\n    roleOrder.forEach((roleId, index) => {\n      db.run('UPDATE server_roles SET position = ? WHERE id = ? AND server_id = ?', \n        [roleOrder.length - index, roleId, serverId], () => {\n          completed++;\n          if (completed === roleOrder.length) {\n            res.json({ success: true, message: 'Role order updated' });\n          }\n        });\n    });\n  });\n});\n\nrouter.get('/server/:serverId/user/:userId/permissions', (req, res) => {\n  const { serverId, userId } = req.params;\n  \n  db.get('SELECT owner_id FROM servers WHERE id = ?', [serverId], (err, server) => {\n    if (!server) return res.status(404).json({ error: 'Server not found' });\n    \n    if (server.owner_id === parseInt(userId)) {\n      return res.json({\n        isOwner: true,\n        permissions: Object.fromEntries(\n          Object.values(PERMISSION_FLAGS).map(p => [p, true])\n        )\n      });\n    }\n    \n    db.all(`\n      SELECT sr.permissions FROM server_roles sr\n      JOIN server_member_roles smr ON sr.id = smr.role_id\n      WHERE smr.server_id = ? AND smr.user_id = ?\n      ORDER BY sr.position DESC\n    `, [serverId, userId], (err, roles) => {\n      const merged = {};\n      \n      db.get(`\n        SELECT permissions FROM server_roles \n        WHERE server_id = ? AND name = '@everyone'\n      `, [serverId], (err, everyoneRole) => {\n        if (everyoneRole) {\n          const everyonePerms = JSON.parse(everyoneRole.permissions || '{}');\n          Object.assign(merged, everyonePerms);\n        }\n        \n        roles.forEach(role => {\n          const perms = JSON.parse(role.permissions || '{}');\n          Object.entries(perms).forEach(([key, value]) => {\n            if (value === true) merged[key] = true;\n          });\n        });\n        \n        res.json({\n          isOwner: false,\n          permissions: merged\n        });\n      });\n    });\n  });\n});\n\nfunction logAuditAction(serverId, actorId, actionType, targetType, targetId, changes, reason) {\n  db.run(`\n    INSERT INTO audit_log (server_id, action_type, actor_id, target_type, target_id, changes, reason)\n    VALUES (?, ?, ?, ?, ?, ?, ?)\n  `, [serverId, actionType, actorId, targetType, targetId, JSON.stringify(changes), reason]);\n}\n\nmodule.exports = router;\nmodule.exports.PERMISSION_FLAGS = PERMISSION_FLAGS;\nmodule.exports.hasPermission = hasPermission;\n","path":null,"size_bytes":13135,"size_tokens":null},"backend/routes/blocks.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst JWT_SECRET = 'real_user_auth_secret_2025';\n\nfunction getUserIdFromToken(req) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return null;\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n    return decoded.userId;\n  } catch {\n    return null;\n  }\n}\n\nrouter.get('/', (req, res) => {\n  const userId = getUserIdFromToken(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  db.all(`\n    SELECT ub.id, ub.blocked_id, ub.created_at, u.username, u.profile_picture\n    FROM user_blocks ub\n    JOIN users u ON ub.blocked_id = u.id\n    WHERE ub.blocker_id = ?\n    ORDER BY ub.created_at DESC\n  `, [userId], (err, blocks) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json(blocks || []);\n  });\n});\n\nrouter.get('/check/:targetId', (req, res) => {\n  const userId = getUserIdFromToken(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const targetId = parseInt(req.params.targetId);\n  \n  db.get('SELECT id FROM user_blocks WHERE blocker_id = ? AND blocked_id = ?', \n    [userId, targetId], (err, block) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      res.json({ blocked: !!block });\n    });\n});\n\nrouter.get('/blocked-by/:targetId', (req, res) => {\n  const userId = getUserIdFromToken(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const targetId = parseInt(req.params.targetId);\n  \n  db.get('SELECT id FROM user_blocks WHERE blocker_id = ? AND blocked_id = ?', \n    [targetId, userId], (err, block) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      res.json({ blockedBy: !!block });\n    });\n});\n\nrouter.post('/:targetId', (req, res) => {\n  const userId = getUserIdFromToken(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const targetId = parseInt(req.params.targetId);\n  \n  if (targetId === userId) {\n    return res.status(400).json({ error: 'Cannot block yourself' });\n  }\n  \n  db.get('SELECT id, username FROM users WHERE id = ?', [targetId], (err, user) => {\n    if (!user) return res.status(404).json({ error: 'User not found' });\n    \n    db.run('INSERT INTO user_blocks (blocker_id, blocked_id) VALUES (?, ?) ON CONFLICT DO NOTHING', \n      [userId, targetId], function(err) {\n        if (err) return res.status(500).json({ error: 'Database error' });\n        \n        db.run('DELETE FROM friends WHERE (user_id = ? AND friend_id = ?) OR (user_id = ? AND friend_id = ?)',\n          [userId, targetId, targetId, userId], () => {\n            res.json({ success: true, message: `Blocked ${user.username}` });\n          });\n      });\n  });\n});\n\nrouter.delete('/:targetId', (req, res) => {\n  const userId = getUserIdFromToken(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const targetId = parseInt(req.params.targetId);\n  \n  db.run('DELETE FROM user_blocks WHERE blocker_id = ? AND blocked_id = ?', \n    [userId, targetId], function(err) {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      res.json({ success: true, message: 'User unblocked' });\n    });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":3354,"size_tokens":null},"backend/routes/pins.js":{"content":"const express = require('express');\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst router = express.Router();\n\nfunction getUserId(req) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return null;\n  try {\n    const decoded = jwt.verify(token, 'real_user_auth_secret_2025');\n    return decoded.userId;\n  } catch {\n    return null;\n  }\n}\n\nrouter.get('/channel/:channelId', (req, res) => {\n  const { channelId } = req.params;\n  \n  db.all(`\n    SELECT pm.*, m.content, m.created_at as message_date, u.username, u.profile_picture,\n           pinner.username as pinned_by_username\n    FROM pinned_messages pm\n    JOIN messages m ON pm.message_id = m.id\n    JOIN users u ON m.user_id = u.id\n    JOIN users pinner ON pm.pinned_by = pinner.id\n    WHERE pm.channel_id = ?\n    ORDER BY pm.pinned_at DESC\n  `, [channelId], (err, pins) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(pins || []);\n  });\n});\n\nrouter.get('/group/:groupChatId', (req, res) => {\n  const { groupChatId } = req.params;\n  \n  db.all(`\n    SELECT pm.*, m.content, m.created_at as message_date, u.username, u.profile_picture,\n           pinner.username as pinned_by_username\n    FROM pinned_messages pm\n    JOIN messages m ON pm.message_id = m.id\n    JOIN users u ON m.user_id = u.id\n    JOIN users pinner ON pm.pinned_by = pinner.id\n    WHERE pm.group_chat_id = ?\n    ORDER BY pm.pinned_at DESC\n  `, [groupChatId], (err, pins) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(pins || []);\n  });\n});\n\nrouter.post('/:messageId', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { messageId } = req.params;\n  const { channelId, groupChatId } = req.body;\n  \n  db.get('SELECT id FROM pinned_messages WHERE message_id = ?', [messageId], (err, existing) => {\n    if (existing) {\n      return res.status(400).json({ error: 'Message already pinned' });\n    }\n    \n    db.run(`INSERT INTO pinned_messages (message_id, channel_id, group_chat_id, pinned_by) \n            VALUES (?, ?, ?, ?)`,\n      [messageId, channelId || null, groupChatId || null, userId], function(err) {\n        if (err) return res.status(500).json({ error: err.message });\n        res.json({ success: true, pinId: this.lastID });\n      });\n  });\n});\n\nrouter.delete('/:messageId', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { messageId } = req.params;\n  \n  db.run('DELETE FROM pinned_messages WHERE message_id = ?', [messageId], function(err) {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json({ success: true, unpinned: this.changes > 0 });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":2821,"size_tokens":null},"backend/routes/search.js":{"content":"const express = require('express');\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst router = express.Router();\n\nfunction getUserId(req) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return null;\n  try {\n    const decoded = jwt.verify(token, 'real_user_auth_secret_2025');\n    return decoded.userId;\n  } catch {\n    return null;\n  }\n}\n\nrouter.get('/messages', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { q, channelId, serverId, userId: searchUserId, limit = 50 } = req.query;\n  \n  if (!q || q.trim().length < 2) {\n    return res.status(400).json({ error: 'Query must be at least 2 characters' });\n  }\n  \n  let sql = `\n    SELECT m.*, u.username, u.profile_picture,\n           c.name as channel_name, s.name as server_name, s.id as server_id\n    FROM messages m\n    JOIN users u ON m.user_id = u.id\n    LEFT JOIN channels c ON m.channel_id = c.id\n    LEFT JOIN servers s ON c.server_id = s.id\n    WHERE m.content LIKE ?\n  `;\n  const params = [`%${q}%`];\n  \n  if (channelId) {\n    sql += ' AND m.channel_id = ?';\n    params.push(channelId);\n  }\n  \n  if (serverId) {\n    sql += ' AND c.server_id = ?';\n    params.push(serverId);\n  }\n  \n  if (searchUserId) {\n    sql += ' AND m.user_id = ?';\n    params.push(searchUserId);\n  }\n  \n  sql += ` ORDER BY m.created_at DESC LIMIT ?`;\n  params.push(parseInt(limit));\n  \n  db.all(sql, params, (err, messages) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(messages || []);\n  });\n});\n\nrouter.get('/users', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { q, limit = 20 } = req.query;\n  \n  if (!q || q.trim().length < 1) {\n    return res.status(400).json({ error: 'Query required' });\n  }\n  \n  db.all(`\n    SELECT id, username, profile_picture, is_online, status\n    FROM users\n    WHERE username LIKE ?\n    ORDER BY is_online DESC, username ASC\n    LIMIT ?\n  `, [`%${q}%`, parseInt(limit)], (err, users) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(users || []);\n  });\n});\n\nrouter.get('/servers', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { q, limit = 20 } = req.query;\n  \n  if (!q || q.trim().length < 1) {\n    return res.status(400).json({ error: 'Query required' });\n  }\n  \n  db.all(`\n    SELECT s.*, \n           (SELECT COUNT(*) FROM server_members WHERE server_id = s.id) as member_count,\n           CASE WHEN sm.user_id IS NOT NULL THEN 1 ELSE 0 END as is_member\n    FROM servers s\n    LEFT JOIN server_members sm ON s.id = sm.server_id AND sm.user_id = ?\n    WHERE s.name LIKE ? AND s.status = 'active'\n    ORDER BY member_count DESC\n    LIMIT ?\n  `, [userId, `%${q}%`, parseInt(limit)], (err, servers) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(servers || []);\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":3073,"size_tokens":null},"frontend/js/profile.js":{"content":"// Profile page\ndocument.addEventListener('DOMContentLoaded', () => {\n  const user = checkAuth();\n  if (!user) return;\n\n  document.getElementById('profileName').textContent = user.username;\n  document.getElementById('usernameInfo').textContent = user.username;\n  document.getElementById('joinedInfo').textContent = new Date().toLocaleDateString();\n  document.getElementById('profilePic').src = user.profilePicture || 'https://via.placeholder.com/100';\n\n  // Check if user is admin and show admin section\n  checkAdminAndShowUsers();\n\n  const uploadBtn = document.getElementById('uploadBtn');\n  const removeBtn = document.getElementById('removeBtn');\n  const avatarInput = document.getElementById('avatarInput');\n\n  uploadBtn.addEventListener('click', async () => {\n    if (!avatarInput.files.length) return alert('Please select a file');\n\n    const formData = new FormData();\n    formData.append('profilePicture', avatarInput.files[0]);\n\n    try {\n      const response = await fetch('/api/auth/upload-avatar', {\n        method: 'POST',\n        headers: { 'Authorization': `Bearer ${getAuthToken()}` },\n        body: formData\n      });\n\n      const data = await response.json();\n\n      if (response.ok) {\n        user.profilePicture = data.profilePicture;\n        localStorage.setItem('user', JSON.stringify(user));\n        document.getElementById('profilePic').src = data.profilePicture;\n        alert('Avatar updated!');\n        avatarInput.value = '';\n      } else {\n        alert(`Upload failed: ${data.error || 'Unknown error'}`);\n      }\n    } catch (err) {\n      console.error('Upload error:', err);\n      alert('Upload failed: ' + err.message);\n    }\n  });\n\n  removeBtn.addEventListener('click', async () => {\n    try {\n      const response = await fetch('/api/auth/remove-avatar', {\n        method: 'POST',\n        headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n      });\n\n      const data = await response.json();\n\n      if (response.ok) {\n        user.profilePicture = null;\n        localStorage.setItem('user', JSON.stringify(user));\n        document.getElementById('profilePic').src = 'https://via.placeholder.com/100';\n        alert('Avatar removed!');\n      } else {\n        alert(`Remove failed: ${data.error || 'Unknown error'}`);\n      }\n    } catch (err) {\n      console.error('Remove error:', err);\n      alert('Remove failed: ' + err.message);\n    }\n  });\n\n  // Delete Account\n  const deleteAccountBtn = document.getElementById('deleteAccountBtn');\n  if (deleteAccountBtn) {\n    deleteAccountBtn.addEventListener('click', async () => {\n      const confirmFirst = confirm('Are you sure you want to delete your account? This action cannot be undone.');\n      if (!confirmFirst) return;\n      \n      const confirmSecond = confirm('This will permanently delete all your messages, friends, and data. Type \"DELETE\" in the next prompt to confirm.');\n      if (!confirmSecond) return;\n      \n      const typed = prompt('Type DELETE to confirm account deletion:');\n      if (typed !== 'DELETE') {\n        alert('Account deletion cancelled.');\n        return;\n      }\n      \n      try {\n        const response = await fetch('/api/auth/delete-account', {\n          method: 'DELETE',\n          headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n        });\n        \n        const data = await response.json();\n        \n        if (response.ok) {\n          alert('Your account has been deleted. Goodbye!');\n          localStorage.clear();\n          window.location.href = '/public/index.html';\n        } else {\n          alert(`Failed to delete account: ${data.error || 'Unknown error'}`);\n        }\n      } catch (err) {\n        console.error('Delete account error:', err);\n        alert('Failed to delete account: ' + err.message);\n      }\n    });\n  }\n\n  // Change username\n  const changeUsernameBtn = document.getElementById('changeUsernameBtn');\n  const newUsernameInput = document.getElementById('newUsernameInput');\n  const usernameMessage = document.getElementById('usernameMessage');\n\n  changeUsernameBtn.addEventListener('click', async () => {\n    const newUsername = newUsernameInput.value.trim();\n\n    if (!newUsername) {\n      usernameMessage.textContent = 'âŒ Username cannot be empty';\n      usernameMessage.style.color = '#e74c3c';\n      usernameMessage.style.display = 'block';\n      return;\n    }\n\n    if (newUsername.length < 3) {\n      usernameMessage.textContent = 'âŒ Username must be at least 3 characters';\n      usernameMessage.style.color = '#e74c3c';\n      usernameMessage.style.display = 'block';\n      return;\n    }\n\n    if (newUsername.length > 20) {\n      usernameMessage.textContent = 'âŒ Username must be at most 20 characters';\n      usernameMessage.style.color = '#e74c3c';\n      usernameMessage.style.display = 'block';\n      return;\n    }\n\n    try {\n      const response = await fetch('/api/auth/change-username', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${getAuthToken()}`\n        },\n        body: JSON.stringify({ newUsername })\n      });\n\n      const data = await response.json();\n\n      if (response.ok) {\n        // Update user object and tokens\n        user.username = newUsername;\n        localStorage.setItem('user', JSON.stringify(user));\n        localStorage.setItem('authToken', data.token);\n        localStorage.setItem('username', newUsername);\n\n        // Update UI\n        document.getElementById('profileName').textContent = newUsername;\n        document.getElementById('usernameInfo').textContent = newUsername;\n        newUsernameInput.value = '';\n\n        usernameMessage.textContent = 'âœ… Username updated successfully!';\n        usernameMessage.style.color = '#27ae60';\n        usernameMessage.style.display = 'block';\n      } else {\n        usernameMessage.textContent = `âŒ ${data.error || 'Failed to update username'}`;\n        usernameMessage.style.color = '#e74c3c';\n        usernameMessage.style.display = 'block';\n      }\n    } catch (err) {\n      usernameMessage.textContent = 'âŒ Update failed';\n      usernameMessage.style.color = '#e74c3c';\n      usernameMessage.style.display = 'block';\n    }\n  });\n});\n\n// Check if user is admin and show all users\nasync function checkAdminAndShowUsers() {\n  try {\n    const response = await fetch('/api/admin/check', {\n      headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n    });\n    const data = await response.json();\n    \n    if (data.isAdmin) {\n      document.getElementById('adminUsersSection').style.display = 'block';\n      loadAllUsers();\n    }\n  } catch (err) {\n    console.error('Admin check failed:', err);\n  }\n}\n\n// Load all users for admin view\nasync function loadAllUsers() {\n  try {\n    const response = await fetch('/api/admin/users', {\n      headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n    });\n    const users = await response.json();\n    \n    const list = document.getElementById('allUsersList');\n    const countEl = document.getElementById('userCount');\n    \n    countEl.textContent = `Total: ${users.length} users registered`;\n    list.innerHTML = '';\n    \n    users.forEach(user => {\n      const item = document.createElement('div');\n      item.className = 'user-item';\n      \n      let badges = '';\n      if (user.role === 'admin') badges += '<span class=\"badge badge-admin\">ADMIN</span>';\n      if (user.is_banned) badges += '<span class=\"badge badge-banned\">BANNED</span>';\n      else if (user.is_online) badges += '<span class=\"badge badge-online\">Online</span>';\n      else badges += '<span class=\"badge badge-offline\">Offline</span>';\n      if (user.warning_count > 0) badges += `<span class=\"badge badge-warn\">${user.warning_count} warns</span>`;\n      \n      item.innerHTML = `\n        <img src=\"${user.profile_picture || 'https://via.placeholder.com/40'}\" alt=\"\">\n        <div class=\"info\">\n          <div class=\"name\">${escapeHtml(user.username)}${badges}</div>\n          <div class=\"meta\">Joined ${new Date(user.created_at).toLocaleDateString()}</div>\n        </div>\n      `;\n      list.appendChild(item);\n    });\n  } catch (err) {\n    console.error('Failed to load users:', err);\n  }\n}\n\nfunction escapeHtml(text) {\n  const map = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#039;'\n  };\n  return String(text).replace(/[&<>\"']/g, m => map[m]);\n}\n\n// Profile Banner Functionality\nfunction setupBannerUpload() {\n  const bannerInput = document.getElementById('bannerInput');\n  const uploadBannerBtn = document.getElementById('uploadBannerBtn');\n  const removeBannerBtn = document.getElementById('removeBannerBtn');\n  const bannerPreview = document.getElementById('bannerPreview');\n\n  // Load current banner\n  loadBanner();\n\n  uploadBannerBtn.addEventListener('click', async () => {\n    if (!bannerInput.files.length) {\n      alert('Please select an image file');\n      return;\n    }\n\n    const formData = new FormData();\n    formData.append('banner', bannerInput.files[0]);\n\n    try {\n      const response = await fetch('/api/customization/banner', {\n        method: 'POST',\n        headers: { 'Authorization': `Bearer ${getAuthToken()}` },\n        body: formData\n      });\n\n      const data = await response.json();\n      if (response.ok) {\n        bannerPreview.style.backgroundImage = `url(${data.bannerUrl})`;\n        bannerInput.value = '';\n        alert('Banner updated!');\n      } else {\n        alert(data.error || 'Failed to upload banner');\n      }\n    } catch (err) {\n      console.error('Banner upload error:', err);\n      alert('Failed to upload banner');\n    }\n  });\n\n  removeBannerBtn.addEventListener('click', async () => {\n    try {\n      const response = await fetch('/api/customization/banner', {\n        method: 'DELETE',\n        headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n      });\n\n      if (response.ok) {\n        bannerPreview.style.backgroundImage = '';\n        alert('Banner removed!');\n      }\n    } catch (err) {\n      console.error('Banner remove error:', err);\n    }\n  });\n}\n\nasync function loadBanner() {\n  try {\n    const response = await fetch('/api/customization/banner', {\n      headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n    });\n    const data = await response.json();\n    if (data.bannerUrl) {\n      document.getElementById('bannerPreview').style.backgroundImage = `url(${data.bannerUrl})`;\n    }\n  } catch (err) {\n    console.error('Failed to load banner:', err);\n  }\n}\n\n// Wallpaper Functionality\nfunction setupWallpaperUpload() {\n  const wallpaperInput = document.getElementById('wallpaperInput');\n  const uploadWallpaperBtn = document.getElementById('uploadWallpaperBtn');\n  const removeWallpaperBtn = document.getElementById('removeWallpaperBtn');\n  const wallpaperStatus = document.getElementById('wallpaperStatus');\n\n  uploadWallpaperBtn.addEventListener('click', async () => {\n    if (!wallpaperInput.files.length) {\n      alert('Please select an image file');\n      return;\n    }\n\n    const formData = new FormData();\n    formData.append('wallpaper', wallpaperInput.files[0]);\n\n    try {\n      const response = await fetch('/api/customization/wallpaper', {\n        method: 'POST',\n        headers: { 'Authorization': `Bearer ${getAuthToken()}` },\n        body: formData\n      });\n\n      const data = await response.json();\n      if (response.ok) {\n        localStorage.setItem('customWallpaper', data.wallpaperUrl);\n        wallpaperStatus.textContent = 'Wallpaper set! Refresh dashboard to see it.';\n        wallpaperStatus.style.color = 'var(--accent)';\n        wallpaperStatus.style.display = 'block';\n        wallpaperInput.value = '';\n      } else {\n        alert(data.error || 'Failed to upload wallpaper');\n      }\n    } catch (err) {\n      console.error('Wallpaper upload error:', err);\n      alert('Failed to upload wallpaper');\n    }\n  });\n\n  removeWallpaperBtn.addEventListener('click', async () => {\n    try {\n      const response = await fetch('/api/customization/wallpaper', {\n        method: 'DELETE',\n        headers: { 'Authorization': `Bearer ${getAuthToken()}` }\n      });\n\n      if (response.ok) {\n        localStorage.removeItem('customWallpaper');\n        wallpaperStatus.textContent = 'Wallpaper removed!';\n        wallpaperStatus.style.color = 'var(--text-secondary)';\n        wallpaperStatus.style.display = 'block';\n      }\n    } catch (err) {\n      console.error('Wallpaper remove error:', err);\n    }\n  });\n}\n\n// Initialize banner and wallpaper on page load\ndocument.addEventListener('DOMContentLoaded', () => {\n  setupBannerUpload();\n  setupWallpaperUpload();\n});\n","path":null,"size_bytes":12574,"size_tokens":null},"backend/routes/servers.js":{"content":"const express = require('express');\nconst db = require('../db');\nconst { logUpdate, logGlobalUpdate, UPDATE_TYPES } = require('../utils/updateLogger');\n\nconst router = express.Router();\n\n// Get all public servers\nrouter.get('/', (req, res) => {\n  db.all(`\n    SELECT s.*, u.username as owner_name, \n           (SELECT COUNT(*) FROM server_members WHERE server_id = s.id) as member_count\n    FROM servers s\n    JOIN users u ON s.owner_id = u.id\n    WHERE s.status = 'active'\n  `, (err, servers) => {\n    res.json(servers || []);\n  });\n});\n\n// Get server details\nrouter.get('/:id', (req, res) => {\n  db.get(`\n    SELECT s.*, u.username as owner_name \n    FROM servers s\n    JOIN users u ON s.owner_id = u.id\n    WHERE s.id = ?\n  `, [req.params.id], (err, server) => {\n    if (server) {\n      db.all('SELECT * FROM channels WHERE server_id = ?', [req.params.id], (err, channels) => {\n        res.json({ ...server, channels });\n      });\n    } else {\n      res.status(404).json({ error: 'Server not found' });\n    }\n  });\n});\n\n// Get server channels\nrouter.get('/:id/channels', (req, res) => {\n  db.all('SELECT * FROM channels WHERE server_id = ?', [req.params.id], (err, channels) => {\n    res.json(channels || []);\n  });\n});\n\n// Join server\nrouter.post('/:id/join', (req, res) => {\n  const { userId } = req.body;\n  \n  db.run(`\n    INSERT INTO server_members (server_id, user_id) \n    VALUES (?, ?) ON CONFLICT DO NOTHING\n  `, [req.params.id, userId], (err) => {\n    if (err) {\n      return res.status(400).json({ error: 'Failed to join server' });\n    }\n    res.json({ success: true });\n  });\n});\n\n// Direct server creation (no admin approval required)\nrouter.post('/create', (req, res) => {\n  const { userId, serverName, description } = req.body;\n  \n  if (!userId || !serverName) {\n    return res.status(400).json({ error: 'User ID and server name are required' });\n  }\n  \n  if (serverName.length > 50) {\n    return res.status(400).json({ error: 'Server name must be 50 characters or less' });\n  }\n  \n  db.run(`\n    INSERT INTO servers (name, owner_id, description, needs_setup, status)\n    VALUES (?, ?, ?, false, 'active')\n  `, [serverName.trim(), userId, description || ''], function(err) {\n    if (err) {\n      console.error('Server creation error:', err);\n      return res.status(400).json({ error: 'Failed to create server: ' + (err.message || 'Unknown error') });\n    }\n    \n    const serverId = this.lastID;\n    \n    if (!serverId) {\n      return res.status(400).json({ error: 'Failed to get server ID after creation' });\n    }\n    \n    // Add owner as member\n    db.run('INSERT INTO server_members (server_id, user_id) VALUES (?, ?) ON CONFLICT(server_id, user_id) DO NOTHING', \n      [serverId, userId], (memberErr) => {\n        if (memberErr) console.error('Failed to add owner as member:', memberErr);\n      });\n    \n    // Create default #general channel\n    db.run('INSERT INTO channels (server_id, name) VALUES (?, ?)', \n      [serverId, 'general'], (channelErr) => {\n        if (channelErr) console.error('Failed to create default channel:', channelErr);\n      });\n    \n    // Auto-log the server creation\n    logUpdate(UPDATE_TYPES.SERVER_CREATED, userId, serverId, 'server', serverId, \n      { name: serverName.trim(), description: description || '' }, \n      'Server created').catch(err => console.error('Failed to log server creation:', err));\n    \n    res.json({ success: true, serverId, serverName: serverName.trim() });\n  });\n});\n\n// Request to create server (legacy - still works but redirects to direct creation)\nrouter.post('/request', (req, res) => {\n  const { userId, serverName, description } = req.body;\n\n  db.run(`\n    INSERT INTO server_requests (user_id, server_name, description) \n    VALUES (?, ?, ?)\n  `, [userId, serverName, description], (err) => {\n    if (err) {\n      return res.status(400).json({ error: 'Failed to submit request' });\n    }\n    res.json({ success: true, message: 'Server creation request submitted. Awaiting admin approval.' });\n  });\n});\n\n// Get user's servers\nrouter.get('/user/:userId', (req, res) => {\n  db.all(`\n    SELECT DISTINCT s.*, u.username as owner_name\n    FROM servers s\n    JOIN users u ON s.owner_id = u.id\n    LEFT JOIN server_members sm ON s.id = sm.server_id\n    WHERE sm.user_id = ? OR s.owner_id = ?\n    ORDER BY s.created_at DESC\n  `, [req.params.userId, req.params.userId], (err, servers) => {\n    res.json(servers || []);\n  });\n});\n\n// Get server messages (from first channel)\nrouter.get('/:id/messages', (req, res) => {\n  const offset = parseInt(req.query.offset) || 0;\n  const limit = parseInt(req.query.limit) || 50;\n  \n  // Get first channel of the server\n  db.get('SELECT id FROM channels WHERE server_id = ? ORDER BY id ASC LIMIT 1', [req.params.id], (err, channel) => {\n    if (!channel) {\n      return res.json([]);\n    }\n    \n    db.all(`\n      SELECT m.id, m.channel_id, m.user_id as userId, m.content, m.created_at as createdAt,\n             u.username, u.profile_picture as profilePicture\n      FROM messages m\n      JOIN users u ON m.user_id = u.id\n      WHERE m.channel_id = ?\n      ORDER BY m.created_at DESC\n      LIMIT ? OFFSET ?\n    `, [channel.id, limit, offset], (err, messages) => {\n      res.json((messages || []).reverse());\n    });\n  });\n});\n\n// Get server members - requires membership\nrouter.get('/:id/members', (req, res) => {\n  const serverId = req.params.id;\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  let userId;\n  try {\n    const decoded = require('jsonwebtoken').verify(token, 'real_user_auth_secret_2025');\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  // Verify user is a member of this server\n  db.get('SELECT * FROM server_members WHERE server_id = ? AND user_id = ?', \n    [serverId, userId], (err, membership) => {\n      if (!membership) {\n        return res.status(403).json({ error: 'You are not a member of this server' });\n      }\n      \n      db.all(`\n        SELECT u.id, u.username, u.profile_picture, u.is_online\n        FROM server_members sm\n        JOIN users u ON sm.user_id = u.id\n        WHERE sm.server_id = ?\n      `, [serverId], (err, members) => {\n        res.json(members || []);\n      });\n    });\n});\n\n// Leave server (any member except owner)\nrouter.post('/:id/leave', (req, res) => {\n  const serverId = req.params.id;\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  let userId;\n  try {\n    const decoded = require('jsonwebtoken').verify(token, 'real_user_auth_secret_2025');\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  // Get server details first\n  db.get('SELECT id, name, owner_id FROM servers WHERE id = ?', [serverId], (err, server) => {\n    if (!server) {\n      return res.status(404).json({ error: 'Server not found' });\n    }\n    \n    // Can't leave the Welcome server\n    if (server.name === 'Welcome') {\n      return res.status(400).json({ error: 'Cannot leave the Welcome server' });\n    }\n    \n    // Owner cannot leave (must delete instead)\n    if (server.owner_id === userId) {\n      return res.status(400).json({ error: 'Owner cannot leave. Delete the server instead.' });\n    }\n    \n    // Verify user is a member\n    db.get('SELECT * FROM server_members WHERE server_id = ? AND user_id = ?', \n      [serverId, userId], (err, membership) => {\n        if (!membership) {\n          return res.status(403).json({ error: 'You are not a member of this server' });\n        }\n        \n        db.run('DELETE FROM server_members WHERE server_id = ? AND user_id = ?', \n          [serverId, userId], (err) => {\n            if (err) {\n              return res.status(500).json({ error: 'Failed to leave server' });\n            }\n            res.json({ success: true, message: 'Left server successfully' });\n          });\n      });\n  });\n});\n\n// Kick member from server (owner only)\nrouter.post('/:id/kick/:userId', (req, res) => {\n  const { id: serverId, userId: targetUserId } = req.params;\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  let requesterId;\n  try {\n    const decoded = require('jsonwebtoken').verify(token, 'real_user_auth_secret_2025');\n    requesterId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  // Get server details and verify ownership\n  db.get('SELECT id, name, owner_id FROM servers WHERE id = ?', [serverId], (err, server) => {\n    if (!server) {\n      return res.status(404).json({ error: 'Server not found' });\n    }\n    \n    // Can't kick from Welcome server\n    if (server.name === 'Welcome') {\n      return res.status(400).json({ error: 'Cannot kick members from the Welcome server' });\n    }\n    \n    if (server.owner_id !== requesterId) {\n      return res.status(403).json({ error: 'Only the server owner can kick members' });\n    }\n    if (parseInt(targetUserId) === requesterId) {\n      return res.status(400).json({ error: 'Cannot kick yourself' });\n    }\n    \n    db.run('DELETE FROM server_members WHERE server_id = ? AND user_id = ?', \n      [serverId, targetUserId], (err) => {\n        if (err) {\n          return res.status(500).json({ error: 'Failed to kick member' });\n        }\n        res.json({ success: true, message: 'Member kicked from server' });\n      });\n  });\n});\n\n// Rename server (owner only)\nrouter.put('/:id/rename', (req, res) => {\n  const serverId = req.params.id;\n  const { name } = req.body;\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  let userId;\n  try {\n    const decoded = require('jsonwebtoken').verify(token, 'real_user_auth_secret_2025');\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  if (!name || name.trim().length === 0) {\n    return res.status(400).json({ error: 'Server name is required' });\n  }\n  \n  db.get('SELECT id, name, owner_id FROM servers WHERE id = ?', [serverId], (err, server) => {\n    if (!server) {\n      return res.status(404).json({ error: 'Server not found' });\n    }\n    \n    if (server.name === 'Welcome') {\n      return res.status(400).json({ error: 'Cannot rename the Welcome server' });\n    }\n    \n    if (server.owner_id !== userId) {\n      return res.status(403).json({ error: 'Only the server owner can rename the server' });\n    }\n    \n    db.run('UPDATE servers SET name = ? WHERE id = ?', [name.trim(), serverId], (err) => {\n      if (err) {\n        return res.status(500).json({ error: 'Failed to rename server' });\n      }\n      res.json({ success: true, message: 'Server renamed successfully' });\n    });\n  });\n});\n\n// Add channel to server (owner only)\nrouter.post('/:id/channels', (req, res) => {\n  const serverId = req.params.id;\n  const { name } = req.body;\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  let userId;\n  try {\n    const decoded = require('jsonwebtoken').verify(token, 'real_user_auth_secret_2025');\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  if (!name || name.trim().length === 0) {\n    return res.status(400).json({ error: 'Channel name is required' });\n  }\n  \n  db.get('SELECT id, name, owner_id FROM servers WHERE id = ?', [serverId], (err, server) => {\n    if (!server) {\n      return res.status(404).json({ error: 'Server not found' });\n    }\n    \n    if (server.name === 'Welcome') {\n      return res.status(400).json({ error: 'Cannot add channels to the Welcome server' });\n    }\n    \n    if (server.owner_id !== userId) {\n      return res.status(403).json({ error: 'Only the server owner can add channels' });\n    }\n    \n    const channelName = name.trim().toLowerCase().replace(/\\s+/g, '-');\n    \n    db.run('INSERT INTO channels (server_id, name) VALUES (?, ?)', [serverId, channelName], function(err) {\n      if (err) {\n        return res.status(500).json({ error: 'Failed to add channel' });\n      }\n      res.json({ success: true, channelId: this.lastID, name: channelName });\n    });\n  });\n});\n\n// Rename channel (owner only)\nrouter.put('/:serverId/channels/:channelId/rename', (req, res) => {\n  const { serverId, channelId } = req.params;\n  const { name } = req.body;\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  let userId;\n  try {\n    const decoded = require('jsonwebtoken').verify(token, 'real_user_auth_secret_2025');\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  if (!name || name.trim().length === 0) {\n    return res.status(400).json({ error: 'Channel name is required' });\n  }\n  \n  db.get('SELECT id, name, owner_id FROM servers WHERE id = ?', [serverId], (err, server) => {\n    if (!server) {\n      return res.status(404).json({ error: 'Server not found' });\n    }\n    \n    if (server.name === 'Welcome') {\n      return res.status(400).json({ error: 'Cannot rename channels in the Welcome server' });\n    }\n    \n    if (server.owner_id !== userId) {\n      return res.status(403).json({ error: 'Only the server owner can rename channels' });\n    }\n    \n    const channelName = name.trim().toLowerCase().replace(/\\s+/g, '-');\n    \n    db.run('UPDATE channels SET name = ? WHERE id = ? AND server_id = ?', \n      [channelName, channelId, serverId], (err) => {\n        if (err) {\n          return res.status(500).json({ error: 'Failed to rename channel' });\n        }\n        res.json({ success: true, name: channelName });\n      });\n  });\n});\n\n// Delete channel (owner only, must keep at least 1)\nrouter.delete('/:serverId/channels/:channelId', (req, res) => {\n  const { serverId, channelId } = req.params;\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  let userId;\n  try {\n    const decoded = require('jsonwebtoken').verify(token, 'real_user_auth_secret_2025');\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  db.get('SELECT id, name, owner_id FROM servers WHERE id = ?', [serverId], (err, server) => {\n    if (!server) {\n      return res.status(404).json({ error: 'Server not found' });\n    }\n    \n    if (server.name === 'Welcome') {\n      return res.status(400).json({ error: 'Cannot delete channels from the Welcome server' });\n    }\n    \n    if (server.owner_id !== userId) {\n      return res.status(403).json({ error: 'Only the server owner can delete channels' });\n    }\n    \n    // Check if this is the last channel\n    db.get('SELECT COUNT(*) as count FROM channels WHERE server_id = ?', [serverId], (err, result) => {\n      if (result.count <= 1) {\n        return res.status(400).json({ error: 'Cannot delete the last channel. Server must have at least one channel.' });\n      }\n      \n      // Delete messages in this channel first\n      db.run('DELETE FROM messages WHERE channel_id = ?', [channelId], () => {\n        db.run('DELETE FROM channels WHERE id = ? AND server_id = ?', [channelId, serverId], (err) => {\n          if (err) {\n            return res.status(500).json({ error: 'Failed to delete channel' });\n          }\n          res.json({ success: true, message: 'Channel deleted successfully' });\n        });\n      });\n    });\n  });\n});\n\n// Check if user needs to setup their newly approved server\nrouter.get('/pending-setup/:userId', (req, res) => {\n  const userId = req.params.userId;\n  \n  // Find servers owned by user that have a default 'general' channel with no custom setup\n  db.all(`\n    SELECT s.id, s.name, s.description, s.created_at\n    FROM servers s\n    WHERE s.owner_id = ? \n      AND s.id != 1\n      AND s.needs_setup = TRUE\n  `, [userId], (err, servers) => {\n    res.json(servers || []);\n  });\n});\n\n// Mark server as setup complete\nrouter.post('/:id/complete-setup', (req, res) => {\n  const serverId = req.params.id;\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  let userId;\n  try {\n    const decoded = require('jsonwebtoken').verify(token, 'real_user_auth_secret_2025');\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  db.get('SELECT owner_id FROM servers WHERE id = ?', [serverId], (err, server) => {\n    if (!server || server.owner_id !== userId) {\n      return res.status(403).json({ error: 'Unauthorized' });\n    }\n    \n    db.run('UPDATE servers SET needs_setup = FALSE WHERE id = ?', [serverId], (err) => {\n      if (err) {\n        return res.status(500).json({ error: 'Failed to complete setup' });\n      }\n      res.json({ success: true });\n    });\n  });\n});\n\n// Delete server (owner only)\nrouter.delete('/:id', (req, res) => {\n  const serverId = req.params.id;\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  let userId;\n  try {\n    const decoded = require('jsonwebtoken').verify(token, 'real_user_auth_secret_2025');\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  // Get server details and verify ownership\n  db.get('SELECT id, name, owner_id FROM servers WHERE id = ?', [serverId], (err, server) => {\n    if (!server) {\n      return res.status(404).json({ error: 'Server not found' });\n    }\n    \n    // Can't delete Welcome server\n    if (server.name === 'Welcome') {\n      return res.status(400).json({ error: 'Cannot delete the Welcome server' });\n    }\n    \n    if (server.owner_id !== userId) {\n      return res.status(403).json({ error: 'Only the server owner can delete the server' });\n    }\n    \n    // Get all channels for this server\n    db.all('SELECT id FROM channels WHERE server_id = ?', [serverId], (err, channels) => {\n      const channelIds = (channels || []).map(c => c.id);\n      \n      // Delete all messages from server channels\n      if (channelIds.length > 0) {\n        const placeholders = channelIds.map(() => '?').join(',');\n        db.run(`DELETE FROM messages WHERE channel_id IN (${placeholders})`, channelIds, () => {});\n      }\n      \n      // Delete all channels\n      db.run('DELETE FROM channels WHERE server_id = ?', [serverId], () => {\n        // Delete all members\n        db.run('DELETE FROM server_members WHERE server_id = ?', [serverId], () => {\n          // Delete the server\n          db.run('DELETE FROM servers WHERE id = ?', [serverId], (err) => {\n            if (err) {\n              return res.status(500).json({ error: 'Failed to delete server' });\n            }\n            res.json({ success: true, message: 'Server deleted successfully' });\n          });\n        });\n      });\n    });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":18430,"size_tokens":null},"frontend/js/auth.js":{"content":"// Authentication and authorization\nfunction checkAuth() {\n  const token = localStorage.getItem('authToken');\n  const user = localStorage.getItem('user');\n\n  if (!token || !user) {\n    window.location.href = '/public/index.html';\n    return null;\n  }\n\n  try {\n    return JSON.parse(user);\n  } catch (err) {\n    window.location.href = '/public/index.html';\n    return null;\n  }\n}\n\n// Check auth on private pages\nif (window.location.pathname.includes('/private/')) {\n  document.addEventListener('DOMContentLoaded', checkAuth);\n}\n\nfunction logout() {\n  localStorage.removeItem('authToken');\n  localStorage.removeItem('user');\n  localStorage.removeItem('autoLoginCreds');\n  localStorage.removeItem('userToken');\n  localStorage.removeItem('userId');\n  localStorage.removeItem('username');\n  localStorage.removeItem('profilePicture');\n  window.location.href = '/public/index.html';\n}\n\nfunction getCurrentUser() {\n  const user = localStorage.getItem('user');\n  return user ? JSON.parse(user) : null;\n}\n\nfunction getAuthToken() {\n  return localStorage.getItem('authToken');\n}\n","path":null,"size_bytes":1068,"size_tokens":null},"backend/routes/auth.js":{"content":"const express = require('express');\nconst bcrypt = require('bcryptjs');\nconst jwt = require('jsonwebtoken');\nconst multer = require('multer');\nconst fs = require('fs');\nconst path = require('path');\nconst db = require('../db');\nconst logger = require('../logger');\n\nconst router = express.Router();\nconst upload = multer({ dest: 'frontend/uploads/' });\nconst SECRET_KEY = 'real_user_auth_secret_2025';\n\n// Sign up\nrouter.post('/signup', upload.single('profilePicture'), (req, res) => {\n  const { username, password } = req.body;\n  \n  if (!username || !password) {\n    return res.status(400).json({ error: 'Username and password required' });\n  }\n\n  const hashedPassword = bcrypt.hashSync(password, 10);\n  let profilePicture = null;\n\n  if (req.file) {\n    const ext = path.extname(req.file.originalname);\n    const newPath = `uploads/${Date.now()}${ext}`;\n    fs.renameSync(req.file.path, path.join(__dirname, '../../frontend', newPath));\n    profilePicture = `/${newPath}`;\n  }\n\n  db.run(\n    `INSERT INTO users (username, password, profile_picture) VALUES (?, ?, ?)`,\n    [username, hashedPassword, profilePicture],\n    function(err) {\n      if (err) {\n        return res.status(400).json({ error: 'Username already exists' });\n      }\n\n      const token = jwt.sign({ userId: this.lastID, username }, SECRET_KEY);\n      logger.auth('User registered', { username, userId: this.lastID }, this.lastID);\n      \n      // Set HTTP-only cookie for server-side auth\n      res.cookie('authToken', token, {\n        httpOnly: true,\n        sameSite: 'lax',\n        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days\n        path: '/'\n      });\n      \n      res.json({ \n        success: true, \n        userId: this.lastID, \n        username, \n        profilePicture,\n        token \n      });\n    }\n  );\n});\n\n// Login\nrouter.post('/login', (req, res) => {\n  const { username, password } = req.body;\n\n  db.get('SELECT * FROM users WHERE username = ?', [username], (err, user) => {\n    if (err) {\n      return res.status(500).json({ error: 'Database error' });\n    }\n    \n    if (!user) {\n      return res.status(401).json({ error: 'Invalid credentials' });\n    }\n    \n    if (!bcrypt.compareSync(password, user.password)) {\n      return res.status(401).json({ error: 'Invalid credentials' });\n    }\n\n    const token = jwt.sign({ userId: user.id, username: user.username, role: user.role }, SECRET_KEY);\n    logger.auth('User logged in', { username: user.username, userId: user.id, role: user.role }, user.id);\n    \n    // Set HTTP-only cookie for server-side auth\n    res.cookie('authToken', token, {\n      httpOnly: true,\n      sameSite: 'lax',\n      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days\n      path: '/'\n    });\n    \n    res.json({ \n      success: true, \n      userId: user.id, \n      username: user.username, \n      profilePicture: user.profile_picture,\n      role: user.role,\n      isAdmin: user.is_admin,\n      token \n    });\n  });\n});\n\n// Update profile picture\nrouter.post('/update-picture', upload.single('profilePicture'), (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  let userId;\n  try {\n    const decoded = jwt.verify(token, SECRET_KEY);\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  if (!req.file) {\n    return res.status(400).json({ error: 'No file provided' });\n  }\n\n  const ext = path.extname(req.file.originalname);\n  const newPath = `uploads/${Date.now()}${ext}`;\n  fs.renameSync(req.file.path, path.join(__dirname, '../../frontend', newPath));\n  const profilePicture = `/${newPath}`;\n\n  db.run('UPDATE users SET profile_picture = ? WHERE id = ?', [profilePicture, userId], (err) => {\n    if (err) {\n      return res.status(500).json({ error: 'Failed to update profile' });\n    }\n    res.json({ success: true, profilePicture });\n  });\n});\n\n// Upload avatar alias\nrouter.post('/upload-avatar', upload.single('profilePicture'), (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  let userId;\n  try {\n    const decoded = jwt.verify(token, SECRET_KEY);\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  if (!req.file) {\n    return res.status(400).json({ error: 'No file provided' });\n  }\n\n  const ext = path.extname(req.file.originalname);\n  const newPath = `uploads/${Date.now()}${ext}`;\n  fs.renameSync(req.file.path, path.join(__dirname, '../../frontend', newPath));\n  const profilePicture = `/${newPath}`;\n\n  db.run('UPDATE users SET profile_picture = ? WHERE id = ?', [profilePicture, userId], (err) => {\n    if (err) {\n      return res.status(500).json({ error: 'Failed to update profile' });\n    }\n    res.json({ success: true, profilePicture });\n  });\n});\n\n// Remove avatar\nrouter.post('/remove-avatar', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  let userId;\n  try {\n    const decoded = jwt.verify(token, SECRET_KEY);\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  db.run('UPDATE users SET profile_picture = NULL WHERE id = ?', [userId], (err) => {\n    if (err) {\n      return res.status(500).json({ error: 'Failed to remove avatar' });\n    }\n    res.json({ success: true });\n  });\n});\n\n// Get user\nrouter.get('/user/:id', (req, res) => {\n  db.get('SELECT id, username, profile_picture, role, is_online FROM users WHERE id = ?', \n    [req.params.id], (err, user) => {\n      if (user) {\n        res.json(user);\n      } else {\n        res.status(404).json({ error: 'User not found' });\n      }\n    });\n});\n\n// Get all online users\nrouter.get('/users/online', (req, res) => {\n  db.all('SELECT id, username, profile_picture, is_online FROM users WHERE is_online = TRUE', \n    (err, users) => {\n      res.json(users || []);\n    });\n});\n\n// Change username\nrouter.post('/change-username', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  const { newUsername } = req.body;\n  \n  if (!newUsername || newUsername.trim().length === 0) {\n    return res.status(400).json({ error: 'Username cannot be empty' });\n  }\n\n  if (newUsername.length < 3) {\n    return res.status(400).json({ error: 'Username must be at least 3 characters' });\n  }\n\n  if (newUsername.length > 20) {\n    return res.status(400).json({ error: 'Username must be at most 20 characters' });\n  }\n\n  let userId;\n  try {\n    const decoded = jwt.verify(token, SECRET_KEY);\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  db.run('UPDATE users SET username = ? WHERE id = ?', [newUsername, userId], function(err) {\n    if (err) {\n      return res.status(400).json({ error: 'Username already taken' });\n    }\n\n    // Return new token with updated username\n    const newToken = jwt.sign({ userId, username: newUsername, role: 'user' }, SECRET_KEY);\n    res.json({ \n      success: true, \n      username: newUsername,\n      token: newToken\n    });\n  });\n});\n\n// Delete account\nrouter.delete('/delete-account', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  let userId;\n  try {\n    const decoded = jwt.verify(token, SECRET_KEY);\n    userId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  // Delete user data from all related tables\n  const deletions = [\n    'DELETE FROM messages WHERE user_id = ?',\n    'DELETE FROM friends WHERE user_id = ? OR friend_id = ?',\n    'DELETE FROM user_xp WHERE user_id = ?',\n    'DELETE FROM achievements WHERE user_id = ?',\n    'DELETE FROM user_activity WHERE user_id = ?',\n    'DELETE FROM tasks WHERE user_id = ?',\n    'DELETE FROM friend_notes WHERE user_id = ? OR target_user_id = ?',\n    'DELETE FROM poll_votes WHERE user_id = ?',\n    'DELETE FROM user_preferences WHERE user_id = ?',\n    'DELETE FROM user_shortcuts WHERE user_id = ?',\n    'DELETE FROM user_purchases WHERE user_id = ?',\n    'DELETE FROM user_equipped WHERE user_id = ?',\n    'DELETE FROM coin_transactions WHERE user_id = ?',\n    'DELETE FROM daily_rewards WHERE user_id = ?',\n    'DELETE FROM archived_chats WHERE user_id = ?',\n    'DELETE FROM bookmarks WHERE user_id = ?',\n    'DELETE FROM users WHERE id = ?'\n  ];\n\n  let completed = 0;\n  let hasError = false;\n\n  deletions.forEach(sql => {\n    const params = sql.includes('friend_id') || sql.includes('target_user_id') \n      ? [userId, userId] \n      : [userId];\n    \n    db.run(sql, params, (err) => {\n      if (err && !hasError) {\n        console.error('Delete error:', err.message, sql);\n      }\n      completed++;\n      \n      if (completed === deletions.length && !hasError) {\n        logger.auth('User deleted account', { userId }, userId);\n        res.json({ success: true, message: 'Account deleted successfully' });\n      }\n    });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":8825,"size_tokens":null},"frontend/css/private-theme.css":{"content":"/* ======================================\n   ENHANCED THEMING SYSTEM - 36 THEMES\n   ====================================== */\n\n/* CSS Variable Schema for All Themes */\n:root {\n  /* Base colors */\n  --bg: #0D1B2A;\n  --bg-secondary: #1B263B;\n  --card: #1B263B;\n  --card-hover: #253649;\n  --surface: #0D1B2A;\n  \n  /* Text colors */\n  --text: #ffffff;\n  --text-secondary: #a0aec0;\n  --text-muted: #64748b;\n  \n  /* Primary palette */\n  --primary: #4CC9F0;\n  --primary-glow: rgba(76, 201, 240, 0.5);\n  --accent: #A04FF9;\n  --accent-glow: rgba(160, 79, 249, 0.5);\n  \n  /* Status colors */\n  --success: #10b981;\n  --warning: #f59e0b;\n  --danger: #ef4444;\n  --info: #3b82f6;\n  \n  /* Effects */\n  --glow-primary: 0 0 20px var(--primary-glow);\n  --glow-accent: 0 0 20px var(--accent-glow);\n  --glass-bg: rgba(13, 27, 42, 0.8);\n  --glass-border: rgba(76, 201, 240, 0.2);\n  --blur-amount: 20px;\n  \n  /* Gradients */\n  --gradient-primary: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);\n  --gradient-bg: linear-gradient(180deg, var(--bg) 0%, var(--bg-secondary) 100%);\n  --gradient-card: linear-gradient(135deg, var(--card) 0%, var(--surface) 100%);\n  \n  /* Borders */\n  --border-color: rgba(255, 255, 255, 0.1);\n  --border-glow: var(--primary);\n  --radius-sm: 8px;\n  --radius-md: 14px;\n  --radius-lg: 20px;\n  --radius-xl: 28px;\n  \n  /* Shadows */\n  --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.2);\n  --shadow-md: 0 4px 20px rgba(0, 0, 0, 0.3);\n  --shadow-lg: 0 8px 40px rgba(0, 0, 0, 0.4);\n  --shadow-glow: 0 0 30px var(--primary-glow);\n  \n  /* Animation */\n  --transition-fast: 0.15s ease;\n  --transition-normal: 0.3s ease;\n  --transition-slow: 0.5s ease;\n  \n  /* Star colors for particle system */\n  --star-color: var(--primary);\n  --star-color-alt: var(--accent);\n}\n\n/* ======================\n   THEME 1: NEBULACORE (Default)\n   ====================== */\n:root[data-theme=\"nebulacore\"],\n:root {\n  --bg: #0D1B2A;\n  --bg-secondary: #1B263B;\n  --card: rgba(27, 38, 59, 0.8);\n  --card-hover: rgba(37, 54, 73, 0.9);\n  --surface: #0D1B2A;\n  --text: #ffffff;\n  --text-secondary: rgba(76, 201, 240, 0.8);\n  --text-muted: rgba(76, 201, 240, 0.5);\n  --primary: #4CC9F0;\n  --primary-glow: rgba(76, 201, 240, 0.5);\n  --accent: #A04FF9;\n  --accent-glow: rgba(160, 79, 249, 0.5);\n  --glass-bg: rgba(13, 27, 42, 0.85);\n  --glass-border: rgba(76, 201, 240, 0.25);\n  --star-color: #4CC9F0;\n  --star-color-alt: #A04FF9;\n}\n\n/* ======================\n   THEME 2: DEEP OCEAN\n   ====================== */\n:root[data-theme=\"ocean\"] {\n  --bg: #0a0e27;\n  --bg-secondary: #141b3d;\n  --card: rgba(26, 31, 58, 0.9);\n  --card-hover: rgba(36, 45, 80, 0.95);\n  --surface: #0a0e27;\n  --text: #e0e5f0;\n  --text-secondary: #a0a8b8;\n  --text-muted: #6b7280;\n  --primary: #00a8e8;\n  --primary-glow: rgba(0, 168, 232, 0.5);\n  --accent: #00d4ff;\n  --accent-glow: rgba(0, 212, 255, 0.5);\n  --glass-bg: rgba(10, 14, 39, 0.9);\n  --glass-border: rgba(0, 168, 232, 0.2);\n  --star-color: #00d4ff;\n  --star-color-alt: #00a8e8;\n}\n\n/* ======================\n   THEME 3: NEON ARCADE\n   ====================== */\n:root[data-theme=\"arcade\"] {\n  --bg: #0a0a0a;\n  --bg-secondary: #1a1a1a;\n  --card: rgba(26, 26, 26, 0.9);\n  --card-hover: rgba(40, 40, 40, 0.95);\n  --surface: #0a0a0a;\n  --text: #ffffff;\n  --text-secondary: #ff00ff;\n  --text-muted: #cccccc;\n  --primary: #ff00ff;\n  --primary-glow: rgba(255, 0, 255, 0.6);\n  --accent: #00ff00;\n  --accent-glow: rgba(0, 255, 0, 0.6);\n  --glass-bg: rgba(10, 10, 10, 0.9);\n  --glass-border: rgba(255, 0, 255, 0.3);\n  --star-color: #ff00ff;\n  --star-color-alt: #00ff00;\n}\n\n/* ======================\n   THEME 4: COTTON CANDY\n   ====================== */\n:root[data-theme=\"candy\"] {\n  --bg: #fff5f8;\n  --bg-secondary: #ffe8f0;\n  --card: rgba(255, 255, 255, 0.9);\n  --card-hover: rgba(255, 230, 240, 0.95);\n  --surface: #fff5f8;\n  --text: #4a4a4a;\n  --text-secondary: #ff69b4;\n  --text-muted: #888888;\n  --primary: #ff69b4;\n  --primary-glow: rgba(255, 105, 180, 0.4);\n  --accent: #87ceeb;\n  --accent-glow: rgba(135, 206, 235, 0.4);\n  --glass-bg: rgba(255, 255, 255, 0.8);\n  --glass-border: rgba(255, 105, 180, 0.3);\n  --star-color: #ff69b4;\n  --star-color-alt: #87ceeb;\n}\n\n/* ======================\n   THEME 5: SOLAR ECLIPSE\n   ====================== */\n:root[data-theme=\"eclipse\"] {\n  --bg: #0d0d0d;\n  --bg-secondary: #1a1a1a;\n  --card: rgba(26, 26, 26, 0.9);\n  --card-hover: rgba(40, 40, 40, 0.95);\n  --surface: #0d0d0d;\n  --text: #f0f0f0;\n  --text-secondary: #ffd700;\n  --text-muted: #999999;\n  --primary: #ffd700;\n  --primary-glow: rgba(255, 215, 0, 0.5);\n  --accent: #ff8c00;\n  --accent-glow: rgba(255, 140, 0, 0.5);\n  --glass-bg: rgba(13, 13, 13, 0.9);\n  --glass-border: rgba(255, 215, 0, 0.25);\n  --star-color: #ffd700;\n  --star-color-alt: #ff8c00;\n}\n\n/* ======================\n   THEME 6: CYBER MATRIX\n   ====================== */\n:root[data-theme=\"matrix\"] {\n  --bg: #0a0a0a;\n  --bg-secondary: #0d1a0d;\n  --card: rgba(13, 26, 13, 0.9);\n  --card-hover: rgba(20, 40, 20, 0.95);\n  --surface: #0a0a0a;\n  --text: #00ff00;\n  --text-secondary: #00cc00;\n  --text-muted: #008800;\n  --primary: #00ff00;\n  --primary-glow: rgba(0, 255, 0, 0.5);\n  --accent: #00ff7f;\n  --accent-glow: rgba(0, 255, 127, 0.5);\n  --glass-bg: rgba(0, 20, 0, 0.9);\n  --glass-border: rgba(0, 255, 0, 0.3);\n  --star-color: #00ff00;\n  --star-color-alt: #00ff7f;\n}\n\n/* ======================\n   THEME 7: SCHOOL NOTEBOOK\n   ====================== */\n:root[data-theme=\"notebook\"] {\n  --bg: #f0f0f0;\n  --bg-secondary: #e8e8e8;\n  --card: rgba(255, 255, 255, 0.95);\n  --card-hover: rgba(245, 245, 245, 1);\n  --surface: #f0f0f0;\n  --text: #2c3e50;\n  --text-secondary: #3498db;\n  --text-muted: #7f8c8d;\n  --primary: #3498db;\n  --primary-glow: rgba(52, 152, 219, 0.3);\n  --accent: #2980b9;\n  --accent-glow: rgba(41, 128, 185, 0.3);\n  --glass-bg: rgba(255, 255, 255, 0.9);\n  --glass-border: rgba(52, 152, 219, 0.3);\n  --star-color: #3498db;\n  --star-color-alt: #27ae60;\n}\n\n/* ======================\n   THEME 8: MIDNIGHT GAMING\n   ====================== */\n:root[data-theme=\"gaming\"] {\n  --bg: #0a0a14;\n  --bg-secondary: #1a1a2e;\n  --card: rgba(26, 26, 46, 0.9);\n  --card-hover: rgba(35, 35, 60, 0.95);\n  --surface: #0a0a14;\n  --text: #eaeaea;\n  --text-secondary: #00d9ff;\n  --text-muted: #888899;\n  --primary: #00d9ff;\n  --primary-glow: rgba(0, 217, 255, 0.5);\n  --accent: #ff3366;\n  --accent-glow: rgba(255, 51, 102, 0.5);\n  --glass-bg: rgba(10, 10, 20, 0.9);\n  --glass-border: rgba(0, 217, 255, 0.3);\n  --star-color: #00d9ff;\n  --star-color-alt: #ff3366;\n}\n\n/* ======================\n   THEME 9: RETRO PIXEL\n   ====================== */\n:root[data-theme=\"pixel\"] {\n  --bg: #1a1a2e;\n  --bg-secondary: #16213e;\n  --card: rgba(22, 33, 62, 0.95);\n  --card-hover: rgba(30, 45, 80, 1);\n  --surface: #1a1a2e;\n  --text: #ffd700;\n  --text-secondary: #ff00ff;\n  --text-muted: #00ffff;\n  --primary: #ff00ff;\n  --primary-glow: rgba(255, 0, 255, 0.5);\n  --accent: #00ffff;\n  --accent-glow: rgba(0, 255, 255, 0.5);\n  --glass-bg: rgba(26, 26, 46, 0.9);\n  --glass-border: rgba(255, 0, 255, 0.3);\n  --star-color: #ffd700;\n  --star-color-alt: #ff00ff;\n}\n\n/* ======================\n   THEME 10: CLOUDY DAY\n   ====================== */\n:root[data-theme=\"cloudy\"] {\n  --bg: #e8eef3;\n  --bg-secondary: #d4dfe8;\n  --card: rgba(245, 247, 250, 0.9);\n  --card-hover: rgba(230, 235, 242, 0.95);\n  --surface: #e8eef3;\n  --text: #3a4556;\n  --text-secondary: #6c92b8;\n  --text-muted: #7a8a9e;\n  --primary: #6c92b8;\n  --primary-glow: rgba(108, 146, 184, 0.3);\n  --accent: #8ab3d9;\n  --accent-glow: rgba(138, 179, 217, 0.3);\n  --glass-bg: rgba(255, 255, 255, 0.7);\n  --glass-border: rgba(108, 146, 184, 0.3);\n  --star-color: #6c92b8;\n  --star-color-alt: #8ab3d9;\n}\n\n/* ======================\n   THEME 11: ROYAL ACADEMIA\n   ====================== */\n:root[data-theme=\"academia\"] {\n  --bg: #1a1410;\n  --bg-secondary: #2a221a;\n  --card: rgba(61, 50, 48, 0.9);\n  --card-hover: rgba(80, 65, 60, 0.95);\n  --surface: #1a1410;\n  --text: #f5e6d3;\n  --text-secondary: #d4af37;\n  --text-muted: #a89080;\n  --primary: #d4af37;\n  --primary-glow: rgba(212, 175, 55, 0.4);\n  --accent: #c9a961;\n  --accent-glow: rgba(201, 169, 97, 0.4);\n  --glass-bg: rgba(26, 20, 16, 0.9);\n  --glass-border: rgba(212, 175, 55, 0.25);\n  --star-color: #d4af37;\n  --star-color-alt: #c9a961;\n}\n\n/* ======================\n   THEME 12: AURORA BOREALIS\n   ====================== */\n:root[data-theme=\"aurora\"] {\n  --bg: #0a1628;\n  --bg-secondary: #102035;\n  --card: rgba(16, 32, 53, 0.9);\n  --card-hover: rgba(25, 45, 70, 0.95);\n  --surface: #0a1628;\n  --text: #e0f7fa;\n  --text-secondary: #4fd1c5;\n  --text-muted: #81e6d9;\n  --primary: #4fd1c5;\n  --primary-glow: rgba(79, 209, 197, 0.5);\n  --accent: #9f7aea;\n  --accent-glow: rgba(159, 122, 234, 0.5);\n  --glass-bg: rgba(10, 22, 40, 0.9);\n  --glass-border: rgba(79, 209, 197, 0.3);\n  --star-color: #4fd1c5;\n  --star-color-alt: #9f7aea;\n}\n\n/* ======================\n   THEME 13: CHERRY BLOSSOM\n   ====================== */\n:root[data-theme=\"cherry\"] {\n  --bg: #1a1215;\n  --bg-secondary: #2a1f22;\n  --card: rgba(42, 31, 34, 0.9);\n  --card-hover: rgba(55, 40, 45, 0.95);\n  --surface: #1a1215;\n  --text: #fce4ec;\n  --text-secondary: #f8bbd9;\n  --text-muted: #c48b9f;\n  --primary: #f48fb1;\n  --primary-glow: rgba(244, 143, 177, 0.5);\n  --accent: #ce93d8;\n  --accent-glow: rgba(206, 147, 216, 0.5);\n  --glass-bg: rgba(26, 18, 21, 0.9);\n  --glass-border: rgba(244, 143, 177, 0.3);\n  --star-color: #f48fb1;\n  --star-color-alt: #ce93d8;\n}\n\n/* ======================\n   THEME 14: VOLCANIC\n   ====================== */\n:root[data-theme=\"volcanic\"] {\n  --bg: #1a0a0a;\n  --bg-secondary: #2a1010;\n  --card: rgba(42, 16, 16, 0.9);\n  --card-hover: rgba(60, 20, 20, 0.95);\n  --surface: #1a0a0a;\n  --text: #fff5f0;\n  --text-secondary: #ff6b35;\n  --text-muted: #b84a30;\n  --primary: #ff6b35;\n  --primary-glow: rgba(255, 107, 53, 0.5);\n  --accent: #f72585;\n  --accent-glow: rgba(247, 37, 133, 0.5);\n  --glass-bg: rgba(26, 10, 10, 0.9);\n  --glass-border: rgba(255, 107, 53, 0.3);\n  --star-color: #ff6b35;\n  --star-color-alt: #f72585;\n}\n\n/* ======================\n   THEME 15: FOREST DEPTHS\n   ====================== */\n:root[data-theme=\"forest\"] {\n  --bg: #0a1a0f;\n  --bg-secondary: #102a18;\n  --card: rgba(16, 42, 24, 0.9);\n  --card-hover: rgba(25, 55, 35, 0.95);\n  --surface: #0a1a0f;\n  --text: #e8f5e9;\n  --text-secondary: #81c784;\n  --text-muted: #4caf50;\n  --primary: #66bb6a;\n  --primary-glow: rgba(102, 187, 106, 0.5);\n  --accent: #8bc34a;\n  --accent-glow: rgba(139, 195, 74, 0.5);\n  --glass-bg: rgba(10, 26, 15, 0.9);\n  --glass-border: rgba(102, 187, 106, 0.3);\n  --star-color: #66bb6a;\n  --star-color-alt: #8bc34a;\n}\n\n/* ======================\n   THEME 16: CYBER PUNK\n   ====================== */\n:root[data-theme=\"cyberpunk\"] {\n  --bg: #0d0221;\n  --bg-secondary: #1a0533;\n  --card: rgba(26, 5, 51, 0.9);\n  --card-hover: rgba(40, 10, 70, 0.95);\n  --surface: #0d0221;\n  --text: #fcee0a;\n  --text-secondary: #f72585;\n  --text-muted: #b388ff;\n  --primary: #f72585;\n  --primary-glow: rgba(247, 37, 133, 0.6);\n  --accent: #00f5d4;\n  --accent-glow: rgba(0, 245, 212, 0.6);\n  --glass-bg: rgba(13, 2, 33, 0.9);\n  --glass-border: rgba(247, 37, 133, 0.4);\n  --star-color: #f72585;\n  --star-color-alt: #00f5d4;\n}\n\n/* ======================\n   THEME 17: SUNSET VIBES\n   ====================== */\n:root[data-theme=\"sunset\"] {\n  --bg: #1a0f15;\n  --bg-secondary: #2a1520;\n  --card: rgba(42, 21, 32, 0.9);\n  --card-hover: rgba(60, 30, 45, 0.95);\n  --surface: #1a0f15;\n  --text: #fff5f0;\n  --text-secondary: #ff7f50;\n  --text-muted: #cd5c5c;\n  --primary: #ff7f50;\n  --primary-glow: rgba(255, 127, 80, 0.5);\n  --accent: #ffd700;\n  --accent-glow: rgba(255, 215, 0, 0.5);\n  --glass-bg: rgba(26, 15, 21, 0.9);\n  --glass-border: rgba(255, 127, 80, 0.3);\n  --star-color: #ff7f50;\n  --star-color-alt: #ffd700;\n}\n\n/* ======================\n   THEME 18: ARCTIC ICE\n   ====================== */\n:root[data-theme=\"arctic\"] {\n  --bg: #0a1520;\n  --bg-secondary: #102030;\n  --card: rgba(16, 32, 48, 0.9);\n  --card-hover: rgba(25, 45, 65, 0.95);\n  --surface: #0a1520;\n  --text: #e0f7ff;\n  --text-secondary: #80deea;\n  --text-muted: #4dd0e1;\n  --primary: #00bcd4;\n  --primary-glow: rgba(0, 188, 212, 0.5);\n  --accent: #e0f7fa;\n  --accent-glow: rgba(224, 247, 250, 0.4);\n  --glass-bg: rgba(10, 21, 32, 0.9);\n  --glass-border: rgba(0, 188, 212, 0.3);\n  --star-color: #80deea;\n  --star-color-alt: #e0f7fa;\n}\n\n/* ======================\n   THEME 19: GRAPE SODA\n   ====================== */\n:root[data-theme=\"grape\"] {\n  --bg: #1a0a2e;\n  --bg-secondary: #2a1048;\n  --card: rgba(42, 16, 72, 0.9);\n  --card-hover: rgba(55, 25, 90, 0.95);\n  --surface: #1a0a2e;\n  --text: #f3e5f5;\n  --text-secondary: #ce93d8;\n  --text-muted: #ab47bc;\n  --primary: #9c27b0;\n  --primary-glow: rgba(156, 39, 176, 0.5);\n  --accent: #e040fb;\n  --accent-glow: rgba(224, 64, 251, 0.5);\n  --glass-bg: rgba(26, 10, 46, 0.9);\n  --glass-border: rgba(156, 39, 176, 0.3);\n  --star-color: #ce93d8;\n  --star-color-alt: #e040fb;\n}\n\n/* ======================\n   THEME 20: COFFEE HOUSE\n   ====================== */\n:root[data-theme=\"coffee\"] {\n  --bg: #1a1510;\n  --bg-secondary: #2a2218;\n  --card: rgba(42, 34, 24, 0.9);\n  --card-hover: rgba(55, 45, 32, 0.95);\n  --surface: #1a1510;\n  --text: #f5f0e8;\n  --text-secondary: #d7a86e;\n  --text-muted: #a67b4e;\n  --primary: #a67c52;\n  --primary-glow: rgba(166, 124, 82, 0.4);\n  --accent: #8b4513;\n  --accent-glow: rgba(139, 69, 19, 0.4);\n  --glass-bg: rgba(26, 21, 16, 0.9);\n  --glass-border: rgba(166, 124, 82, 0.3);\n  --star-color: #d7a86e;\n  --star-color-alt: #a67c52;\n}\n\n/* ======================\n   THEME 21: MIDNIGHT PURPLE\n   ====================== */\n:root[data-theme=\"midnight\"] {\n  --bg: #0f0a1a;\n  --bg-secondary: #1a1030;\n  --card: rgba(26, 16, 48, 0.9);\n  --card-hover: rgba(35, 25, 65, 0.95);\n  --surface: #0f0a1a;\n  --text: #e8e0f0;\n  --text-secondary: #a78bfa;\n  --text-muted: #8b5cf6;\n  --primary: #8b5cf6;\n  --primary-glow: rgba(139, 92, 246, 0.5);\n  --accent: #c4b5fd;\n  --accent-glow: rgba(196, 181, 253, 0.4);\n  --glass-bg: rgba(15, 10, 26, 0.9);\n  --glass-border: rgba(139, 92, 246, 0.3);\n  --star-color: #a78bfa;\n  --star-color-alt: #c4b5fd;\n}\n\n/* ======================\n   THEME 22: NEON TOKYO\n   ====================== */\n:root[data-theme=\"tokyo\"] {\n  --bg: #0a0a12;\n  --bg-secondary: #141420;\n  --card: rgba(20, 20, 32, 0.9);\n  --card-hover: rgba(30, 30, 45, 0.95);\n  --surface: #0a0a12;\n  --text: #ffffff;\n  --text-secondary: #ff1493;\n  --text-muted: #00ced1;\n  --primary: #ff1493;\n  --primary-glow: rgba(255, 20, 147, 0.5);\n  --accent: #00ced1;\n  --accent-glow: rgba(0, 206, 209, 0.5);\n  --glass-bg: rgba(10, 10, 18, 0.9);\n  --glass-border: rgba(255, 20, 147, 0.3);\n  --star-color: #ff1493;\n  --star-color-alt: #00ced1;\n}\n\n/* ======================\n   THEME 23: EMERALD CITY\n   ====================== */\n:root[data-theme=\"emerald\"] {\n  --bg: #0a1a15;\n  --bg-secondary: #103025;\n  --card: rgba(16, 48, 37, 0.9);\n  --card-hover: rgba(25, 65, 50, 0.95);\n  --surface: #0a1a15;\n  --text: #e8fff5;\n  --text-secondary: #34d399;\n  --text-muted: #10b981;\n  --primary: #10b981;\n  --primary-glow: rgba(16, 185, 129, 0.5);\n  --accent: #6ee7b7;\n  --accent-glow: rgba(110, 231, 183, 0.4);\n  --glass-bg: rgba(10, 26, 21, 0.9);\n  --glass-border: rgba(16, 185, 129, 0.3);\n  --star-color: #34d399;\n  --star-color-alt: #6ee7b7;\n}\n\n/* ======================\n   THEME 24: BLOOD MOON\n   ====================== */\n:root[data-theme=\"bloodmoon\"] {\n  --bg: #0a0508;\n  --bg-secondary: #1a0a10;\n  --card: rgba(26, 10, 16, 0.9);\n  --card-hover: rgba(40, 15, 25, 0.95);\n  --surface: #0a0508;\n  --text: #fff0f0;\n  --text-secondary: #dc2626;\n  --text-muted: #991b1b;\n  --primary: #dc2626;\n  --primary-glow: rgba(220, 38, 38, 0.5);\n  --accent: #450a0a;\n  --accent-glow: rgba(69, 10, 10, 0.4);\n  --glass-bg: rgba(10, 5, 8, 0.9);\n  --glass-border: rgba(220, 38, 38, 0.3);\n  --star-color: #dc2626;\n  --star-color-alt: #fca5a5;\n}\n\n/* ======================\n   THEME 25: COTTON BLUE\n   ====================== */\n:root[data-theme=\"cottonblue\"] {\n  --bg: #f0f8ff;\n  --bg-secondary: #e0f0ff;\n  --card: rgba(255, 255, 255, 0.9);\n  --card-hover: rgba(240, 248, 255, 0.95);\n  --surface: #f0f8ff;\n  --text: #1e3a5f;\n  --text-secondary: #3b82f6;\n  --text-muted: #6b7280;\n  --primary: #3b82f6;\n  --primary-glow: rgba(59, 130, 246, 0.3);\n  --accent: #60a5fa;\n  --accent-glow: rgba(96, 165, 250, 0.3);\n  --glass-bg: rgba(255, 255, 255, 0.8);\n  --glass-border: rgba(59, 130, 246, 0.3);\n  --star-color: #3b82f6;\n  --star-color-alt: #60a5fa;\n}\n\n/* ======================\n   THEME 26: STEAMPUNK\n   ====================== */\n:root[data-theme=\"steampunk\"] {\n  --bg: #1a1408;\n  --bg-secondary: #2a2210;\n  --card: rgba(42, 34, 16, 0.9);\n  --card-hover: rgba(55, 45, 22, 0.95);\n  --surface: #1a1408;\n  --text: #f5e6c8;\n  --text-secondary: #cd853f;\n  --text-muted: #8b4513;\n  --primary: #cd7f32;\n  --primary-glow: rgba(205, 127, 50, 0.5);\n  --accent: #b87333;\n  --accent-glow: rgba(184, 115, 51, 0.5);\n  --glass-bg: rgba(26, 20, 8, 0.9);\n  --glass-border: rgba(205, 127, 50, 0.3);\n  --star-color: #cd7f32;\n  --star-color-alt: #ffd700;\n}\n\n/* ======================\n   THEME 27: LAVENDER DREAM\n   ====================== */\n:root[data-theme=\"lavender\"] {\n  --bg: #f8f5ff;\n  --bg-secondary: #f0e8ff;\n  --card: rgba(255, 255, 255, 0.9);\n  --card-hover: rgba(248, 245, 255, 0.95);\n  --surface: #f8f5ff;\n  --text: #4a3668;\n  --text-secondary: #7c3aed;\n  --text-muted: #9ca3af;\n  --primary: #8b5cf6;\n  --primary-glow: rgba(139, 92, 246, 0.3);\n  --accent: #a78bfa;\n  --accent-glow: rgba(167, 139, 250, 0.3);\n  --glass-bg: rgba(255, 255, 255, 0.8);\n  --glass-border: rgba(139, 92, 246, 0.3);\n  --star-color: #8b5cf6;\n  --star-color-alt: #a78bfa;\n}\n\n/* ======================\n   THEME 28: SPACE GRAY\n   ====================== */\n:root[data-theme=\"spacegray\"] {\n  --bg: #1c1c1e;\n  --bg-secondary: #2c2c2e;\n  --card: rgba(44, 44, 46, 0.9);\n  --card-hover: rgba(58, 58, 60, 0.95);\n  --surface: #1c1c1e;\n  --text: #ffffff;\n  --text-secondary: #98989d;\n  --text-muted: #636366;\n  --primary: #0a84ff;\n  --primary-glow: rgba(10, 132, 255, 0.4);\n  --accent: #5e5ce6;\n  --accent-glow: rgba(94, 92, 230, 0.4);\n  --glass-bg: rgba(28, 28, 30, 0.9);\n  --glass-border: rgba(99, 99, 102, 0.3);\n  --star-color: #0a84ff;\n  --star-color-alt: #5e5ce6;\n}\n\n/* ======================\n   THEME 29: MINT FRESH\n   ====================== */\n:root[data-theme=\"mint\"] {\n  --bg: #f0fff8;\n  --bg-secondary: #e0fff0;\n  --card: rgba(255, 255, 255, 0.9);\n  --card-hover: rgba(240, 255, 248, 0.95);\n  --surface: #f0fff8;\n  --text: #1a4d3e;\n  --text-secondary: #14b8a6;\n  --text-muted: #6b7280;\n  --primary: #14b8a6;\n  --primary-glow: rgba(20, 184, 166, 0.3);\n  --accent: #5eead4;\n  --accent-glow: rgba(94, 234, 212, 0.3);\n  --glass-bg: rgba(255, 255, 255, 0.8);\n  --glass-border: rgba(20, 184, 166, 0.3);\n  --star-color: #14b8a6;\n  --star-color-alt: #5eead4;\n}\n\n/* ======================\n   THEME 30: DARK ROSE\n   ====================== */\n:root[data-theme=\"darkrose\"] {\n  --bg: #1a0a10;\n  --bg-secondary: #2a1018;\n  --card: rgba(42, 16, 24, 0.9);\n  --card-hover: rgba(55, 22, 32, 0.95);\n  --surface: #1a0a10;\n  --text: #fff0f5;\n  --text-secondary: #fb7185;\n  --text-muted: #f43f5e;\n  --primary: #e11d48;\n  --primary-glow: rgba(225, 29, 72, 0.5);\n  --accent: #fda4af;\n  --accent-glow: rgba(253, 164, 175, 0.4);\n  --glass-bg: rgba(26, 10, 16, 0.9);\n  --glass-border: rgba(225, 29, 72, 0.3);\n  --star-color: #fb7185;\n  --star-color-alt: #fda4af;\n}\n\n/* ======================\n   THEME 31: ELECTRIC BLUE\n   ====================== */\n:root[data-theme=\"electric\"] {\n  --bg: #000814;\n  --bg-secondary: #001d3d;\n  --card: rgba(0, 29, 61, 0.9);\n  --card-hover: rgba(0, 40, 80, 0.95);\n  --surface: #000814;\n  --text: #ffffff;\n  --text-secondary: #00b4d8;\n  --text-muted: #0077b6;\n  --primary: #00b4d8;\n  --primary-glow: rgba(0, 180, 216, 0.5);\n  --accent: #90e0ef;\n  --accent-glow: rgba(144, 224, 239, 0.4);\n  --glass-bg: rgba(0, 8, 20, 0.9);\n  --glass-border: rgba(0, 180, 216, 0.3);\n  --star-color: #00b4d8;\n  --star-color-alt: #90e0ef;\n}\n\n/* ======================\n   THEME 32: GOLDEN HOUR\n   ====================== */\n:root[data-theme=\"golden\"] {\n  --bg: #1a1408;\n  --bg-secondary: #2a2010;\n  --card: rgba(42, 32, 16, 0.9);\n  --card-hover: rgba(55, 42, 22, 0.95);\n  --surface: #1a1408;\n  --text: #fff8e8;\n  --text-secondary: #fbbf24;\n  --text-muted: #d97706;\n  --primary: #f59e0b;\n  --primary-glow: rgba(245, 158, 11, 0.5);\n  --accent: #fcd34d;\n  --accent-glow: rgba(252, 211, 77, 0.4);\n  --glass-bg: rgba(26, 20, 8, 0.9);\n  --glass-border: rgba(245, 158, 11, 0.3);\n  --star-color: #fbbf24;\n  --star-color-alt: #fcd34d;\n}\n\n/* ======================\n   THEME 33: SYNTHWAVE\n   ====================== */\n:root[data-theme=\"synthwave\"] {\n  --bg: #090014;\n  --bg-secondary: #15002a;\n  --card: rgba(21, 0, 42, 0.9);\n  --card-hover: rgba(35, 0, 60, 0.95);\n  --surface: #090014;\n  --text: #ff71ce;\n  --text-secondary: #01cdfe;\n  --text-muted: #b967ff;\n  --primary: #ff71ce;\n  --primary-glow: rgba(255, 113, 206, 0.5);\n  --accent: #01cdfe;\n  --accent-glow: rgba(1, 205, 254, 0.5);\n  --glass-bg: rgba(9, 0, 20, 0.9);\n  --glass-border: rgba(255, 113, 206, 0.3);\n  --star-color: #ff71ce;\n  --star-color-alt: #01cdfe;\n}\n\n/* ======================\n   THEME 34: OCEAN BREEZE\n   ====================== */\n:root[data-theme=\"breeze\"] {\n  --bg: #f0fdfa;\n  --bg-secondary: #e0f7f5;\n  --card: rgba(255, 255, 255, 0.9);\n  --card-hover: rgba(240, 253, 250, 0.95);\n  --surface: #f0fdfa;\n  --text: #134e4a;\n  --text-secondary: #0d9488;\n  --text-muted: #6b7280;\n  --primary: #14b8a6;\n  --primary-glow: rgba(20, 184, 166, 0.3);\n  --accent: #2dd4bf;\n  --accent-glow: rgba(45, 212, 191, 0.3);\n  --glass-bg: rgba(255, 255, 255, 0.8);\n  --glass-border: rgba(20, 184, 166, 0.3);\n  --star-color: #14b8a6;\n  --star-color-alt: #2dd4bf;\n}\n\n/* ======================\n   THEME 35: DARK MONO\n   ====================== */\n:root[data-theme=\"mono\"] {\n  --bg: #0a0a0a;\n  --bg-secondary: #141414;\n  --card: rgba(20, 20, 20, 0.9);\n  --card-hover: rgba(30, 30, 30, 0.95);\n  --surface: #0a0a0a;\n  --text: #e5e5e5;\n  --text-secondary: #a3a3a3;\n  --text-muted: #737373;\n  --primary: #ffffff;\n  --primary-glow: rgba(255, 255, 255, 0.3);\n  --accent: #d4d4d4;\n  --accent-glow: rgba(212, 212, 212, 0.3);\n  --glass-bg: rgba(10, 10, 10, 0.9);\n  --glass-border: rgba(255, 255, 255, 0.15);\n  --star-color: #ffffff;\n  --star-color-alt: #a3a3a3;\n}\n\n/* ======================\n   THEME 36: NEON JUNGLE\n   ====================== */\n:root[data-theme=\"jungle\"] {\n  --bg: #021a09;\n  --bg-secondary: #042b10;\n  --card: rgba(4, 43, 16, 0.9);\n  --card-hover: rgba(8, 60, 25, 0.95);\n  --surface: #021a09;\n  --text: #d1fae5;\n  --text-secondary: #34d399;\n  --text-muted: #10b981;\n  --primary: #22c55e;\n  --primary-glow: rgba(34, 197, 94, 0.5);\n  --accent: #4ade80;\n  --accent-glow: rgba(74, 222, 128, 0.5);\n  --glass-bg: rgba(2, 26, 9, 0.9);\n  --glass-border: rgba(34, 197, 94, 0.3);\n  --star-color: #22c55e;\n  --star-color-alt: #4ade80;\n}\n\n/* ======================================\n   GLOBAL STYLES USING CSS VARIABLES\n   ====================================== */\n\n/* Body and base styles */\nbody {\n  background-color: var(--bg);\n  color: var(--text);\n  transition: background-color var(--transition-normal), color var(--transition-normal);\n}\n\n/* Card styles */\n.card,\n.dashboard-card,\n.feature-card,\n.game-card,\n.movie-card,\n.chat-card,\n.navbar,\n.sidebar {\n  background: var(--card);\n  color: var(--text);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  backdrop-filter: blur(var(--blur-amount));\n  transition: all var(--transition-normal);\n}\n\n.card:hover,\n.dashboard-card:hover,\n.feature-card:hover,\n.game-card:hover,\n.movie-card:hover {\n  background: var(--card-hover);\n  border-color: var(--primary);\n  box-shadow: var(--shadow-glow);\n  transform: translateY(-4px);\n}\n\n/* Button styles */\nbutton,\n.btn {\n  background: var(--glass-bg);\n  color: var(--text);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n  transition: all var(--transition-normal);\n  cursor: pointer;\n}\n\nbutton:hover,\n.btn:hover {\n  background: var(--primary);\n  border-color: var(--primary);\n  color: var(--bg);\n  box-shadow: var(--glow-primary);\n}\n\n.btn-primary {\n  background: var(--gradient-primary);\n  border: none;\n  color: white;\n}\n\n.btn-primary:hover {\n  box-shadow: var(--shadow-glow);\n  transform: translateY(-2px);\n}\n\n/* Input styles */\ninput,\nselect,\ntextarea {\n  background: var(--glass-bg);\n  color: var(--text);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n  transition: all var(--transition-normal);\n}\n\ninput:focus,\nselect:focus,\ntextarea:focus {\n  border-color: var(--primary);\n  box-shadow: var(--glow-primary);\n  outline: none;\n}\n\ninput::placeholder,\ntextarea::placeholder {\n  color: var(--text-muted);\n}\n\n/* Link styles */\na {\n  color: var(--primary);\n  transition: color var(--transition-fast);\n}\n\na:hover {\n  color: var(--accent);\n}\n\n/* Navbar specific */\n.navbar {\n  background: var(--glass-bg);\n  border-bottom: 1px solid var(--glass-border);\n  backdrop-filter: blur(var(--blur-amount));\n}\n\n/* Sidebar specific */\n.sidebar {\n  background: var(--glass-bg);\n  border-right: 1px solid var(--glass-border);\n}\n\n/* Scrollbar styling */\n::-webkit-scrollbar {\n  width: 8px;\n  height: 8px;\n}\n\n::-webkit-scrollbar-track {\n  background: var(--bg-secondary);\n}\n\n::-webkit-scrollbar-thumb {\n  background: var(--primary);\n  border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n  background: var(--accent);\n}\n\n/* Glow text effect */\n.glow-text {\n  text-shadow: 0 0 10px var(--primary-glow), 0 0 20px var(--primary-glow);\n}\n\n/* Glass panel effect */\n.glass-panel {\n  background: var(--glass-bg);\n  backdrop-filter: blur(var(--blur-amount));\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n}\n\n/* Status colors */\n.text-success { color: var(--success); }\n.text-warning { color: var(--warning); }\n.text-danger { color: var(--danger); }\n.text-info { color: var(--info); }\n.text-primary { color: var(--primary); }\n.text-accent { color: var(--accent); }\n.text-muted { color: var(--text-muted); }\n\n/* Background colors */\n.bg-success { background-color: var(--success); }\n.bg-warning { background-color: var(--warning); }\n.bg-danger { background-color: var(--danger); }\n.bg-primary { background-color: var(--primary); }\n\n/* Theme selector styling */\n.theme-selector {\n  background: var(--glass-bg);\n  color: var(--text);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n  padding: 8px 32px 8px 12px;\n  font-size: 13px;\n  cursor: pointer;\n  transition: all var(--transition-normal);\n  appearance: none;\n  background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E\");\n  background-repeat: no-repeat;\n  background-position: right 10px center;\n}\n\n.theme-selector:hover {\n  border-color: var(--primary);\n}\n\n.theme-selector:focus {\n  border-color: var(--primary);\n  box-shadow: var(--glow-primary);\n  outline: none;\n}\n\n/* Gradient background for certain sections */\n.gradient-bg {\n  background: var(--gradient-bg);\n}\n\n/* Card icon styling */\n.card-icon {\n  font-size: 2.5rem;\n  margin-bottom: 0.5rem;\n  filter: drop-shadow(0 0 10px var(--primary-glow));\n}\n\n/* Animated gradient text */\n.gradient-text {\n  background: var(--gradient-primary);\n  background-size: 200% 200%;\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  background-clip: text;\n  animation: gradientShift 3s ease infinite;\n}\n\n@keyframes gradientShift {\n  0%, 100% { background-position: 0% 50%; }\n  50% { background-position: 100% 50%; }\n}\n\n/* Pulse animation for notifications */\n@keyframes pulse {\n  0%, 100% { box-shadow: 0 0 0 0 var(--primary-glow); }\n  50% { box-shadow: 0 0 20px 5px var(--primary-glow); }\n}\n\n.pulse {\n  animation: pulse 2s infinite;\n}\n","path":null,"size_bytes":27951,"size_tokens":null},"frontend/css/transitions.css":{"content":"/* Smooth page transitions */\n@keyframes slideInLeft {\n  from {\n    opacity: 0;\n    transform: translateX(-50px);\n  }\n  to {\n    opacity: 1;\n    transform: translateX(0);\n  }\n}\n\n@keyframes slideInRight {\n  from {\n    opacity: 0;\n    transform: translateX(50px);\n  }\n  to {\n    opacity: 1;\n    transform: translateX(0);\n  }\n}\n\n@keyframes slideInUp {\n  from {\n    opacity: 0;\n    transform: translateY(40px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n@keyframes slideInDown {\n  from {\n    opacity: 0;\n    transform: translateY(-40px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n@keyframes waveIn {\n  from {\n    opacity: 0;\n    transform: scale(0.95);\n  }\n  to {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes zoomIn {\n  from {\n    opacity: 0;\n    transform: scale(0.9);\n  }\n  to {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n\n/* Page exit animations */\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n    transform: scale(1);\n  }\n  to {\n    opacity: 0;\n    transform: scale(0.98);\n  }\n}\n\n@keyframes slideOutLeft {\n  from {\n    opacity: 1;\n    transform: translateX(0);\n  }\n  to {\n    opacity: 0;\n    transform: translateX(-50px);\n  }\n}\n\n@keyframes slideOutRight {\n  from {\n    opacity: 1;\n    transform: translateX(0);\n  }\n  to {\n    opacity: 0;\n    transform: translateX(50px);\n  }\n}\n\n/* Page exit state */\nbody.page-exit {\n  animation: fadeOut 0.3s ease-out forwards !important;\n  pointer-events: none;\n}\n\nbody {\n  animation: fadeIn 0.4s ease-out;\n}\n\n/* Apply transitions to different page types */\nbody.public-page {\n  animation: slideInRight 0.5s cubic-bezier(0.22, 1, 0.36, 1);\n}\n\nbody.private-page {\n  animation: zoomIn 0.4s cubic-bezier(0.22, 1, 0.36, 1);\n}\n\nbody.auth-page {\n  animation: waveIn 0.5s cubic-bezier(0.22, 1, 0.36, 1);\n}\n\nbody.chat-page {\n  animation: slideInUp 0.4s cubic-bezier(0.22, 1, 0.36, 1);\n}\n\nbody.games-page {\n  animation: slideInRight 0.4s cubic-bezier(0.22, 1, 0.36, 1);\n}\n\nbody.profile-page {\n  animation: slideInLeft 0.4s cubic-bezier(0.22, 1, 0.36, 1);\n}\n\nbody.movies-page {\n  animation: slideInDown 0.4s cubic-bezier(0.22, 1, 0.36, 1);\n}\n\nbody.proxy-page {\n  animation: zoomIn 0.4s cubic-bezier(0.22, 1, 0.36, 1);\n}\n\n/* Smooth transitions for all navigation links */\na[href]:not([target=\"_blank\"]),\nbutton:not(.search-clear):not(.toggle-btn) {\n  position: relative;\n  transition: all 0.3s ease;\n}\n\n/* Add subtle hover effects */\na[href]:not([target=\"_blank\"]):hover {\n  opacity: 0.85;\n}\n\n/* Page exit animation on click */\na[href]:not([target=\"_blank\"]) {\n  cursor: pointer;\n}\n\n/* Smooth transitions for interactive elements */\ninput, textarea, select {\n  transition: all 0.2s ease;\n}\n\ninput:focus, textarea:focus, select:focus {\n  transition: all 0.2s ease;\n}\n\nbutton {\n  transition: all 0.2s ease;\n}\n\n/* Stagger animations for lists */\n@keyframes listItemIn {\n  from {\n    opacity: 0;\n    transform: translateY(10px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n.dashboard-card {\n  animation: listItemIn 0.5s ease-out;\n}\n\n.game-card {\n  animation: listItemIn 0.4s ease-out;\n}\n\n.service-card {\n  animation: listItemIn 0.4s ease-out;\n}\n\n.server-btn, .channel-btn, .friend-btn {\n  animation: listItemIn 0.3s ease-out;\n}\n\n/* Smooth page exit on navigation */\n@media (prefers-reduced-motion: no-preference) {\n  body {\n    transition: opacity 0.3s ease;\n  }\n}\n","path":null,"size_bytes":3446,"size_tokens":null},"DEPLOY-RENDER.md":{"content":"# Deploying to Render\n\nRender is the easiest way to host this app - no Docker needed!\n\n## Step 1: Push to GitHub\n\n1. Create a new repository on GitHub\n2. Upload the project files (or push from your computer)\n\n## Step 2: Create Render Account\n\n1. Go to https://render.com\n2. Sign up with GitHub (easiest)\n\n## Step 3: Deploy\n\n1. Click **New +** â†’ **Web Service**\n2. Select **Build and deploy from a Git repository** â†’ **Next**\n3. Connect your GitHub repo â†’ Click **Connect**\n\n4. Configure the service:\n   ```\n   Name: k12-enrichment-portal\n   Region: (pick closest to you)\n   Branch: main\n   Runtime: Node\n   Build Command: npm install\n   Start Command: node backend/server.js\n   ```\n\n5. Select **Free** plan\n\n6. Click **Create Web Service**\n\nWait 2-5 minutes for build to complete. You'll get a URL like:\n`https://k12-enrichment-portal.onrender.com`\n\n## That's it!\n\nYour app is now live at your Render URL.\n\n---\n\n## Important Notes\n\n### Free Tier Behavior\n- App sleeps after 15 minutes of no activity\n- First visit after sleep takes ~30-60 seconds to wake up\n- 750 free hours/month\n\n### Keep App Awake (Optional)\nTo prevent sleeping, use a free service like:\n- UptimeRobot (https://uptimerobot.com) - pings your URL every 5 min\n- Cron-job.org - same thing\n\n### Database Note\nThe SQLite database resets when Render restarts your app. For permanent data, you'd need to add a Render PostgreSQL database.\n\n---\n\n## Quick Checklist\n\n- [ ] Push code to GitHub\n- [ ] Create Render account\n- [ ] New â†’ Web Service â†’ Connect repo\n- [ ] Build: `npm install`\n- [ ] Start: `node backend/server.js`\n- [ ] Create Web Service\n- [ ] Wait for \"Live\" status\n- [ ] Visit your URL!\n","path":null,"size_bytes":1670,"size_tokens":null},"frontend/js/private-auth.js":{"content":"// Real account system for private area\n// Separate from the public cover login\n\nfunction checkPrivateAuth() {\n  const userToken = localStorage.getItem('userToken');\n  const authToken = localStorage.getItem('authToken');\n  const isGuest = localStorage.getItem('isGuest') === 'true';\n  \n  // Check for valid guest session (must have been set within last 24 hours)\n  if (isGuest) {\n    const guestStart = parseInt(localStorage.getItem('guestSessionStart') || '0');\n    const sessionAge = Date.now() - guestStart;\n    const maxGuestAge = 24 * 60 * 60 * 1000; // 24 hours\n    \n    if (sessionAge > maxGuestAge) {\n      // Guest session expired, clear it and redirect to auth\n      localStorage.removeItem('isGuest');\n      localStorage.removeItem('guestSessionStart');\n      localStorage.removeItem('userToken');\n      localStorage.removeItem('authToken');\n      localStorage.removeItem('username');\n      window.location.href = '/auth';\n      return false;\n    }\n    return true;\n  }\n  \n  // No valid token and not a valid guest session\n  if (!userToken && !authToken) {\n    window.location.href = '/auth';\n    return false;\n  }\n  \n  // Guest token should also be treated as needing validation\n  if (userToken === 'guest' || authToken === 'guest') {\n    // If there's a guest token but no isGuest flag, clear and redirect\n    localStorage.removeItem('userToken');\n    localStorage.removeItem('authToken');\n    window.location.href = '/auth';\n    return false;\n  }\n  \n  return true;\n}\n\nfunction getCurrentPrivateUser() {\n  const isGuest = localStorage.getItem('isGuest') === 'true';\n  return {\n    token: localStorage.getItem('userToken'),\n    userId: isGuest ? 'guest' : localStorage.getItem('userId'),\n    username: localStorage.getItem('username') || 'Guest',\n    profilePicture: localStorage.getItem('profilePicture'),\n    isGuest: isGuest\n  };\n}\n\nfunction isGuestUser() {\n  return localStorage.getItem('isGuest') === 'true' || localStorage.getItem('userToken') === 'guest';\n}\n\nfunction requireLogin(action) {\n  if (isGuestUser()) {\n    showGuestRestrictionModal(action);\n    return false;\n  }\n  return true;\n}\n\nfunction showGuestRestrictionModal(action) {\n  const existingModal = document.getElementById('guestRestrictionModal');\n  if (existingModal) existingModal.remove();\n  \n  const modal = document.createElement('div');\n  modal.id = 'guestRestrictionModal';\n  modal.innerHTML = `\n    <div style=\"position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:99999;display:flex;align-items:center;justify-content:center;\">\n      <div style=\"background:var(--card,#1a1a2e);padding:30px;border-radius:16px;max-width:400px;text-align:center;border:2px solid var(--primary,#00d4ff);\">\n        <div style=\"font-size:48px;margin-bottom:15px;\">ðŸ”’</div>\n        <h3 style=\"color:var(--text,white);margin-bottom:10px;\">Login Required</h3>\n        <p style=\"color:var(--text-secondary,#aaa);margin-bottom:20px;\">\n          ${action || 'This feature'} is not available for guests. Create an account to unlock all features!\n        </p>\n        <div style=\"display:flex;gap:10px;justify-content:center;\">\n          <button onclick=\"window.location.href='/auth'\" style=\"padding:12px 24px;background:linear-gradient(135deg,var(--primary,#00d4ff),var(--secondary,#7c3aed));border:none;border-radius:8px;color:white;font-weight:600;cursor:pointer;\">\n            Create Account\n          </button>\n          <button onclick=\"this.closest('#guestRestrictionModal').remove()\" style=\"padding:12px 24px;background:transparent;border:2px solid var(--border,#333);border-radius:8px;color:var(--text,white);cursor:pointer;\">\n            Cancel\n          </button>\n        </div>\n      </div>\n    </div>\n  `;\n  document.body.appendChild(modal);\n}\n\nfunction logoutPrivate() {\n  localStorage.clear();\n  window.location.href = '/public/index.html';\n}\n\n// Check auth on private pages\nif (window.location.pathname.includes('/private/')) {\n  if (window.location.pathname !== '/auth') {\n    document.addEventListener('DOMContentLoaded', checkPrivateAuth);\n  }\n}\n","path":null,"size_bytes":4055,"size_tokens":null},"backend/routes/users.js":{"content":"const express = require('express');\nconst bcrypt = require('bcryptjs');\nconst jwt = require('jsonwebtoken');\nconst multer = require('multer');\nconst fs = require('fs');\nconst path = require('path');\nconst db = require('../db');\n\nconst router = express.Router();\nconst upload = multer({ dest: 'frontend/uploads/' });\nconst SECRET_KEY = 'real_user_auth_secret_2025';\n\n// REAL USER SIGNUP (NOT connected to cover login)\nrouter.post('/signup', upload.single('profilePicture'), (req, res) => {\n  const { username, password } = req.body;\n\n  if (!username || !password) {\n    return res.status(400).json({ error: 'Username and password required' });\n  }\n\n  if (username === 'admin') {\n    return res.status(400).json({ error: 'Username not available' });\n  }\n\n  const hashedPassword = bcrypt.hashSync(password, 10);\n  let profilePicture = null;\n\n  if (req.file) {\n    const ext = path.extname(req.file.originalname);\n    const newPath = `uploads/${Date.now()}${ext}`;\n    fs.renameSync(req.file.path, path.join(__dirname, '../../frontend', newPath));\n    profilePicture = `/${newPath}`;\n  }\n\n  db.run(\n    `INSERT INTO users (username, password, profile_picture)\n    VALUES (?, ?, ?)`,\n    [username, hashedPassword, profilePicture],\n    function(err) {\n      if (err) {\n        return res.status(400).json({ error: 'Username already exists' });\n      }\n\n      const userId = this.lastID;\n      const token = jwt.sign({ userId, username }, SECRET_KEY);\n      \n      // Auto-add to Welcome server (ID: 1) with Rules and Moderation Logs channels\n      db.run('INSERT INTO server_members (server_id, user_id) VALUES (?, ?) ON CONFLICT DO NOTHING', [1, userId], () => {});\n      \n      // Set HTTP-only cookie for server-side auth\n      res.cookie('authToken', token, {\n        httpOnly: true,\n        sameSite: 'lax',\n        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days\n        path: '/'\n      });\n      \n      res.json({\n        success: true,\n        userId,\n        username,\n        profilePicture,\n        token\n      });\n    }\n  );\n});\n\n// REAL USER LOGIN (NOT connected to cover login)\nrouter.post('/login', (req, res) => {\n  const { username, password } = req.body;\n\n  // Prevent using cover credentials\n  if (username === 'admin') {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n\n  // Allow both regular users and admin accounts to login\n  db.get('SELECT * FROM users WHERE username = ?', [username], (err, user) => {\n    if (!user || !bcrypt.compareSync(password, user.password)) {\n      return res.status(401).json({ error: 'Invalid credentials' });\n    }\n\n    const token = jwt.sign({ userId: user.id, username: user.username }, SECRET_KEY);\n    \n    // Set HTTP-only cookie for server-side auth\n    res.cookie('authToken', token, {\n      httpOnly: true,\n      sameSite: 'lax',\n      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days\n      path: '/'\n    });\n    \n    res.json({\n      success: true,\n      userId: user.id,\n      username: user.username,\n      profilePicture: user.profile_picture,\n      token\n    });\n  });\n});\n\n// Search user by username\nrouter.get('/search', (req, res) => {\n  const { username } = req.query;\n  if (!username) {\n    return res.status(400).json({ error: 'Username required' });\n  }\n  \n  db.get('SELECT id, username, profile_picture FROM users WHERE username = ?', [username], (err, user) => {\n    if (user) {\n      res.json({\n        id: user.id,\n        username: user.username,\n        profilePicture: user.profile_picture\n      });\n    } else {\n      res.status(404).json({ error: 'User not found' });\n    }\n  });\n});\n\n// Search all users by partial username match (for quick switcher) - requires auth\nrouter.get('/search-all', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  try {\n    jwt.verify(token, SECRET_KEY);\n  } catch {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n  \n  const { q } = req.query;\n  if (!q || q.length < 2) {\n    return res.json([]);\n  }\n  \n  db.all(`\n    SELECT id, username, profile_picture, is_online \n    FROM users \n    WHERE username LIKE ? \n    ORDER BY is_online DESC, username ASC\n    LIMIT 10\n  `, [`%${q}%`], (err, users) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json(users || []);\n  });\n});\n\n// Get user profile (returns camelCase to match frontend)\nrouter.get('/:userId', (req, res) => {\n  db.get('SELECT id, username, profile_picture, created_at FROM users WHERE id = ?', [req.params.userId], (err, user) => {\n    if (user) {\n      res.json({\n        id: user.id,\n        username: user.username,\n        profilePicture: user.profile_picture,\n        createdAt: user.created_at\n      });\n    } else {\n      res.status(404).json({ error: 'User not found' });\n    }\n  });\n});\n\n// Update profile picture\nrouter.post('/:userId/avatar', upload.single('profilePicture'), (req, res) => {\n  if (!req.file) {\n    return res.status(400).json({ error: 'No file provided' });\n  }\n\n  const ext = path.extname(req.file.originalname);\n  const newPath = `uploads/${Date.now()}${ext}`;\n  fs.renameSync(req.file.path, path.join(__dirname, '../../frontend', newPath));\n  const profilePicture = `/${newPath}`;\n\n  db.run('UPDATE users SET profile_picture = ? WHERE id = ?', [profilePicture, req.params.userId], () => {\n    res.json({ success: true, profilePicture });\n  });\n});\n\n// Get/Update user status\nrouter.get('/:userId/status', (req, res) => {\n  db.get('SELECT status, custom_status, custom_status_expiry, is_online FROM users WHERE id = ?', \n    [req.params.userId], (err, user) => {\n      if (!user) return res.status(404).json({ error: 'User not found' });\n      \n      // Check if custom status has expired\n      if (user.custom_status_expiry && new Date(user.custom_status_expiry) < new Date()) {\n        db.run('UPDATE users SET custom_status = NULL, custom_status_expiry = NULL WHERE id = ?', \n          [req.params.userId], () => {});\n        user.custom_status = null;\n        user.custom_status_expiry = null;\n      }\n      \n      res.json({\n        status: user.status || 'offline',\n        customStatus: user.custom_status,\n        customStatusExpiry: user.custom_status_expiry,\n        isOnline: user.is_online\n      });\n    });\n});\n\nrouter.patch('/:userId/status', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  let requesterId;\n  try {\n    const decoded = jwt.verify(token, SECRET_KEY);\n    requesterId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  if (requesterId !== parseInt(req.params.userId)) {\n    return res.status(403).json({ error: 'Can only update your own status' });\n  }\n  \n  const { status, customStatus, customStatusExpiry } = req.body;\n  const validStatuses = ['online', 'away', 'dnd', 'invisible', 'offline'];\n  \n  if (status && !validStatuses.includes(status)) {\n    return res.status(400).json({ error: 'Invalid status' });\n  }\n  \n  const updates = [];\n  const params = [];\n  \n  if (status) {\n    updates.push('status = ?');\n    params.push(status);\n  }\n  if (customStatus !== undefined) {\n    updates.push('custom_status = ?');\n    params.push(customStatus ? customStatus.substring(0, 128) : null);\n  }\n  if (customStatusExpiry !== undefined) {\n    updates.push('custom_status_expiry = ?');\n    params.push(customStatusExpiry);\n  }\n  \n  if (updates.length === 0) {\n    return res.status(400).json({ error: 'No updates provided' });\n  }\n  \n  params.push(req.params.userId);\n  \n  db.run(`UPDATE users SET ${updates.join(', ')} WHERE id = ?`, params, (err) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json({ success: true });\n  });\n});\n\n// Get user full profile with mutual servers/friends\nrouter.get('/:userId/profile', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  let requesterId;\n  try {\n    const decoded = jwt.verify(token, SECRET_KEY);\n    requesterId = decoded.userId;\n  } catch {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  const targetId = parseInt(req.params.userId);\n  \n  // Check if blocked\n  db.get('SELECT id FROM user_blocks WHERE blocker_id = ? AND blocked_id = ?', \n    [targetId, requesterId], (err, blocked) => {\n      if (blocked) {\n        return res.status(403).json({ error: 'You cannot view this profile' });\n      }\n      \n      db.get(`SELECT id, username, profile_picture, status, custom_status, is_online, created_at \n              FROM users WHERE id = ?`, [targetId], (err, user) => {\n        if (!user) return res.status(404).json({ error: 'User not found' });\n        \n        // Get mutual servers\n        db.all(`\n          SELECT s.id, s.name \n          FROM servers s\n          JOIN server_members sm1 ON s.id = sm1.server_id AND sm1.user_id = ?\n          JOIN server_members sm2 ON s.id = sm2.server_id AND sm2.user_id = ?\n        `, [requesterId, targetId], (err, mutualServers) => {\n          \n          // Get mutual friends\n          db.all(`\n            SELECT u.id, u.username, u.profile_picture\n            FROM friends f1\n            JOIN friends f2 ON f1.friend_id = f2.friend_id\n            JOIN users u ON f1.friend_id = u.id\n            WHERE f1.user_id = ? AND f2.user_id = ? AND f1.status = 'accepted' AND f2.status = 'accepted'\n          `, [requesterId, targetId], (err, mutualFriends) => {\n            \n            // Check friendship status\n            db.get(`SELECT status FROM friends WHERE user_id = ? AND friend_id = ?`, \n              [requesterId, targetId], (err, friendship) => {\n                \n                // Check if requester blocked target\n                db.get('SELECT id FROM user_blocks WHERE blocker_id = ? AND blocked_id = ?',\n                  [requesterId, targetId], (err, isBlocked) => {\n                    \n                    res.json({\n                      id: user.id,\n                      username: user.username,\n                      profilePicture: user.profile_picture,\n                      status: user.status || 'offline',\n                      customStatus: user.custom_status,\n                      isOnline: user.is_online,\n                      createdAt: user.created_at,\n                      mutualServers: mutualServers || [],\n                      mutualFriends: mutualFriends || [],\n                      friendshipStatus: friendship?.status || null,\n                      isBlocked: !!isBlocked\n                    });\n                  });\n              });\n          });\n        });\n      });\n    });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":10604,"size_tokens":null},"frontend/css/private.css":{"content":"/* ======================================\n   ENHANCED PRIVATE AREA STYLES\n   NebulaCore Theme Compatible\n   ====================================== */\n\n@import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap');\n\n/* App Container */\n.app-container {\n  width: 100%;\n  min-height: 100vh;\n  background: var(--bg);\n  color: var(--text);\n  font-family: 'Plus Jakarta Sans', -apple-system, BlinkMacSystemFont, sans-serif;\n  position: relative;\n}\n\nh1, h2, h3, h4, h5, h6, .logo-text {\n  font-family: 'Space Grotesk', 'Plus Jakarta Sans', sans-serif;\n}\n\n/* Background gradient overlay */\n.app-container::before {\n  content: '';\n  position: fixed;\n  inset: 0;\n  background: \n    radial-gradient(ellipse at 30% 20%, var(--accent-glow) 0%, transparent 50%),\n    radial-gradient(ellipse at 70% 80%, var(--primary-glow) 0%, transparent 50%);\n  opacity: 0.3;\n  pointer-events: none;\n  z-index: 0;\n}\n\n/* Navbar */\n.navbar {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 16px 32px;\n  background: var(--glass-bg);\n  backdrop-filter: blur(var(--blur-amount));\n  border-bottom: 1px solid var(--glass-border);\n  box-shadow: var(--shadow-md);\n  position: relative;\n  z-index: 100;\n}\n\n.navbar h1 {\n  margin: 0;\n  font-size: 24px;\n  font-weight: 600;\n  background: var(--gradient-primary);\n  background-size: 200% 200%;\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  background-clip: text;\n  animation: gradientShift 8s ease infinite;\n}\n\n@keyframes gradientShift {\n  0%, 100% { background-position: 0% 50%; }\n  50% { background-position: 100% 50%; }\n}\n\n.nav-right {\n  display: flex;\n  gap: 12px;\n  align-items: center;\n}\n\n.theme-selector {\n  padding: 10px 36px 10px 14px;\n  border-radius: var(--radius-md);\n  border: 1px solid var(--glass-border);\n  background: var(--glass-bg);\n  color: var(--text);\n  font-family: 'Inter', sans-serif;\n  font-size: 13px;\n  cursor: pointer;\n  transition: all var(--transition-normal);\n  appearance: none;\n  background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E\");\n  background-repeat: no-repeat;\n  background-position: right 12px center;\n}\n\n.theme-selector:hover {\n  border-color: var(--primary);\n}\n\n.theme-selector:focus {\n  border-color: var(--primary);\n  box-shadow: var(--glow-primary);\n  outline: none;\n}\n\n.help-btn {\n  padding: 10px 16px;\n  background: var(--glass-bg);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n  color: var(--text-secondary);\n  text-decoration: none;\n  font-size: 13px;\n  transition: all var(--transition-normal);\n}\n\n.help-btn:hover {\n  background: var(--primary);\n  border-color: var(--primary);\n  color: var(--bg);\n  box-shadow: var(--glow-primary);\n}\n\n.logout-btn {\n  padding: 10px 20px;\n  background: var(--gradient-primary);\n  color: white;\n  border: none;\n  border-radius: var(--radius-md);\n  text-decoration: none;\n  cursor: pointer;\n  transition: all var(--transition-normal);\n  font-weight: 600;\n  font-size: 13px;\n  box-shadow: var(--shadow-sm);\n}\n\n.logout-btn:hover {\n  transform: translateY(-2px);\n  box-shadow: var(--shadow-glow);\n}\n\n/* Dashboard */\n.dashboard {\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 40px 24px;\n  position: relative;\n  z-index: 1;\n}\n\n.dashboard-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));\n  gap: 24px;\n}\n\n.dashboard-card {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  padding: 36px 24px;\n  background: var(--glass-bg);\n  backdrop-filter: blur(var(--blur-amount));\n  border-radius: var(--radius-xl);\n  border: 1px solid var(--glass-border);\n  cursor: pointer;\n  text-decoration: none;\n  color: inherit;\n  transition: all var(--transition-normal);\n  box-shadow: var(--shadow-md);\n  position: relative;\n  overflow: hidden;\n}\n\n.dashboard-card::before {\n  content: '';\n  position: absolute;\n  inset: 0;\n  background: radial-gradient(circle at 50% 120%, var(--primary-glow) 0%, transparent 60%);\n  opacity: 0;\n  transition: opacity var(--transition-normal);\n}\n\n.dashboard-card:hover {\n  transform: translateY(-8px) scale(1.02);\n  border-color: var(--primary);\n  box-shadow: var(--shadow-lg), var(--shadow-glow);\n}\n\n.dashboard-card:hover::before {\n  opacity: 0.5;\n}\n\n.card-icon {\n  font-size: 52px;\n  margin-bottom: 16px;\n  filter: drop-shadow(0 0 15px var(--primary-glow));\n  transition: transform var(--transition-normal);\n  position: relative;\n  z-index: 1;\n}\n\n.dashboard-card:hover .card-icon {\n  transform: scale(1.15);\n}\n\n.dashboard-card h3 {\n  font-size: 18px;\n  font-weight: 600;\n  margin-bottom: 8px;\n  text-align: center;\n  position: relative;\n  z-index: 1;\n}\n\n.dashboard-card p {\n  font-size: 13px;\n  color: var(--text-secondary);\n  text-align: center;\n  position: relative;\n  z-index: 1;\n}\n\n/* Profile Page */\n.profile-page {\n  max-width: 600px;\n  margin: 40px auto;\n  padding: 0 20px;\n  position: relative;\n  z-index: 1;\n}\n\n.profile-card {\n  background: var(--glass-bg);\n  backdrop-filter: blur(var(--blur-amount));\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-xl);\n  padding: 32px;\n  box-shadow: var(--shadow-lg);\n}\n\n.profile-header {\n  display: flex;\n  gap: 24px;\n  margin-bottom: 32px;\n  align-items: center;\n}\n\n.profile-pic {\n  width: 100px;\n  height: 100px;\n  border-radius: 50%;\n  object-fit: cover;\n  border: 3px solid var(--primary);\n  box-shadow: var(--glow-primary);\n}\n\n.profile-info h2 {\n  margin: 0 0 8px 0;\n  font-size: 24px;\n  background: var(--gradient-primary);\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  background-clip: text;\n}\n\n.profile-info p {\n  margin: 0;\n  color: var(--text-secondary);\n}\n\n.profile-section {\n  margin-bottom: 28px;\n  padding-bottom: 20px;\n  border-bottom: 1px solid var(--glass-border);\n}\n\n.profile-section:last-child {\n  border-bottom: none;\n}\n\n.profile-section h3 {\n  margin-bottom: 16px;\n  font-size: 15px;\n  color: var(--primary);\n  text-transform: uppercase;\n  letter-spacing: 1px;\n}\n\n.info-row {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 12px;\n  padding: 10px 14px;\n  background: rgba(0,0,0,0.2);\n  border-radius: var(--radius-sm);\n}\n\n.info-row label {\n  font-weight: 600;\n  color: var(--text-secondary);\n}\n\ninput[type=\"file\"] {\n  display: block;\n  margin-bottom: 12px;\n  padding: 12px;\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n  background: var(--glass-bg);\n  color: var(--text);\n}\n\n/* Games & Media Pages */\n.games-page,\n.media-page,\n.proxy-page {\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 40px 24px;\n  position: relative;\n  z-index: 1;\n}\n\n.page-header {\n  text-align: center;\n  margin-bottom: 40px;\n}\n\n.page-header h2 {\n  font-size: 2rem;\n  margin-bottom: 8px;\n  background: var(--gradient-primary);\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  background-clip: text;\n}\n\n.page-header p {\n  color: var(--text-secondary);\n}\n\n.search-bar {\n  display: flex;\n  gap: 12px;\n  margin-bottom: 32px;\n  max-width: 500px;\n  margin-left: auto;\n  margin-right: auto;\n}\n\n.search-bar input {\n  flex: 1;\n  padding: 14px 20px;\n  background: var(--glass-bg);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  color: var(--text);\n  font-size: 15px;\n  transition: all var(--transition-normal);\n}\n\n.search-bar input:focus {\n  border-color: var(--primary);\n  box-shadow: var(--glow-primary);\n  outline: none;\n}\n\n.games-grid,\n.media-grid,\n.tools-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));\n  gap: 24px;\n}\n\n.game-card,\n.media-card,\n.tool-card {\n  background: var(--glass-bg);\n  backdrop-filter: blur(var(--blur-amount));\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-xl);\n  padding: 24px;\n  text-align: center;\n  box-shadow: var(--shadow-md);\n  transition: all var(--transition-normal);\n  position: relative;\n  overflow: hidden;\n}\n\n.game-card::before,\n.media-card::before,\n.tool-card::before {\n  content: '';\n  position: absolute;\n  inset: 0;\n  background: radial-gradient(circle at 50% 100%, var(--primary-glow) 0%, transparent 60%);\n  opacity: 0;\n  transition: opacity var(--transition-normal);\n}\n\n.game-card:hover,\n.media-card:hover,\n.tool-card:hover {\n  transform: translateY(-6px);\n  border-color: var(--primary);\n  box-shadow: var(--shadow-lg), var(--shadow-glow);\n}\n\n.game-card:hover::before,\n.media-card:hover::before,\n.tool-card:hover::before {\n  opacity: 0.4;\n}\n\n.game-thumbnail,\n.media-thumbnail,\n.tool-icon {\n  font-size: 48px;\n  margin-bottom: 16px;\n  filter: drop-shadow(0 0 12px var(--primary-glow));\n  position: relative;\n  z-index: 1;\n}\n\n.game-card h3,\n.media-card h3,\n.tool-card h3 {\n  margin: 0 0 10px 0;\n  font-size: 17px;\n  font-weight: 600;\n  position: relative;\n  z-index: 1;\n}\n\n.game-card p,\n.media-card p,\n.tool-card p {\n  color: var(--text-secondary);\n  font-size: 13px;\n  margin-bottom: 16px;\n  position: relative;\n  z-index: 1;\n}\n\n/* Buttons */\n.btn-primary {\n  padding: 12px 24px;\n  background: var(--gradient-primary);\n  color: white;\n  border: none;\n  border-radius: var(--radius-md);\n  cursor: pointer;\n  font-weight: 600;\n  font-size: 14px;\n  transition: all var(--transition-normal);\n  box-shadow: var(--shadow-sm);\n  position: relative;\n  z-index: 1;\n}\n\n.btn-primary:hover {\n  transform: translateY(-2px);\n  box-shadow: var(--shadow-glow);\n}\n\n.btn-secondary {\n  padding: 12px 24px;\n  background: transparent;\n  color: var(--primary);\n  border: 2px solid var(--primary);\n  border-radius: var(--radius-md);\n  cursor: pointer;\n  font-weight: 600;\n  font-size: 14px;\n  transition: all var(--transition-normal);\n  margin-left: 10px;\n  position: relative;\n  z-index: 1;\n}\n\n.btn-secondary:hover {\n  background: var(--primary);\n  color: var(--bg);\n  box-shadow: var(--glow-primary);\n}\n\n/* Category filters */\n.category-filters {\n  display: flex;\n  gap: 10px;\n  flex-wrap: wrap;\n  justify-content: center;\n  margin-bottom: 32px;\n}\n\n.category-btn {\n  padding: 10px 20px;\n  background: var(--glass-bg);\n  border: 1px solid var(--glass-border);\n  border-radius: 20px;\n  color: var(--text-secondary);\n  font-size: 13px;\n  cursor: pointer;\n  transition: all var(--transition-normal);\n}\n\n.category-btn:hover {\n  border-color: var(--primary);\n  color: var(--primary);\n}\n\n.category-btn.active {\n  background: var(--primary);\n  border-color: var(--primary);\n  color: var(--bg);\n}\n\n/* Loading state */\n.loading {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  padding: 60px;\n  color: var(--text-secondary);\n}\n\n.loading-spinner {\n  width: 40px;\n  height: 40px;\n  border: 3px solid var(--glass-border);\n  border-top-color: var(--primary);\n  border-radius: 50%;\n  animation: spin 1s linear infinite;\n  margin-bottom: 16px;\n}\n\n@keyframes spin {\n  to { transform: rotate(360deg); }\n}\n\n/* Empty state */\n.empty-state {\n  text-align: center;\n  padding: 60px 20px;\n  color: var(--text-secondary);\n}\n\n.empty-state-icon {\n  font-size: 64px;\n  margin-bottom: 16px;\n  opacity: 0.5;\n}\n\n/* Modal styles */\n.modal-overlay {\n  position: fixed;\n  inset: 0;\n  background: rgba(0, 0, 0, 0.8);\n  backdrop-filter: blur(8px);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: 1000;\n  opacity: 0;\n  visibility: hidden;\n  transition: all var(--transition-normal);\n}\n\n.modal-overlay.active {\n  opacity: 1;\n  visibility: visible;\n}\n\n.modal {\n  background: var(--glass-bg);\n  backdrop-filter: blur(var(--blur-amount));\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-xl);\n  padding: 32px;\n  width: 90%;\n  max-width: 500px;\n  max-height: 80vh;\n  overflow-y: auto;\n  transform: scale(0.9);\n  transition: transform var(--transition-normal);\n}\n\n.modal-overlay.active .modal {\n  transform: scale(1);\n}\n\n.modal-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 24px;\n}\n\n.modal-header h3 {\n  margin: 0;\n  font-size: 1.25rem;\n  background: var(--gradient-primary);\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  background-clip: text;\n}\n\n.modal-close {\n  width: 36px;\n  height: 36px;\n  border-radius: 50%;\n  border: none;\n  background: rgba(255, 255, 255, 0.1);\n  color: var(--text);\n  font-size: 20px;\n  cursor: pointer;\n  transition: all var(--transition-normal);\n}\n\n.modal-close:hover {\n  background: var(--danger);\n  transform: rotate(90deg);\n}\n\n/* Skeleton Loading */\n.skeleton {\n  background: linear-gradient(90deg, var(--card) 25%, var(--accent) 50%, var(--card) 75%);\n  background-size: 200% 100%;\n  animation: skeleton-loading 1.5s infinite;\n  border-radius: 8px;\n}\n\n@keyframes skeleton-loading {\n  0% { background-position: 200% 0; }\n  100% { background-position: -200% 0; }\n}\n\n.skeleton-text {\n  height: 16px;\n  margin-bottom: 8px;\n  border-radius: 4px;\n}\n\n.skeleton-text.short {\n  width: 60%;\n}\n\n.skeleton-text.medium {\n  width: 80%;\n}\n\n.skeleton-title {\n  height: 24px;\n  width: 40%;\n  margin-bottom: 12px;\n  border-radius: 4px;\n}\n\n.skeleton-avatar {\n  width: 48px;\n  height: 48px;\n  border-radius: 50%;\n}\n\n.skeleton-card {\n  height: 200px;\n  border-radius: 12px;\n}\n\n.skeleton-image {\n  width: 100%;\n  height: 150px;\n  border-radius: 8px;\n}\n\n.skeleton-button {\n  height: 40px;\n  width: 120px;\n  border-radius: 8px;\n}\n\n.skeleton-row {\n  display: flex;\n  gap: 12px;\n  align-items: center;\n  padding: 12px;\n  background: var(--card);\n  border-radius: 8px;\n  margin-bottom: 8px;\n}\n\n.loading-container {\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n  padding: 20px;\n}\n\n/* Reduce motion support */\n.reduce-motion * {\n  animation-duration: 0.01ms !important;\n  animation-iteration-count: 1 !important;\n  transition-duration: 0.01ms !important;\n}\n\n/* High contrast mode */\n.high-contrast {\n  --text: #ffffff !important;\n  --text-secondary: #e0e0e0 !important;\n  --bg: #000000 !important;\n  --card: #1a1a1a !important;\n  --accent: #333333 !important;\n  --primary: #00d4ff !important;\n}\n\n/* Responsive */\n@media (max-width: 768px) {\n  .navbar {\n    padding: 12px 16px;\n    flex-wrap: wrap;\n    gap: 12px;\n  }\n  \n  .navbar h1 {\n    font-size: 20px;\n  }\n  \n  .nav-right {\n    gap: 8px;\n    flex-wrap: wrap;\n  }\n  \n  .theme-selector {\n    display: none;\n  }\n  \n  .dashboard {\n    padding: 24px 16px;\n  }\n  \n  .dashboard-grid {\n    gap: 16px;\n  }\n  \n  .dashboard-card {\n    padding: 28px 20px;\n  }\n  \n  .card-icon {\n    font-size: 40px;\n  }\n}\n","path":null,"size_bytes":14638,"size_tokens":null},"backend/routes/categories.js":{"content":"const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst db = require('../db');\n\nconst router = express.Router();\n\nconst JWT_SECRET = 'real_user_auth_secret_2025';\n\nfunction getUserFromToken(req) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return null;\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch {\n    return null;\n  }\n}\n\nfunction canManageChannels(serverId, userId, callback) {\n  db.get('SELECT owner_id FROM servers WHERE id = ?', [serverId], (err, server) => {\n    if (err || !server) return callback(false);\n    if (server.owner_id === userId) return callback(true);\n    \n    db.all(`\n      SELECT sr.permissions FROM server_roles sr\n      JOIN server_member_roles smr ON sr.id = smr.role_id\n      WHERE smr.server_id = ? AND smr.user_id = ?\n    `, [serverId, userId], (err, roles) => {\n      if (err) return callback(false);\n      for (const role of roles) {\n        const perms = JSON.parse(role.permissions || '{}');\n        if (perms.administrator || perms.manage_channels) {\n          return callback(true);\n        }\n      }\n      callback(false);\n    });\n  });\n}\n\nrouter.get('/server/:serverId', (req, res) => {\n  const serverId = req.params.serverId;\n  \n  db.all(`\n    SELECT cc.*, \n      (SELECT COUNT(*) FROM channels WHERE category_id = cc.id) as channel_count\n    FROM channel_categories cc\n    WHERE cc.server_id = ?\n    ORDER BY cc.position\n  `, [serverId], (err, categories) => {\n    if (err) return res.status(500).json({ error: 'Failed to load categories' });\n    res.json(categories);\n  });\n});\n\nrouter.get('/server/:serverId/structured', (req, res) => {\n  const serverId = req.params.serverId;\n  \n  db.all(`SELECT * FROM channel_categories WHERE server_id = ? ORDER BY position`, [serverId], (err, categories) => {\n    if (err) return res.status(500).json({ error: 'Failed to load categories' });\n    \n    db.all(`SELECT * FROM channels WHERE server_id = ? ORDER BY position`, [serverId], (err, channels) => {\n      if (err) return res.status(500).json({ error: 'Failed to load channels' });\n      \n      const uncategorized = channels.filter(c => !c.category_id);\n      const structured = categories.map(cat => ({\n        ...cat,\n        channels: channels.filter(c => c.category_id === cat.id)\n      }));\n      \n      if (uncategorized.length > 0) {\n        structured.unshift({\n          id: null,\n          name: 'Channels',\n          channels: uncategorized\n        });\n      }\n      \n      res.json(structured);\n    });\n  });\n});\n\nrouter.post('/server/:serverId', (req, res) => {\n  const user = getUserFromToken(req);\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const serverId = req.params.serverId;\n  const { name } = req.body;\n  \n  if (!name) return res.status(400).json({ error: 'Category name is required' });\n  \n  canManageChannels(serverId, user.userId, (canManage) => {\n    if (!canManage) return res.status(403).json({ error: 'No permission to manage channels' });\n    \n    db.get('SELECT MAX(position) as maxPos FROM channel_categories WHERE server_id = ?', [serverId], (err, result) => {\n      const position = (result?.maxPos || 0) + 1;\n      \n      db.run(`\n        INSERT INTO channel_categories (server_id, name, position)\n        VALUES (?, ?, ?)\n      `, [serverId, name, position], function(err) {\n        if (err) return res.status(500).json({ error: 'Failed to create category' });\n        \n        res.json({ \n          success: true, \n          categoryId: this.lastID,\n          message: `Category \"${name}\" created` \n        });\n      });\n    });\n  });\n});\n\nrouter.put('/server/:serverId/:categoryId', (req, res) => {\n  const user = getUserFromToken(req);\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { serverId, categoryId } = req.params;\n  const { name } = req.body;\n  \n  canManageChannels(serverId, user.userId, (canManage) => {\n    if (!canManage) return res.status(403).json({ error: 'No permission to manage channels' });\n    \n    db.run('UPDATE channel_categories SET name = ? WHERE id = ? AND server_id = ?', \n      [name, categoryId, serverId], (err) => {\n        if (err) return res.status(500).json({ error: 'Failed to update category' });\n        res.json({ success: true, message: 'Category updated' });\n      });\n  });\n});\n\nrouter.delete('/server/:serverId/:categoryId', (req, res) => {\n  const user = getUserFromToken(req);\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { serverId, categoryId } = req.params;\n  \n  canManageChannels(serverId, user.userId, (canManage) => {\n    if (!canManage) return res.status(403).json({ error: 'No permission to manage channels' });\n    \n    db.run('UPDATE channels SET category_id = NULL WHERE category_id = ?', [categoryId], () => {\n      db.run('DELETE FROM channel_categories WHERE id = ? AND server_id = ?', \n        [categoryId, serverId], (err) => {\n          if (err) return res.status(500).json({ error: 'Failed to delete category' });\n          res.json({ success: true, message: 'Category deleted' });\n        });\n    });\n  });\n});\n\nrouter.put('/server/:serverId/reorder', (req, res) => {\n  const user = getUserFromToken(req);\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const serverId = req.params.serverId;\n  const { categoryOrder } = req.body;\n  \n  if (!Array.isArray(categoryOrder)) return res.status(400).json({ error: 'Invalid category order' });\n  \n  canManageChannels(serverId, user.userId, (canManage) => {\n    if (!canManage) return res.status(403).json({ error: 'No permission to manage channels' });\n    \n    let completed = 0;\n    categoryOrder.forEach((categoryId, index) => {\n      db.run('UPDATE channel_categories SET position = ? WHERE id = ? AND server_id = ?', \n        [index, categoryId, serverId], () => {\n          completed++;\n          if (completed === categoryOrder.length) {\n            res.json({ success: true, message: 'Category order updated' });\n          }\n        });\n    });\n    \n    if (categoryOrder.length === 0) {\n      res.json({ success: true, message: 'No changes' });\n    }\n  });\n});\n\nrouter.put('/server/:serverId/channel/:channelId/category', (req, res) => {\n  const user = getUserFromToken(req);\n  if (!user) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { serverId, channelId } = req.params;\n  const { categoryId } = req.body;\n  \n  canManageChannels(serverId, user.userId, (canManage) => {\n    if (!canManage) return res.status(403).json({ error: 'No permission to manage channels' });\n    \n    db.run('UPDATE channels SET category_id = ? WHERE id = ? AND server_id = ?', \n      [categoryId || null, channelId, serverId], (err) => {\n        if (err) return res.status(500).json({ error: 'Failed to move channel' });\n        res.json({ success: true, message: 'Channel moved to category' });\n      });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":6918,"size_tokens":null},"backend/routes/friends.js":{"content":"const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst db = require('../db');\n\nconst router = express.Router();\nconst SECRET_KEY = 'real_user_auth_secret_2025';\n\n// Helper to extract userId from token\nfunction getUserIdFromToken(req) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return null;\n  try {\n    const decoded = jwt.verify(token, SECRET_KEY);\n    return decoded.userId;\n  } catch {\n    return null;\n  }\n}\n\n// Send friend request\nrouter.post('/request', (req, res) => {\n  const userId = getUserIdFromToken(req);\n  const { username } = req.body;\n\n  if (!userId) {\n    return res.status(401).json({ error: 'Unauthorized - invalid token' });\n  }\n\n  if (!username) {\n    return res.status(400).json({ error: 'Username required' });\n  }\n\n  if (username === 'admin') {\n    return res.status(400).json({ error: 'Cannot add admin' });\n  }\n\n  // Get friend ID by username (case insensitive)\n  db.get('SELECT id FROM users WHERE LOWER(username) = LOWER(?)', [username], (err, friend) => {\n    if (err) {\n      console.error('Lookup error:', err);\n      return res.status(500).json({ error: 'Database error' });\n    }\n\n    if (!friend) {\n      console.log('User not found:', username);\n      return res.status(404).json({ error: 'User not found: ' + username });\n    }\n\n    console.log('Found friend:', friend, 'Current user:', userId);\n\n    if (friend.id === userId) {\n      return res.status(400).json({ error: 'Cannot add yourself' });\n    }\n\n    // Check if request already exists\n    db.get(\n      'SELECT * FROM friends WHERE (user_id = ? AND friend_id = ?) OR (user_id = ? AND friend_id = ?)',\n      [userId, friend.id, friend.id, userId],\n      (err, existing) => {\n        if (existing) {\n          console.log('Request already exists');\n          return res.status(400).json({ error: 'Request already exists or already friends' });\n        }\n\n        // Create friend request (works offline - just stores in DB)\n        db.run(\n          'INSERT INTO friends (user_id, friend_id, status) VALUES (?, ?, ?)',\n          [userId, friend.id, 'pending'],\n          function(err) {\n            if (err) {\n              console.error('Friend request DB error:', err, {userId, friendId: friend.id});\n              return res.status(500).json({ error: 'Failed to send request: ' + err.message });\n            }\n            console.log('Friend request created successfully');\n            res.json({ success: true, message: 'Friend request sent to ' + username, requestId: this.lastID });\n          }\n        );\n      }\n    );\n  });\n});\n\n// Get pending friend requests (requests sent TO the user)\nrouter.get('/pending', (req, res) => {\n  const userId = getUserIdFromToken(req);\n  if (!userId) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  db.all(\n    `SELECT f.id, u.id as \"userId\", u.username, u.profile_picture as \"profilePicture\", f.created_at\n     FROM friends f\n     JOIN users u ON f.user_id = u.id\n     WHERE f.friend_id = ? AND f.status = 'pending'\n     ORDER BY f.created_at DESC`,\n    [userId],\n    (err, requests) => {\n      if (err) {\n        return res.status(500).json({ error: 'Failed to fetch requests' });\n      }\n      res.json(requests || []);\n    }\n  );\n});\n\n// Accept friend request\nrouter.post('/:friendId/accept', (req, res) => {\n  const userId = getUserIdFromToken(req);\n  const { friendId } = req.params;\n\n  if (!userId) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  // Update request status\n  db.run(\n    'UPDATE friends SET status = ? WHERE user_id = ? AND friend_id = ? AND status = ?',\n    ['accepted', friendId, userId, 'pending'],\n    (err) => {\n      if (err) {\n        return res.status(500).json({ error: 'Failed to accept request' });\n      }\n\n      // Create reverse friendship\n      db.run(\n        `INSERT INTO friends (user_id, friend_id, status)\n         VALUES (?, ?, ?) ON CONFLICT DO NOTHING`,\n        [userId, friendId, 'accepted'],\n        (err) => {\n          res.json({ success: true, message: 'Friend request accepted' });\n        }\n      );\n    }\n  );\n});\n\n// Reject friend request\nrouter.post('/:friendId/reject', (req, res) => {\n  const userId = getUserIdFromToken(req);\n  const { friendId } = req.params;\n\n  if (!userId) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  db.run(\n    'DELETE FROM friends WHERE user_id = ? AND friend_id = ? AND status = ?',\n    [friendId, userId, 'pending'],\n    (err) => {\n      if (err) {\n        return res.status(500).json({ error: 'Failed to reject request' });\n      }\n      res.json({ success: true, message: 'Request rejected' });\n    }\n  );\n});\n\n// Get all friends (accepted friendships)\nrouter.get('/', (req, res) => {\n  const userId = getUserIdFromToken(req);\n  if (!userId) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  db.all(\n    `SELECT DISTINCT CASE \n      WHEN f.user_id = ? THEN f.friend_id \n      ELSE f.user_id \n    END as \"friendId\"\n    FROM friends f\n    WHERE (f.user_id = ? OR f.friend_id = ?) AND f.status = 'accepted'`,\n    [userId, userId, userId],\n    (err, friendIds) => {\n      if (err || !friendIds) {\n        return res.json([]);\n      }\n\n      if (friendIds.length === 0) {\n        return res.json([]);\n      }\n\n      const ids = friendIds.map(f => f.friendid || f.friendId).filter(id => id);\n      if (ids.length === 0) {\n        return res.json([]);\n      }\n      \n      const placeholders = ids.map(() => '?').join(',');\n      db.all(\n        `SELECT id, username, profile_picture as \"profilePicture\", is_online FROM users WHERE id IN (${placeholders})`,\n        ids,\n        (err, friends) => {\n          if (err) {\n            console.error('Error fetching friends:', err);\n            return res.json([]);\n          }\n          res.json(friends || []);\n        }\n      );\n    }\n  );\n});\n\n// Remove friend (unfriend)\nrouter.post('/:friendId/remove', (req, res) => {\n  const userId = getUserIdFromToken(req);\n  const { friendId } = req.params;\n\n  if (!userId) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  db.run(\n    `DELETE FROM friends WHERE \n    (user_id = ? AND friend_id = ?) OR \n    (user_id = ? AND friend_id = ?)`,\n    [userId, friendId, friendId, userId],\n    (err) => {\n      if (err) {\n        return res.status(500).json({ error: 'Failed to remove friend' });\n      }\n      res.json({ success: true, message: 'Friend removed' });\n    }\n  );\n});\n\n// Set nickname for a friend (only visible to you)\nrouter.post('/:friendId/nickname', (req, res) => {\n  const userId = getUserIdFromToken(req);\n  const { friendId } = req.params;\n  const { nickname } = req.body;\n\n  if (!userId) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  if (!nickname || nickname.trim() === '') {\n    // Remove nickname if empty\n    db.run(\n      'DELETE FROM friend_nicknames WHERE user_id = ? AND friend_id = ?',\n      [userId, friendId],\n      (err) => {\n        if (err) {\n          return res.status(500).json({ error: 'Failed to remove nickname' });\n        }\n        res.json({ success: true, message: 'Nickname removed' });\n      }\n    );\n  } else {\n    // Set or update nickname\n    db.run(\n      `INSERT INTO friend_nicknames (user_id, friend_id, nickname)\n       VALUES (?, ?, ?)\n       ON CONFLICT (user_id, friend_id) DO UPDATE SET nickname = ?, updated_at = CURRENT_TIMESTAMP`,\n      [userId, friendId, nickname.trim(), nickname.trim()],\n      (err) => {\n        if (err) {\n          return res.status(500).json({ error: 'Failed to set nickname' });\n        }\n        res.json({ success: true, message: 'Nickname set', nickname: nickname.trim() });\n      }\n    );\n  }\n});\n\n// Get nickname for a friend\nrouter.get('/:friendId/nickname', (req, res) => {\n  const userId = getUserIdFromToken(req);\n  const { friendId } = req.params;\n\n  if (!userId) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  db.get(\n    'SELECT nickname FROM friend_nicknames WHERE user_id = ? AND friend_id = ?',\n    [userId, friendId],\n    (err, row) => {\n      if (err) {\n        return res.status(500).json({ error: 'Failed to get nickname' });\n      }\n      res.json({ nickname: row?.nickname || null });\n    }\n  );\n});\n\n// Get all nicknames for current user\nrouter.get('/nicknames/all', (req, res) => {\n  const userId = getUserIdFromToken(req);\n\n  if (!userId) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  db.all(\n    'SELECT friend_id as friendId, nickname FROM friend_nicknames WHERE user_id = ?',\n    [userId],\n    (err, rows) => {\n      if (err) {\n        return res.status(500).json({ error: 'Failed to get nicknames' });\n      }\n      res.json(rows || []);\n    }\n  );\n});\n\n// Set invisible to specific friend\nrouter.post('/:friendId/invisible', (req, res) => {\n  const userId = getUserIdFromToken(req);\n  const { friendId } = req.params;\n  const { invisible } = req.body;\n\n  if (!userId) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  db.run(\n    `UPDATE friends SET invisible = ? WHERE \n    (user_id = ? AND friend_id = ?) OR \n    (user_id = ? AND friend_id = ?)`,\n    [invisible ? 1 : 0, userId, friendId, friendId, userId],\n    (err) => {\n      if (err) {\n        return res.status(500).json({ error: 'Failed to update visibility' });\n      }\n      res.json({ success: true, message: invisible ? 'Now invisible to this friend' : 'Now visible to this friend' });\n    }\n  );\n});\n\n// Ignore friend (hide from DM list but keep friendship)\nrouter.post('/:friendId/ignore', (req, res) => {\n  const userId = getUserIdFromToken(req);\n  const { friendId } = req.params;\n  const { ignored } = req.body;\n\n  if (!userId) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  db.run(\n    `UPDATE friends SET ignored = ? WHERE \n    (user_id = ? AND friend_id = ?) OR \n    (user_id = ? AND friend_id = ?)`,\n    [ignored ? 1 : 0, userId, friendId, friendId, userId],\n    (err) => {\n      if (err) {\n        return res.status(500).json({ error: 'Failed to update ignore status' });\n      }\n      res.json({ success: true, message: ignored ? 'Friend ignored' : 'Friend unignored' });\n    }\n  );\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":10168,"size_tokens":null},"backend/routes/admin.js":{"content":"const express = require('express');\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\nconst logger = require('../logger');\n\nconst router = express.Router();\nconst SECRET_KEY = 'real_user_auth_secret_2025';\n\n// Socket.io instance (set from server.js)\nlet io = null;\nrouter.setIo = (socketIo) => { io = socketIo; };\n\n// Helper to log moderation action to losers channel\nfunction logModerationAction(type, username, reason, duration, warningCount) {\n  let logContent = `User: ${username}\\n`;\n  logContent += `Reason: ${reason || 'No reason provided'}`;\n  \n  if (type === 'ban' && duration) {\n    logContent += `\\nHow long: ${duration}`;\n  } else if (type === 'warn' && warningCount) {\n    logContent += `\\nStrike: ${warningCount}/3`;\n  } else if (type === 'permaban') {\n    logContent += `\\nHow long: PERMANENT`;\n  }\n  \n  // Find the losers channel by name\n  db.get('SELECT id FROM channels WHERE server_id = 1 AND name = ?', ['losers'], (err, channel) => {\n    if (err || !channel) {\n      console.log('Losers channel not found');\n      return;\n    }\n    \n    const channelId = channel.id;\n    \n    // Insert log message as admin user (ID: 1)\n    db.run(\n      `INSERT INTO messages (channel_id, user_id, content) VALUES (?, ?, ?)`,\n      [channelId, 1, logContent],\n      function(err) {\n        if (!err && io) {\n          db.get(\n            `SELECT m.*, u.username, u.profile_picture FROM messages m JOIN users u ON m.user_id = u.id WHERE m.id = ?`,\n            [this.lastID],\n            (err, message) => {\n              if (message) {\n                message.channelId = channelId;\n                io.to(`channel-${channelId}`).emit('new_message', message);\n              }\n            }\n          );\n        }\n      }\n    );\n  });\n}\n\n// Middleware to check if user is admin\nconst isAdmin = (req, res, next) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  if (!token) {\n    return res.status(401).json({ error: 'No token provided' });\n  }\n\n  try {\n    const decoded = jwt.verify(token, SECRET_KEY);\n    \n    db.get('SELECT role FROM users WHERE id = ?', [decoded.userId], (err, user) => {\n      if (err || !user || user.role !== 'admin') {\n        return res.status(403).json({ error: 'Unauthorized: Admin access required' });\n      }\n      req.userId = decoded.userId;\n      next();\n    });\n  } catch (err) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n};\n\n// Check if current user is admin\nrouter.get('/check', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) {\n    return res.json({ isAdmin: false });\n  }\n\n  try {\n    const decoded = jwt.verify(token, SECRET_KEY);\n    db.get('SELECT role FROM users WHERE id = ?', [decoded.userId], (err, user) => {\n      res.json({ isAdmin: user && user.role === 'admin' });\n    });\n  } catch {\n    res.json({ isAdmin: false });\n  }\n});\n\n// Get pending server requests\nrouter.get('/server-requests', isAdmin, (req, res) => {\n  db.all(`\n    SELECT sr.*, u.username FROM server_requests sr\n    JOIN users u ON sr.user_id = u.id\n    WHERE sr.status = 'pending'\n  `, (err, requests) => {\n    res.json(requests || []);\n  });\n});\n\n// Approve server request\nrouter.post('/approve-server/:requestId', isAdmin, (req, res) => {\n  const { requestId } = req.params;\n\n  db.get('SELECT * FROM server_requests WHERE id = ?', [requestId], (err, request) => {\n    if (!request) {\n      return res.status(404).json({ error: 'Request not found' });\n    }\n\n    // Create server with needs_setup = 1 so owner can name their channels\n    db.run(`\n      INSERT INTO servers (name, owner_id, description, needs_setup)\n      VALUES (?, ?, ?, 1)\n    `, [request.server_name, request.user_id, request.description], function(err) {\n      if (err) {\n        return res.status(400).json({ error: 'Failed to create server' });\n      }\n\n      const serverId = this.lastID;\n      \n      // Add owner as member\n      db.run('INSERT INTO server_members (server_id, user_id) VALUES (?, ?) ON CONFLICT DO NOTHING', \n        [serverId, request.user_id], () => {});\n      \n      // Update request status\n      db.run('UPDATE server_requests SET status = ? WHERE id = ?', ['approved', requestId], (err) => {\n        if (err) {\n          return res.status(400).json({ error: 'Failed to update request' });\n        }\n        \n        // Notify the user via socket that their server was approved\n        if (io) {\n          io.emit('server_approved', { \n            userId: request.user_id, \n            serverId: serverId,\n            serverName: request.server_name\n          });\n        }\n        \n        res.json({ success: true, serverId });\n      });\n    });\n  });\n});\n\n// Deny server request\nrouter.post('/deny-server/:requestId', isAdmin, (req, res) => {\n  db.run('UPDATE server_requests SET status = ? WHERE id = ?', ['denied', req.params.requestId], () => {\n    res.json({ success: true });\n  });\n});\n\n// Helper to parse time strings like \"30 minutes\", \"1 hour\", \"2 days\"\nfunction parseTimeString(timeStr) {\n  if (!timeStr) return null;\n  \n  const match = timeStr.toLowerCase().match(/(\\d+)\\s*(minute|minutes|min|mins|hour|hours|hr|hrs|day|days)/);\n  if (!match) return null;\n  \n  const amount = parseInt(match[1]);\n  const unit = match[2];\n  \n  let milliseconds;\n  if (unit.startsWith('minute') || unit.startsWith('min')) {\n    milliseconds = amount * 60 * 1000;\n  } else if (unit.startsWith('hour') || unit.startsWith('hr')) {\n    milliseconds = amount * 60 * 60 * 1000;\n  } else if (unit.startsWith('day')) {\n    milliseconds = amount * 24 * 60 * 60 * 1000;\n  } else {\n    return null;\n  }\n  \n  return new Date(Date.now() + milliseconds);\n}\n\n// Get all users (with ban/warn info)\nrouter.get('/users', isAdmin, (req, res) => {\n  db.all(`SELECT id, username, profile_picture, role, is_online, is_banned, ban_reason, \n          warning_count, last_warning, ban_until, created_at FROM users`, \n    (err, users) => {\n      res.json(users || []);\n    });\n});\n\n// Ban user from chatting (time-based)\nrouter.post('/ban/:userId', isAdmin, (req, res) => {\n  const { userId } = req.params;\n  const { reason, duration } = req.body;\n  \n  // Can't ban yourself or other admins\n  db.get('SELECT role, username FROM users WHERE id = ?', [userId], (err, user) => {\n    if (!user) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    if (user.role === 'admin') {\n      return res.status(403).json({ error: 'Cannot ban an admin' });\n    }\n    \n    // Parse duration (e.g., \"30 minutes\", \"1 hour\", \"2 days\")\n    const banUntil = parseTimeString(duration);\n    if (!banUntil) {\n      return res.status(400).json({ error: 'Invalid duration. Use format like \"30 minutes\", \"1 hour\", or \"2 days\"' });\n    }\n    \n    db.run('UPDATE users SET ban_until = ?, ban_reason = ? WHERE id = ?', \n      [banUntil.toISOString(), reason || 'No reason provided', userId], (err) => {\n        if (err) {\n          return res.status(500).json({ error: 'Failed to ban user' });\n        }\n        \n        // Log to moderation logs\n        logModerationAction('ban', user.username, reason, duration);\n        \n        // Notify banned user via socket\n        if (io) {\n          io.emit('user_banned', { \n            userId: parseInt(userId), \n            banUntil: banUntil.toISOString(),\n            reason: reason || 'No reason provided',\n            duration: duration\n          });\n        }\n        \n        res.json({ \n          success: true, \n          message: `User banned from chatting until ${banUntil.toLocaleString()}`,\n          banUntil: banUntil.toISOString()\n        });\n      });\n  });\n});\n\n// Unban user (clear ban_until)\nrouter.post('/unban/:userId', isAdmin, (req, res) => {\n  db.run('UPDATE users SET ban_until = NULL, ban_reason = NULL WHERE id = ?', \n    [req.params.userId], (err) => {\n      if (err) {\n        return res.status(500).json({ error: 'Failed to unban user' });\n      }\n      res.json({ success: true, message: 'User unbanned successfully' });\n    });\n});\n\n// Warn user\nrouter.post('/warn/:userId', isAdmin, (req, res) => {\n  const { userId } = req.params;\n  const { reason } = req.body;\n  \n  db.get('SELECT role, username, warning_count FROM users WHERE id = ?', [userId], (err, user) => {\n    if (!user) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    if (user.role === 'admin') {\n      return res.status(403).json({ error: 'Cannot warn an admin' });\n    }\n    \n    const newWarningCount = (user.warning_count || 0) + 1;\n    const warningMsg = reason || 'You have been warned by an admin';\n    \n    db.run('UPDATE users SET warning_count = ?, last_warning = ? WHERE id = ?', \n      [newWarningCount, warningMsg, userId], (err) => {\n        if (err) {\n          return res.status(500).json({ error: 'Failed to warn user' });\n        }\n        \n        // Log to moderation logs\n        logModerationAction('warn', user.username, reason, null, newWarningCount);\n        \n        // Notify warned user via socket\n        if (io) {\n          io.emit('user_warned', { \n            userId: parseInt(userId), \n            warningCount: newWarningCount,\n            reason: warningMsg\n          });\n        }\n        \n        // Auto-permaban after 3 warnings\n        if (newWarningCount >= 3) {\n          db.run('UPDATE users SET is_banned = TRUE, ban_reason = ? WHERE id = ?', \n            ['Permanently banned: Too many warnings (3/3)', userId], () => {\n              // Log the auto-ban\n              logModerationAction('permaban', user.username, 'Automatic permanent ban - 3 warnings reached');\n              \n              // Notify about permaban\n              if (io) {\n                io.emit('user_permabanned', { \n                  userId: parseInt(userId), \n                  reason: 'Permanently banned: Too many warnings (3/3)'\n                });\n              }\n            });\n        }\n        \n        res.json({ \n          success: true, \n          warningCount: newWarningCount,\n          message: newWarningCount >= 3 ? 'User warned and permanently banned (3/3 warnings)' : 'User warned successfully'\n        });\n      });\n  });\n});\n\n// Clear warnings\nrouter.post('/clear-warnings/:userId', isAdmin, (req, res) => {\n  db.run('UPDATE users SET warning_count = 0, last_warning = NULL WHERE id = ?', \n    [req.params.userId], (err) => {\n      if (err) {\n        return res.status(500).json({ error: 'Failed to clear warnings' });\n      }\n      res.json({ success: true, message: 'Warnings cleared' });\n    });\n});\n\n// Remove user\nrouter.delete('/users/:userId', isAdmin, (req, res) => {\n  const { userId } = req.params;\n  \n  // Can't delete admins\n  db.get('SELECT role FROM users WHERE id = ?', [userId], (err, user) => {\n    if (user && user.role === 'admin') {\n      return res.status(403).json({ error: 'Cannot delete an admin' });\n    }\n    \n    db.run('DELETE FROM users WHERE id = ?', [userId], () => {\n      res.json({ success: true });\n    });\n  });\n});\n\n// Delete message (admin only)\nrouter.delete('/messages/:messageId', isAdmin, (req, res) => {\n  db.run('DELETE FROM messages WHERE id = ?', [req.params.messageId], () => {\n    res.json({ success: true });\n  });\n});\n\n// Get all active servers\nrouter.get('/servers', isAdmin, (req, res) => {\n  db.all(`\n    SELECT s.*, u.username as owner_name,\n      (SELECT COUNT(*) FROM channels WHERE server_id = s.id) as channel_count,\n      (SELECT COUNT(*) FROM server_members WHERE server_id = s.id) as member_count\n    FROM servers s\n    LEFT JOIN users u ON s.owner_id = u.id\n    ORDER BY s.created_at DESC\n  `, [], (err, servers) => {\n    if (err) {\n      return res.status(500).json({ error: 'Failed to load servers' });\n    }\n    res.json(servers || []);\n  });\n});\n\n// Delete a server\nrouter.delete('/servers/:serverId', isAdmin, (req, res) => {\n  const { serverId } = req.params;\n  \n  db.run('DELETE FROM channels WHERE server_id = ?', [serverId], () => {\n    db.run('DELETE FROM server_members WHERE server_id = ?', [serverId], () => {\n      db.run('DELETE FROM servers WHERE id = ?', [serverId], (err) => {\n        if (err) {\n          return res.status(500).json({ error: 'Failed to delete server' });\n        }\n        res.json({ success: true });\n      });\n    });\n  });\n});\n\n// Get dashboard metrics\nrouter.get('/metrics', isAdmin, (req, res) => {\n  const metrics = {};\n  \n  db.get('SELECT COUNT(*) as count FROM users', [], (err, row) => {\n    metrics.total_users = row?.count || 0;\n    \n    db.get('SELECT COUNT(*) as count FROM users WHERE is_online = true', [], (err, row) => {\n      metrics.online_users = row?.count || 0;\n      \n      db.get('SELECT COUNT(*) as count FROM messages', [], (err, row) => {\n        metrics.total_messages = row?.count || 0;\n        \n        db.get('SELECT COUNT(*) as count FROM servers', [], (err, row) => {\n          metrics.total_servers = row?.count || 0;\n          \n          db.get('SELECT COUNT(*) as count FROM server_requests WHERE status = ?', ['pending'], (err, row) => {\n            metrics.pending_requests = row?.count || 0;\n            res.json(metrics);\n          });\n        });\n      });\n    });\n  });\n});\n\n// Get alerts\nrouter.get('/alerts', isAdmin, (req, res) => {\n  const alerts = [];\n  \n  db.get('SELECT COUNT(*) as count FROM server_requests WHERE status = ?', ['pending'], (err, row) => {\n    if (row?.count > 0) {\n      alerts.push({\n        type: 'info',\n        title: 'Pending Server Requests',\n        description: `${row.count} server request(s) awaiting approval`,\n        created_at: new Date().toISOString()\n      });\n    }\n    \n    db.get('SELECT COUNT(*) as count FROM users WHERE warning_count >= 2', [], (err, row) => {\n      if (row?.count > 0) {\n        alerts.push({\n          type: 'warning',\n          title: 'Users at Risk',\n          description: `${row.count} user(s) have 2+ warnings`,\n          created_at: new Date().toISOString()\n        });\n      }\n      \n      res.json(alerts);\n    });\n  });\n});\n\n// Get all users with filters\nrouter.get('/users', isAdmin, (req, res) => {\n  const { search, role, status } = req.query;\n  let query = 'SELECT id, username, email, role, is_online, is_banned, created_at, last_seen, profile_picture FROM users WHERE 1=1';\n  const params = [];\n  \n  if (search) {\n    query += ' AND (username LIKE ? OR email LIKE ?)';\n    params.push(`%${search}%`, `%${search}%`);\n  }\n  if (role) {\n    query += ' AND role = ?';\n    params.push(role);\n  }\n  if (status === 'online') {\n    query += ' AND is_online = true';\n  } else if (status === 'offline') {\n    query += ' AND is_online = false';\n  } else if (status === 'banned') {\n    query += ' AND is_banned = true';\n  }\n  \n  query += ' ORDER BY created_at DESC LIMIT 100';\n  \n  db.all(query, params, (err, users) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(users || []);\n  });\n});\n\n// Get single user\nrouter.get('/users/:userId', isAdmin, (req, res) => {\n  db.get('SELECT * FROM users WHERE id = ?', [req.params.userId], (err, user) => {\n    if (err) return res.status(500).json({ error: err.message });\n    if (!user) return res.status(404).json({ error: 'User not found' });\n    res.json(user);\n  });\n});\n\n// Update user\nrouter.patch('/users/:userId', isAdmin, (req, res) => {\n  const { userId } = req.params;\n  const { username, role, email } = req.body;\n  \n  db.run('UPDATE users SET username = COALESCE(?, username), role = COALESCE(?, role), email = COALESCE(?, email) WHERE id = ?',\n    [username, role, email, userId], function(err) {\n      if (err) return res.status(500).json({ error: err.message });\n      \n      logAuditAction(req.userId, 'update_user', userId, `Updated user: role=${role}`);\n      res.json({ success: true });\n    });\n});\n\n// Get recent messages\nrouter.get('/messages', isAdmin, (req, res) => {\n  const limit = parseInt(req.query.limit) || 50;\n  \n  db.all(`\n    SELECT m.*, u.username, c.name as channel_name, g.name as group_name\n    FROM messages m\n    LEFT JOIN users u ON m.user_id = u.id\n    LEFT JOIN channels c ON m.channel_id = c.id\n    LEFT JOIN group_chats g ON m.group_chat_id = g.id\n    ORDER BY m.created_at DESC\n    LIMIT ?\n  `, [limit], (err, messages) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(messages || []);\n  });\n});\n\n// Get audit logs\nrouter.get('/audit-logs', isAdmin, (req, res) => {\n  const limit = parseInt(req.query.limit) || 100;\n  \n  db.all(`\n    SELECT al.*, \n           admin.username as admin_username,\n           target.username as target_username\n    FROM audit_logs al\n    LEFT JOIN users admin ON al.admin_id = admin.id\n    LEFT JOIN users target ON al.target_id = target.id\n    ORDER BY al.created_at DESC\n    LIMIT ?\n  `, [limit], (err, logs) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(logs || []);\n  });\n});\n\n// Get analytics\nrouter.get('/analytics', isAdmin, (req, res) => {\n  const analytics = {};\n  const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();\n  const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();\n  \n  db.get('SELECT COUNT(DISTINCT user_id) as count FROM messages WHERE created_at > ?', [oneDayAgo], (err, row) => {\n    analytics.daily_active = row?.count || 0;\n    \n    db.get('SELECT COUNT(DISTINCT user_id) as count FROM messages WHERE created_at > ?', [oneWeekAgo], (err, row) => {\n      analytics.weekly_active = row?.count || 0;\n      \n      db.get('SELECT COUNT(*) as count FROM messages WHERE created_at > ?', [oneDayAgo], (err, row) => {\n        analytics.avg_messages = row?.count || 0;\n        \n        db.get('SELECT SUM(games_played) as count FROM user_xp', [], (err, row) => {\n          analytics.games_played_today = row?.count || 0;\n          res.json(analytics);\n        });\n      });\n    });\n  });\n});\n\nfunction logAuditAction(adminId, action, targetId, details) {\n  db.run(`\n    INSERT INTO audit_logs (admin_id, action, target_id, details, created_at)\n    VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)\n  `, [adminId, action, targetId, details]);\n}\n\nmodule.exports = router;\n","path":null,"size_bytes":18032,"size_tokens":null},"backend/db.js":{"content":"const { Pool } = require('pg');\nconst bcrypt = require('bcryptjs');\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: process.env.DATABASE_URL?.includes('localhost') ? false : { rejectUnauthorized: false }\n});\n\nlet paramIndex = 0;\nfunction convertParams(sql, params) {\n  paramIndex = 0;\n  const converted = sql.replace(/\\?/g, () => `$${++paramIndex}`);\n  return converted;\n}\n\nconst db = {\n  run: function(sql, params, callback) {\n    if (typeof params === 'function') {\n      callback = params;\n      params = [];\n    }\n    let pgSql = convertParams(sql, params);\n    const isInsert = pgSql.trim().toUpperCase().startsWith('INSERT');\n    if (isInsert && !pgSql.toUpperCase().includes('RETURNING')) {\n      pgSql = pgSql.replace(/;?\\s*$/, '') + ' RETURNING id';\n    }\n    pool.query(pgSql, Array.isArray(params) ? params : [params])\n      .then(result => {\n        if (callback) callback.call({ lastID: result.rows[0]?.id, changes: result.rowCount }, null);\n      })\n      .catch(err => {\n        if (callback) callback(err);\n      });\n  },\n\n  get: function(sql, params, callback) {\n    if (typeof params === 'function') {\n      callback = params;\n      params = [];\n    }\n    const pgSql = convertParams(sql, params);\n    pool.query(pgSql, Array.isArray(params) ? params : [params])\n      .then(result => {\n        callback(null, result.rows[0] || null);\n      })\n      .catch(err => {\n        callback(err);\n      });\n  },\n\n  all: function(sql, params, callback) {\n    if (typeof params === 'function') {\n      callback = params;\n      params = [];\n    }\n    const pgSql = convertParams(sql, params);\n    pool.query(pgSql, Array.isArray(params) ? params : [params])\n      .then(result => {\n        callback(null, result.rows || []);\n      })\n      .catch(err => {\n        callback(err);\n      });\n  },\n\n  exec: function(sql, callback) {\n    pool.query(sql)\n      .then(() => {\n        if (callback) callback(null);\n      })\n      .catch(err => {\n        if (callback) callback(err);\n      });\n  }\n};\n\nasync function initDatabase() {\n  const client = await pool.connect();\n  try {\n    await client.query(`CREATE TABLE IF NOT EXISTS users (\n      id SERIAL PRIMARY KEY,\n      username TEXT UNIQUE NOT NULL,\n      password TEXT NOT NULL,\n      profile_picture TEXT,\n      role TEXT DEFAULT 'member',\n      status TEXT DEFAULT 'offline',\n      custom_status TEXT,\n      custom_status_expiry TIMESTAMP,\n      is_online BOOLEAN DEFAULT false,\n      is_banned BOOLEAN DEFAULT false,\n      ban_reason TEXT,\n      ban_until TIMESTAMP,\n      warning_count INTEGER DEFAULT 0,\n      last_warning TEXT,\n      coins INTEGER DEFAULT 1000,\n      last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS servers (\n      id SERIAL PRIMARY KEY,\n      name TEXT NOT NULL,\n      owner_id INTEGER NOT NULL,\n      icon TEXT,\n      description TEXT,\n      status TEXT DEFAULT 'active',\n      needs_setup BOOLEAN DEFAULT false,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS server_members (\n      id SERIAL PRIMARY KEY,\n      server_id INTEGER NOT NULL,\n      user_id INTEGER NOT NULL,\n      joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(server_id, user_id)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS channels (\n      id SERIAL PRIMARY KEY,\n      server_id INTEGER NOT NULL,\n      name TEXT NOT NULL,\n      description TEXT,\n      category_id INTEGER,\n      position INTEGER DEFAULT 0,\n      is_archived BOOLEAN DEFAULT false,\n      archived_at TIMESTAMP,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS messages (\n      id SERIAL PRIMARY KEY,\n      channel_id INTEGER,\n      group_chat_id INTEGER,\n      dm_partner_id INTEGER,\n      user_id INTEGER NOT NULL,\n      content TEXT NOT NULL,\n      is_global BOOLEAN DEFAULT false,\n      reply_to_id INTEGER,\n      edited_at TIMESTAMP,\n      is_edited BOOLEAN DEFAULT false,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS friends (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      friend_id INTEGER NOT NULL,\n      status TEXT DEFAULT 'pending',\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(user_id, friend_id)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS group_chats (\n      id SERIAL PRIMARY KEY,\n      name TEXT,\n      owner_id INTEGER,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS group_chat_members (\n      id SERIAL PRIMARY KEY,\n      group_chat_id INTEGER NOT NULL,\n      user_id INTEGER NOT NULL,\n      UNIQUE(group_chat_id, user_id)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS server_requests (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      server_name TEXT NOT NULL,\n      description TEXT,\n      status TEXT DEFAULT 'pending',\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS roles (\n      id SERIAL PRIMARY KEY,\n      name TEXT UNIQUE NOT NULL,\n      permissions TEXT,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS reports (\n      id SERIAL PRIMARY KEY,\n      report_type TEXT NOT NULL,\n      reported_user_id INTEGER,\n      message_id INTEGER,\n      server_id INTEGER,\n      reporter_id INTEGER NOT NULL,\n      reason TEXT NOT NULL,\n      status TEXT DEFAULT 'pending',\n      resolved_by INTEGER,\n      action_taken TEXT,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      resolved_at TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS message_filters (\n      id SERIAL PRIMARY KEY,\n      filter_type TEXT NOT NULL,\n      enabled BOOLEAN DEFAULT true,\n      filter_data TEXT,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS blocked_words (\n      id SERIAL PRIMARY KEY,\n      word TEXT UNIQUE NOT NULL,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS game_categories (\n      id SERIAL PRIMARY KEY,\n      name TEXT UNIQUE NOT NULL,\n      icon TEXT,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS games (\n      id SERIAL PRIMARY KEY,\n      title TEXT NOT NULL,\n      description TEXT,\n      category_id INTEGER,\n      url TEXT,\n      thumbnail TEXT,\n      play_count INTEGER DEFAULT 0,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS favorites (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      game_id INTEGER NOT NULL,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(user_id, game_id)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS badges (\n      id SERIAL PRIMARY KEY,\n      name TEXT UNIQUE NOT NULL,\n      icon TEXT,\n      description TEXT,\n      requirement_type TEXT,\n      requirement_value INTEGER,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS user_badges (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      badge_id INTEGER NOT NULL,\n      earned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(user_id, badge_id)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS message_reactions (\n      id SERIAL PRIMARY KEY,\n      message_id INTEGER NOT NULL,\n      user_id INTEGER NOT NULL,\n      emoji TEXT NOT NULL,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(message_id, user_id, emoji)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS pinned_messages (\n      id SERIAL PRIMARY KEY,\n      message_id INTEGER NOT NULL UNIQUE,\n      channel_id INTEGER,\n      group_chat_id INTEGER,\n      pinned_by INTEGER NOT NULL,\n      pinned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS server_roles (\n      id SERIAL PRIMARY KEY,\n      server_id INTEGER NOT NULL,\n      name TEXT NOT NULL,\n      color TEXT DEFAULT '#99AAB5',\n      permissions TEXT DEFAULT '{}',\n      position INTEGER DEFAULT 0,\n      hoist BOOLEAN DEFAULT false,\n      mentionable BOOLEAN DEFAULT false,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS server_member_roles (\n      id SERIAL PRIMARY KEY,\n      server_id INTEGER NOT NULL,\n      user_id INTEGER NOT NULL,\n      role_id INTEGER NOT NULL,\n      UNIQUE(server_id, user_id, role_id)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS server_invites (\n      id SERIAL PRIMARY KEY,\n      server_id INTEGER NOT NULL,\n      code TEXT UNIQUE NOT NULL,\n      created_by INTEGER NOT NULL,\n      uses INTEGER DEFAULT 0,\n      max_uses INTEGER DEFAULT 0,\n      expires_at TIMESTAMP,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS message_read_status (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      channel_id INTEGER,\n      group_chat_id INTEGER,\n      dm_partner_id INTEGER,\n      is_global BOOLEAN DEFAULT false,\n      last_read_message_id INTEGER DEFAULT 0,\n      last_read_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS attachments (\n      id SERIAL PRIMARY KEY,\n      message_id INTEGER NOT NULL,\n      filename TEXT NOT NULL,\n      original_name TEXT NOT NULL,\n      file_type TEXT,\n      file_size INTEGER,\n      url TEXT NOT NULL,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS user_blocks (\n      id SERIAL PRIMARY KEY,\n      blocker_id INTEGER NOT NULL,\n      blocked_id INTEGER NOT NULL,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(blocker_id, blocked_id)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS channel_categories (\n      id SERIAL PRIMARY KEY,\n      server_id INTEGER NOT NULL,\n      name TEXT NOT NULL,\n      position INTEGER DEFAULT 0,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS channel_permissions (\n      id SERIAL PRIMARY KEY,\n      channel_id INTEGER NOT NULL,\n      target_type TEXT NOT NULL,\n      target_id INTEGER NOT NULL,\n      permission TEXT NOT NULL,\n      value INTEGER DEFAULT 1,\n      UNIQUE(channel_id, target_type, target_id, permission)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS audit_log (\n      id SERIAL PRIMARY KEY,\n      server_id INTEGER,\n      action_type TEXT NOT NULL,\n      actor_id INTEGER NOT NULL,\n      target_type TEXT,\n      target_id INTEGER,\n      changes TEXT,\n      reason TEXT,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS audit_logs (\n      id SERIAL PRIMARY KEY,\n      admin_id INTEGER NOT NULL,\n      action TEXT NOT NULL,\n      target_id INTEGER,\n      details TEXT,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS shop_categories (\n      id SERIAL PRIMARY KEY,\n      name TEXT UNIQUE NOT NULL,\n      slug TEXT UNIQUE NOT NULL,\n      icon TEXT,\n      description TEXT,\n      position INTEGER DEFAULT 0,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS shop_items (\n      id SERIAL PRIMARY KEY,\n      category_id INTEGER NOT NULL,\n      name TEXT NOT NULL,\n      slug TEXT UNIQUE NOT NULL,\n      description TEXT,\n      price INTEGER NOT NULL DEFAULT 100,\n      rarity TEXT DEFAULT 'common',\n      item_type TEXT NOT NULL,\n      css_class TEXT,\n      css_vars TEXT,\n      asset_url TEXT,\n      metadata TEXT DEFAULT '{}',\n      is_animated BOOLEAN DEFAULT false,\n      is_available BOOLEAN DEFAULT true,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS user_purchases (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      item_id INTEGER NOT NULL,\n      price_paid INTEGER NOT NULL,\n      purchased_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(user_id, item_id)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS user_equipped (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      slot TEXT NOT NULL,\n      item_id INTEGER NOT NULL,\n      server_id INTEGER DEFAULT 0,\n      equipped_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(user_id, slot, server_id)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS coin_transactions (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      amount INTEGER NOT NULL,\n      balance_after INTEGER NOT NULL,\n      transaction_type TEXT NOT NULL,\n      description TEXT,\n      reference_id INTEGER,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS daily_rewards (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      reward_date DATE NOT NULL,\n      amount INTEGER NOT NULL,\n      streak INTEGER DEFAULT 1,\n      claimed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(user_id, reward_date)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS changelogs (\n      id SERIAL PRIMARY KEY,\n      version TEXT,\n      title TEXT NOT NULL,\n      content TEXT NOT NULL,\n      change_type TEXT DEFAULT 'feature',\n      author_id INTEGER,\n      is_published BOOLEAN DEFAULT true,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS user_shortcuts (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      action TEXT NOT NULL,\n      shortcut TEXT NOT NULL,\n      is_enabled BOOLEAN DEFAULT true,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(user_id, action)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS default_shortcuts (\n      id SERIAL PRIMARY KEY,\n      action TEXT UNIQUE NOT NULL,\n      shortcut TEXT NOT NULL,\n      description TEXT,\n      category TEXT DEFAULT 'general'\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS archived_chats (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      chat_type TEXT NOT NULL,\n      chat_id INTEGER NOT NULL,\n      archived_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(user_id, chat_type, chat_id)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS friend_notes (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      friend_id INTEGER NOT NULL,\n      note TEXT,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(user_id, friend_id)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS polls (\n      id SERIAL PRIMARY KEY,\n      channel_id INTEGER,\n      server_id INTEGER,\n      creator_id INTEGER NOT NULL,\n      question TEXT NOT NULL,\n      poll_type TEXT DEFAULT 'single',\n      is_anonymous BOOLEAN DEFAULT false,\n      expires_at TIMESTAMP,\n      is_closed BOOLEAN DEFAULT false,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS poll_options (\n      id SERIAL PRIMARY KEY,\n      poll_id INTEGER NOT NULL,\n      option_text TEXT NOT NULL,\n      position INTEGER DEFAULT 0\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS poll_votes (\n      id SERIAL PRIMARY KEY,\n      poll_id INTEGER NOT NULL,\n      option_id INTEGER NOT NULL,\n      user_id INTEGER NOT NULL,\n      voted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(poll_id, user_id, option_id)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS activity_log (\n      id SERIAL PRIMARY KEY,\n      category TEXT NOT NULL,\n      action TEXT NOT NULL,\n      details TEXT,\n      user_id INTEGER,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE INDEX IF NOT EXISTS idx_activity_log_category ON activity_log(category)`);\n    await client.query(`CREATE INDEX IF NOT EXISTS idx_activity_log_created ON activity_log(created_at DESC)`);\n\n    // Game ratings and reviews\n    await client.query(`CREATE TABLE IF NOT EXISTS game_ratings (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      game_name TEXT NOT NULL,\n      rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),\n      review TEXT,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(user_id, game_name)\n    )`);\n\n    await client.query(`CREATE INDEX IF NOT EXISTS idx_game_ratings_game ON game_ratings(game_name)`);\n\n    // User customization settings (wallpapers, banners, etc.)\n    await client.query(`CREATE TABLE IF NOT EXISTS user_customization (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL UNIQUE,\n      wallpaper_url TEXT,\n      wallpaper_type TEXT DEFAULT 'default',\n      profile_banner_url TEXT,\n      dashboard_layout TEXT DEFAULT '{}',\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS user_preferences (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL UNIQUE,\n      theme_mode TEXT DEFAULT 'manual',\n      auto_theme_schedule TEXT,\n      tab_cloak_enabled BOOLEAN DEFAULT false,\n      tab_cloak_title TEXT,\n      tab_cloak_favicon TEXT,\n      panic_key TEXT DEFAULT E'\\`',\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    // Game leaderboards for high scores\n    await client.query(`CREATE TABLE IF NOT EXISTS game_leaderboards (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      game_name TEXT NOT NULL,\n      score INTEGER NOT NULL,\n      play_time INTEGER DEFAULT 0,\n      achieved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(user_id, game_name)\n    )`);\n    await client.query(`CREATE INDEX IF NOT EXISTS idx_leaderboards_game ON game_leaderboards(game_name)`);\n    await client.query(`CREATE INDEX IF NOT EXISTS idx_leaderboards_score ON game_leaderboards(score DESC)`);\n\n    // Speedrun records\n    await client.query(`CREATE TABLE IF NOT EXISTS speedrun_records (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      game_name TEXT NOT NULL,\n      time_ms INTEGER NOT NULL,\n      category TEXT DEFAULT 'any%',\n      verified BOOLEAN DEFAULT false,\n      achieved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n    await client.query(`CREATE INDEX IF NOT EXISTS idx_speedruns_game ON speedrun_records(game_name)`);\n    await client.query(`CREATE INDEX IF NOT EXISTS idx_speedruns_time ON speedrun_records(time_ms ASC)`);\n\n    // Dashboard widgets configuration\n    await client.query(`CREATE TABLE IF NOT EXISTS user_widgets (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      widget_type TEXT NOT NULL,\n      widget_config TEXT DEFAULT '{}',\n      position_x INTEGER DEFAULT 0,\n      position_y INTEGER DEFAULT 0,\n      width INTEGER DEFAULT 1,\n      height INTEGER DEFAULT 1,\n      enabled BOOLEAN DEFAULT true,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n    await client.query(`CREATE INDEX IF NOT EXISTS idx_widgets_user ON user_widgets(user_id)`);\n\n    // Custom user themes\n    await client.query(`CREATE TABLE IF NOT EXISTS custom_themes (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      name TEXT NOT NULL,\n      theme_data TEXT NOT NULL,\n      is_public BOOLEAN DEFAULT false,\n      uses_count INTEGER DEFAULT 0,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(user_id, name)\n    )`);\n    await client.query(`CREATE INDEX IF NOT EXISTS idx_themes_public ON custom_themes(is_public) WHERE is_public = true`);\n\n    // Anonymous forums\n    await client.query(`CREATE TABLE IF NOT EXISTS forum_categories (\n      id SERIAL PRIMARY KEY,\n      name TEXT NOT NULL UNIQUE,\n      description TEXT,\n      icon TEXT DEFAULT 'ðŸ“',\n      color TEXT DEFAULT '#4cc9f0',\n      position INTEGER DEFAULT 0,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS forum_posts (\n      id SERIAL PRIMARY KEY,\n      category_id INTEGER NOT NULL,\n      title TEXT NOT NULL,\n      content TEXT NOT NULL,\n      anonymous_name TEXT DEFAULT 'Anonymous',\n      user_id INTEGER,\n      is_pinned BOOLEAN DEFAULT false,\n      is_locked BOOLEAN DEFAULT false,\n      views INTEGER DEFAULT 0,\n      upvotes INTEGER DEFAULT 0,\n      downvotes INTEGER DEFAULT 0,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n    await client.query(`CREATE INDEX IF NOT EXISTS idx_forum_posts_category ON forum_posts(category_id)`);\n    await client.query(`CREATE INDEX IF NOT EXISTS idx_forum_posts_created ON forum_posts(created_at DESC)`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS forum_replies (\n      id SERIAL PRIMARY KEY,\n      post_id INTEGER NOT NULL,\n      content TEXT NOT NULL,\n      anonymous_name TEXT DEFAULT 'Anonymous',\n      user_id INTEGER,\n      upvotes INTEGER DEFAULT 0,\n      downvotes INTEGER DEFAULT 0,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n    await client.query(`CREATE INDEX IF NOT EXISTS idx_forum_replies_post ON forum_replies(post_id)`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS forum_votes (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      post_id INTEGER,\n      reply_id INTEGER,\n      vote_type TEXT NOT NULL,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(user_id, post_id, reply_id)\n    )`);\n\n    await client.query(`CREATE TABLE IF NOT EXISTS bug_reports (\n      id SERIAL PRIMARY KEY,\n      user_id INTEGER NOT NULL,\n      category TEXT NOT NULL,\n      title TEXT NOT NULL,\n      description TEXT NOT NULL,\n      location TEXT,\n      status TEXT DEFAULT 'open',\n      priority TEXT DEFAULT 'normal',\n      admin_notes TEXT,\n      resolved_by INTEGER,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )`);\n    await client.query(`CREATE INDEX IF NOT EXISTS idx_bug_reports_status ON bug_reports(status)`);\n    await client.query(`CREATE INDEX IF NOT EXISTS idx_bug_reports_user ON bug_reports(user_id)`);\n\n    // Seed default forum categories\n    await client.query(`INSERT INTO forum_categories (name, description, icon, color, position) VALUES\n      ('General Discussion', 'Talk about anything school-related', 'ðŸ’¬', '#4cc9f0', 1),\n      ('Homework Help', 'Get help with your homework', 'ðŸ“š', '#f72585', 2),\n      ('Study Tips', 'Share your best study strategies', 'ðŸ§ ', '#7209b7', 3),\n      ('Game Requests', 'Request new games for the portal', 'ðŸŽ®', '#3a0ca3', 4),\n      ('Bug Reports', 'Report issues with the portal', 'ðŸ›', '#f77f00', 5),\n      ('Off Topic', 'Random discussions and fun', 'ðŸŽ­', '#06d6a0', 6)\n      ON CONFLICT (name) DO NOTHING`);\n\n    await client.query(`INSERT INTO roles (name, permissions) VALUES \n      ('admin', 'full_control'),\n      ('moderator', 'delete_message,mute_user,warn_user'),\n      ('member', 'normal_user'),\n      ('guest', 'read_only')\n      ON CONFLICT (name) DO NOTHING`);\n\n    await client.query(`INSERT INTO message_filters (filter_type, enabled, filter_data) VALUES\n      ('profanity', true, '{}'),\n      ('spam', true, '{}'),\n      ('dangerous_links', true, '{}'),\n      ('caps_spam', true, '{}')\n      ON CONFLICT DO NOTHING`);\n\n    await client.query(`INSERT INTO game_categories (name, icon) VALUES\n      ('Action', 'âš”ï¸'),\n      ('Racing', 'ðŸŽï¸'),\n      ('Puzzle', 'ðŸ§©'),\n      ('Retro', 'ðŸ‘¾'),\n      ('Sports', 'âš½'),\n      ('Brain Games', 'ðŸ§ '),\n      ('Sandbox', 'ðŸ—ï¸'),\n      ('School-Safe', 'ðŸ“š'),\n      ('Horror', 'ðŸ‘»'),\n      ('Featured', 'â­')\n      ON CONFLICT (name) DO NOTHING`);\n\n    await client.query(`INSERT INTO badges (name, icon, description, requirement_type, requirement_value) VALUES\n      ('Founder', 'â­', 'Early user of the platform', 'early_user', 0),\n      ('Gamer', 'ðŸŽ®', 'Played 50+ games', 'game_plays', 50),\n      ('Chatterbox', 'ðŸ’¬', 'Sent 1000+ messages', 'messages_sent', 1000),\n      ('Admin', 'ðŸ‘‘', 'Administrator role', 'role', 0),\n      ('Smartie', 'ðŸ§ ', 'Completed 20 Brain Games', 'brain_games', 20),\n      ('Helper', 'ðŸ§‘â€ðŸ«', 'Moderator or helpful reports', 'helper', 0)\n      ON CONFLICT (name) DO NOTHING`);\n\n    const adminPassword = bcrypt.hashSync('0000P', 10);\n    await client.query(`INSERT INTO users (id, username, password, role, coins) VALUES (1, 'admin', $1, 'admin', 1000) ON CONFLICT (username) DO NOTHING`, [adminPassword]);\n\n    const yusoffPassword = bcrypt.hashSync('1124', 10);\n    await client.query(`INSERT INTO users (id, username, password, role, coins) VALUES (2, 'Yusoff(ADMIN)', $1, 'admin', 1000) ON CONFLICT (username) DO NOTHING`, [yusoffPassword]);\n\n    await client.query(`SELECT setval('users_id_seq', (SELECT COALESCE(MAX(id), 1) FROM users))`);\n\n    await client.query(`INSERT INTO servers (id, name, owner_id, description) VALUES (1, 'Welcome', 1, 'Official Welcome server - Admin only messaging') ON CONFLICT DO NOTHING`);\n    await client.query(`SELECT setval('servers_id_seq', (SELECT COALESCE(MAX(id), 1) FROM servers))`);\n\n    const channelExists = await client.query(`SELECT id FROM channels WHERE server_id = 1 AND name = 'rules-and-guidelines'`);\n    if (channelExists.rows.length === 0) {\n      await client.query(`INSERT INTO channels (server_id, name, description) VALUES (1, 'rules-and-guidelines', 'Read the rules here')`);\n    }\n\n    const losersExists = await client.query(`SELECT id FROM channels WHERE server_id = 1 AND name = 'losers'`);\n    if (losersExists.rows.length === 0) {\n      await client.query(`INSERT INTO channels (server_id, name, description) VALUES (1, 'losers', 'The Wall of Shame - Bans and Warnings')`);\n    }\n\n    await client.query(`INSERT INTO shop_categories (name, slug, icon, description, position) VALUES\n      ('Themes', 'themes', 'ðŸŽ¨', 'Custom color themes for your chat', 1),\n      ('Profile Frames', 'frames', 'ðŸ–¼ï¸', 'Stylish borders for your avatar', 2),\n      ('Badges', 'badges', 'ðŸ…', 'Flair badges next to your name', 3),\n      ('Chat Bubbles', 'bubbles', 'ðŸ’¬', 'Customize how your messages look', 4),\n      ('Sound Packs', 'sounds', 'ðŸ”Š', 'Custom notification sounds', 5),\n      ('Animated Avatars', 'avatars', 'âœ¨', 'Pre-made animated profile pictures', 6),\n      ('Server Cosmetics', 'server', 'ðŸ ', 'Icons and banners for your servers', 7),\n      ('Status Effects', 'status', 'ðŸ”´', 'Custom status indicators', 8),\n      ('Bio Upgrades', 'bio', 'ðŸ“', 'Enhance your profile bio', 9),\n      ('Boosts', 'boosts', 'ðŸš€', 'Cosmetic boosts and effects', 10)\n      ON CONFLICT (slug) DO NOTHING`);\n\n    await client.query(`INSERT INTO shop_items (category_id, name, slug, description, price, rarity, item_type, css_class, css_vars, is_animated) VALUES\n      (1, 'Neon Galaxy', 'theme-neon-galaxy', 'A vibrant neon space theme', 500, 'rare', 'theme', 'theme-neon-galaxy', '{\"--bg\":\"#0a0a1a\",\"--bg-light\":\"#1a1a3a\",\"--primary\":\"#00ffff\",\"--secondary\":\"#ff00ff\",\"--text\":\"#ffffff\",\"--text-light\":\"#aaaaff\"}', false),\n      (1, 'Sakura Pink', 'theme-sakura-pink', 'Soft cherry blossom colors', 400, 'uncommon', 'theme', 'theme-sakura-pink', '{\"--bg\":\"#fff0f5\",\"--bg-light\":\"#ffe4ec\",\"--primary\":\"#ff69b4\",\"--secondary\":\"#ff1493\",\"--text\":\"#4a0025\",\"--text-light\":\"#8b4563\"}', false),\n      (1, 'Midnight Chrome', 'theme-midnight-chrome', 'Sleek dark chrome aesthetic', 600, 'rare', 'theme', 'theme-midnight-chrome', '{\"--bg\":\"#0f0f0f\",\"--bg-light\":\"#1f1f1f\",\"--primary\":\"#c0c0c0\",\"--secondary\":\"#808080\",\"--text\":\"#e0e0e0\",\"--text-light\":\"#a0a0a0\"}', false),\n      (1, 'Glitch Hacker', 'theme-glitch-hacker', 'Matrix-style hacker theme', 800, 'epic', 'theme', 'theme-glitch-hacker', '{\"--bg\":\"#000000\",\"--bg-light\":\"#001100\",\"--primary\":\"#00ff00\",\"--secondary\":\"#00aa00\",\"--text\":\"#00ff00\",\"--text-light\":\"#00cc00\"}', true),\n      (1, 'Sunset Pulse', 'theme-sunset-pulse', 'Warm sunset gradient vibes', 450, 'uncommon', 'theme', 'theme-sunset-pulse', '{\"--bg\":\"#1a0a0a\",\"--bg-light\":\"#2a1515\",\"--primary\":\"#ff6b35\",\"--secondary\":\"#f7931e\",\"--text\":\"#fff5f0\",\"--text-light\":\"#ffccbb\"}', false),\n      (1, 'Blueprint Tech', 'theme-blueprint-tech', 'Technical blueprint style', 550, 'rare', 'theme', 'theme-blueprint-tech', '{\"--bg\":\"#0a1628\",\"--bg-light\":\"#152238\",\"--primary\":\"#4fc3f7\",\"--secondary\":\"#29b6f6\",\"--text\":\"#e3f2fd\",\"--text-light\":\"#90caf9\"}', false)\n      ON CONFLICT (slug) DO NOTHING`);\n\n    await client.query(`INSERT INTO shop_items (category_id, name, slug, description, price, rarity, item_type, css_class, is_animated) VALUES\n      (2, 'Gold Trim', 'frame-gold-trim', 'Luxurious golden border', 300, 'uncommon', 'frame', 'frame-gold-trim', false),\n      (2, 'Pixel Frame', 'frame-pixel', 'Retro pixel art border', 250, 'common', 'frame', 'frame-pixel', false),\n      (2, 'Rainbow Wave', 'frame-rainbow-wave', 'Animated rainbow gradient', 700, 'epic', 'frame', 'frame-rainbow-wave', true),\n      (2, 'Carbon Fiber', 'frame-carbon-fiber', 'Sleek carbon fiber pattern', 350, 'uncommon', 'frame', 'frame-carbon-fiber', false),\n      (2, 'Fire Aura', 'frame-fire-aura', 'Blazing animated flames', 900, 'legendary', 'frame', 'frame-fire-aura', true),\n      (2, 'Frost Glow', 'frame-frost-glow', 'Icy crystalline glow', 650, 'rare', 'frame', 'frame-frost-glow', true)\n      ON CONFLICT (slug) DO NOTHING`);\n\n    await client.query(`INSERT INTO shop_items (category_id, name, slug, description, price, rarity, item_type, css_class, metadata) VALUES\n      (3, 'Verified Star', 'badge-verified', 'â­ Verified badge', 1000, 'legendary', 'badge', 'badge-verified', '{\"emoji\":\"â­\",\"label\":\"Verified\"}'),\n      (3, 'Dragon Rank', 'badge-dragon', 'ðŸ‰ Dragon rank badge', 800, 'epic', 'badge', 'badge-dragon', '{\"emoji\":\"ðŸ‰\",\"label\":\"Dragon\"}'),\n      (3, 'VIP Crown', 'badge-vip', 'ðŸ‘‘ VIP member badge', 1200, 'legendary', 'badge', 'badge-vip', '{\"emoji\":\"ðŸ‘‘\",\"label\":\"VIP\"}'),\n      (3, 'Speedrunner', 'badge-speedrunner', 'âš¡ Speedrunner badge', 400, 'rare', 'badge', 'badge-speedrunner', '{\"emoji\":\"âš¡\",\"label\":\"Speed\"}'),\n      (3, 'OG Member', 'badge-og', 'ðŸ”¥ Original member badge', 600, 'epic', 'badge', 'badge-og', '{\"emoji\":\"ðŸ”¥\",\"label\":\"OG\"}'),\n      (3, 'Prestige', 'badge-prestige', 'ðŸ’Ž Prestige badge', 1500, 'legendary', 'badge', 'badge-prestige', '{\"emoji\":\"ðŸ’Ž\",\"label\":\"Prestige\"}'),\n      (3, 'Brainiac', 'badge-brainiac', 'ðŸ§  Brainiac badge', 500, 'rare', 'badge', 'badge-brainiac', '{\"emoji\":\"ðŸ§ \",\"label\":\"Brainiac\"}'),\n      (3, 'Daily Champion', 'daily-special-badge', 'ðŸ† 8-day streak reward badge', 0, 'legendary', 'badge', 'badge-daily-champion', '{\"emoji\":\"ðŸ†\",\"label\":\"Champion\"}')\n      ON CONFLICT (slug) DO NOTHING`);\n\n    await client.query(`INSERT INTO shop_items (category_id, name, slug, description, price, rarity, item_type, css_class, is_animated) VALUES\n      (4, 'Rounded Neon', 'bubble-neon', 'Glowing neon chat bubbles', 350, 'uncommon', 'bubble', 'bubble-neon', true),\n      (4, 'Pixel Chat', 'bubble-pixel', 'Retro pixel-style bubbles', 300, 'common', 'bubble', 'bubble-pixel', false),\n      (4, 'Gradient Wave', 'bubble-gradient', 'Smooth gradient messages', 400, 'uncommon', 'bubble', 'bubble-gradient', false),\n      (4, 'iMessage Style', 'bubble-imessage', 'Clean iMessage look', 450, 'rare', 'bubble', 'bubble-imessage', false),\n      (4, 'Terminal Hacker', 'bubble-terminal', 'Matrix terminal style', 550, 'rare', 'bubble', 'bubble-terminal', false)\n      ON CONFLICT (slug) DO NOTHING`);\n\n    await client.query(`INSERT INTO default_shortcuts (action, shortcut, description, category) VALUES\n      ('open_chat', 'c', 'Open chat panel', 'navigation'),\n      ('open_games', 'g', 'Open games library', 'navigation'),\n      ('open_profile', 'p', 'Open your profile', 'navigation'),\n      ('focus_search', '/', 'Focus search bar', 'navigation'),\n      ('return_dashboard', 'Escape', 'Return to dashboard', 'navigation'),\n      ('open_shop', 's', 'Open the shop', 'navigation'),\n      ('toggle_sidebar', 'b', 'Toggle sidebar', 'ui'),\n      ('quick_switcher', 'ctrl+k', 'Open quick switcher', 'advanced'),\n      ('command_palette', 'ctrl+shift+p', 'Open command palette', 'advanced'),\n      ('new_message', 'n', 'Start new message', 'chat'),\n      ('mark_read', 'm', 'Mark all as read', 'chat'),\n      ('next_channel', 'alt+down', 'Next channel', 'chat'),\n      ('prev_channel', 'alt+up', 'Previous channel', 'chat')\n      ON CONFLICT (action) DO NOTHING`);\n\n    const existingChangelogs = await client.query('SELECT COUNT(*) FROM changelogs');\n    if (parseInt(existingChangelogs.rows[0].count) === 0) {\n      await client.query(`INSERT INTO changelogs (version, title, content, change_type, author_id) VALUES\n        ('1.0.0', 'Welcome to Enrichment Hub!', 'Initial release of our K-12 learning portal featuring chat system, educational games, and social features.', 'feature', 1),\n        ('1.1.0', 'Cosmetic Shop Added', 'New shop system with themes, profile frames, badges, chat bubbles, and more! Earn coins daily.', 'feature', 1),\n        ('1.1.1', 'Server Invite System', 'Create custom invite links with expiry options and usage limits. Preview servers before joining.', 'feature', 1)`);\n    }\n\n    console.log('PostgreSQL database initialized successfully');\n  } catch (err) {\n    console.error('Database initialization error:', err);\n  } finally {\n    client.release();\n  }\n}\n\ninitDatabase();\n\nmodule.exports = db;\n","path":null,"size_bytes":34026,"size_tokens":null},"backend/server.js":{"content":"const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cors = require('cors');\nconst compression = require('compression');\nconst path = require('path');\nconst multer = require('multer');\nconst { createBareServer } = require('@nebula-services/bare-server-node');\n\nconst db = require('./db');\nconst authRoutes = require('./routes/auth');\nconst usersRoutes = require('./routes/users');\nconst serverRoutes = require('./routes/servers');\nconst messageRoutes = require('./routes/messages');\nconst adminRoutes = require('./routes/admin');\nconst featuresRoutes = require('./routes/features');\nconst friendsRoutes = require('./routes/friends');\nconst blocksRoutes = require('./routes/blocks');\nconst reactionsRoutes = require('./routes/reactions');\nconst pinsRoutes = require('./routes/pins');\nconst invitesRoutes = require('./routes/invites');\nconst searchRoutes = require('./routes/search');\nconst rolesRoutes = require('./routes/roles');\nconst categoriesRoutes = require('./routes/categories');\nconst auditRoutes = require('./routes/audit');\nconst shopRoutes = require('./routes/shop');\nconst changelogsRoutes = require('./routes/changelogs');\nconst shortcutsRoutes = require('./routes/shortcuts');\nconst archiveRoutes = require('./routes/archive');\nconst notesRoutes = require('./routes/notes');\nconst pollsRoutes = require('./routes/polls');\nconst preferencesRoutes = require('./routes/preferences');\nconst proxyRoutes = require('./routes/proxy');\nconst bookmarksRoutes = require('./routes/bookmarks');\nconst permissionsRoutes = require('./routes/permissions');\nconst permissionsHelper = require('./permissions');\nconst xpRoutes = require('./routes/xp');\nconst activityRoutes = require('./routes/activity');\nconst activityLogRoutes = require('./routes/activity-log');\nconst tasksRoutes = require('./routes/tasks');\nconst announcementsRoutes = require('./routes/announcements');\nconst gamesRoutes = require('./routes/games');\nconst youtubeRoutes = require('./routes/youtube');\nconst customizationRoutes = require('./routes/customization');\nconst leaderboardsRoutes = require('./routes/leaderboards');\nconst speedrunsRoutes = require('./routes/speedruns');\nconst widgetsRoutes = require('./routes/widgets');\nconst themesRoutes = require('./routes/themes');\nconst forumsRoutes = require('./routes/forums');\nconst bugReportsRoutes = require('./routes/bug-reports');\nconst aiChatRoutes = require('./routes/ai-chat');\nconst logger = require('./logger');\n\nconst storage = multer.diskStorage({\n  destination: (req, file, cb) => cb(null, path.join(__dirname, '../frontend/uploads')),\n  filename: (req, file, cb) => cb(null, Date.now() + '-' + file.originalname.replace(/[^a-zA-Z0-9.-]/g, '_'))\n});\nconst upload = multer({ storage, limits: { fileSize: 10 * 1024 * 1024 } });\n\nconst app = express();\nconst bareServer = createBareServer('/bare/', {\n  logErrors: true,\n  localAddress: undefined,\n  maintainer: {\n    email: 'admin@example.com',\n    website: 'https://example.com'\n  }\n});\n\n// Add error handling for bare server\nbareServer.on('error', (error) => {\n  console.error('Bare server error:', error);\n});\n\nconst server = http.createServer((req, res) => {\n  if (bareServer.shouldRoute(req)) {\n    try {\n      bareServer.routeRequest(req, res);\n    } catch (err) {\n      console.error('Bare request error:', err);\n      res.writeHead(502, { 'Content-Type': 'application/json' });\n      res.end(JSON.stringify({ error: 'Proxy error', details: err.message }));\n    }\n  } else {\n    app(req, res);\n  }\n});\n\nserver.on('upgrade', (req, socket, head) => {\n  if (bareServer.shouldRoute(req)) {\n    bareServer.routeUpgrade(req, socket, head);\n  } else {\n    socket.end();\n  }\n});\n\nconst io = socketIo(server, {\n  cors: { origin: '*', methods: ['GET', 'POST'] },\n  pingInterval: 25000,\n  pingTimeout: 60000\n});\n\n// Pass io to admin routes for real-time notifications\nadminRoutes.setIo(io);\n\n// Middleware\napp.use(compression({ level: 6 }));\napp.use(cors({ origin: true, credentials: true }));\napp.use(require('cookie-parser')());\napp.use(express.json({ limit: '50mb' }));\napp.use(express.urlencoded({ limit: '50mb', extended: true }));\n\n// Service Worker headers - must come before static serving\napp.get('/uv/sw.js', (req, res) => {\n  res.setHeader('Content-Type', 'application/javascript');\n  res.setHeader('Service-Worker-Allowed', '/');\n  res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');\n  res.sendFile(path.join(__dirname, '../frontend/uv/sw.js'));\n});\n\n// Cache UV assets for 1 year (immutable) - speeds up proxy loading significantly\napp.use('/uv', (req, res, next) => {\n  res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');\n  next();\n}, express.static(path.join(__dirname, '../frontend/uv')));\n\n// Serve bare-mux worker and transport with caching\napp.use('/baremux', (req, res, next) => {\n  res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');\n  next();\n}, express.static(path.join(__dirname, '../node_modules/@mercuryworkshop/bare-mux/dist')));\n\napp.use('/bareasmodule', (req, res, next) => {\n  res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');\n  next();\n}, express.static(path.join(__dirname, '../node_modules/@mercuryworkshop/bare-as-module3/dist')));\n\nconst jwt = require('jsonwebtoken');\nconst JWT_SECRET = process.env.JWT_SECRET || 'real_user_auth_secret_2025';\n\n// Server-side authentication check for private pages\nfunction verifyPageAccess(req, res, next) {\n  // Only check HTTP-only cookie (no query params for security)\n  const token = req.cookies?.authToken;\n  \n  if (!token) {\n    // Store intended destination in a cookie (not visible in URL)\n    res.cookie('redirectAfterLogin', req.originalUrl, {\n      httpOnly: false, // Needs to be readable by client JS\n      sameSite: 'lax',\n      maxAge: 5 * 60 * 1000, // 5 minutes\n      path: '/'\n    });\n    return res.redirect('/auth');\n  }\n  \n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n    req.userId = decoded.userId;\n    next();\n  } catch (err) {\n    // Clear invalid cookie\n    res.clearCookie('authToken');\n    return res.redirect('/auth');\n  }\n}\n\n// Auth page - accessible without login\napp.get('/auth', (req, res) => {\n  res.sendFile(path.join(__dirname, '../frontend/private/auth.html'));\n});\n\n// Setup wizard - accessible without login\napp.get('/setup', (req, res) => {\n  res.sendFile(path.join(__dirname, '../frontend/private/setup.html'));\n});\n\n// Lock screen - accessible without login (checks localStorage)\napp.get('/lock', (req, res) => {\n  res.sendFile(path.join(__dirname, '../frontend/private/lock.html'));\n});\n\n// Fake login screen for stealth mode\napp.get('/classlink', (req, res) => {\n  res.sendFile(path.join(__dirname, '../frontend/private/fake-login.html'));\n});\n\n// Legacy auth routes\napp.get(['/private/auth', '/private/auth.html'], (req, res) => {\n  res.redirect('/auth');\n});\n\n// Page content endpoints for SPA - returns just the page content\nconst privatePages = ['dashboard', 'chat', 'games', 'proxy', 'settings', 'profile', 'admin', 'videos', 'music', 'apps', 'forums', 'shop', 'leaderboard', 'achievements', 'bugs', 'themes', 'changelog', 'tasks', 'browser', 'movies', 'stats', 'shortcuts', 'youtube', 'theme-creator', 'ai-chat'];\n\nprivatePages.forEach(page => {\n  app.get(`/pages/${page}`, verifyPageAccess, (req, res) => {\n    res.sendFile(path.join(__dirname, `../frontend/private/${page}.html`));\n  });\n});\n\n// Clean URL routes for private pages (without /private prefix)\nprivatePages.forEach(page => {\n  app.get(`/${page}`, verifyPageAccess, (req, res) => {\n    res.sendFile(path.join(__dirname, `../frontend/private/${page}.html`));\n  });\n});\n\n// Protect private static files\napp.use('/private', verifyPageAccess, express.static(path.join(__dirname, '../frontend/private')));\n\n// Serve public files and other static assets (CSS, JS, uploads, etc.)\napp.use(express.static(path.join(__dirname, '../frontend'), {\n  index: false // Don't auto-serve index.html\n}));\n\n// Root - Show public K-12 Learning Portal landing page\n// \"Access Portal\" buttons lead to the fake Staff Portal login at /classlink\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, '../frontend/public/index.html'));\n});\n\n// Logout endpoint - clears the auth cookie\napp.post('/api/auth/logout', (req, res) => {\n  res.clearCookie('authToken', { httpOnly: true, sameSite: 'lax', path: '/' });\n  res.json({ success: true });\n});\n\napp.get('/api/auth/logout', (req, res) => {\n  res.clearCookie('authToken', { httpOnly: true, sameSite: 'lax', path: '/' });\n  res.redirect('/auth');\n});\n\n// Routes - REAL user system (no token needed for signup/login)\napp.use('/api/users', usersRoutes);\n\n// Auth routes - NO middleware (users need to login first to get a token)\napp.use('/api/auth', authRoutes);\n\n// Auth middleware for protected API routes (checks both header and cookie)\nconst authMiddleware = (req, res, next) => {\n  const token = req.headers.authorization?.split(' ')[1] || req.cookies?.authToken;\n  if (!token) return res.status(401).json({ error: 'Unauthorized' });\n  \n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n    req.userId = decoded.userId;\n    req.user = decoded;\n    next();\n  } catch (err) {\n    return res.status(401).json({ error: 'Invalid or expired token' });\n  }\n};\n\n// Protected routes\napp.use('/api/servers', authMiddleware, serverRoutes);\napp.use('/api/messages', authMiddleware, messageRoutes);\napp.use('/api/admin', authMiddleware, adminRoutes);\napp.use('/api/features', authMiddleware, featuresRoutes);\napp.use('/api/friends', authMiddleware, friendsRoutes);\napp.use('/api/blocks', authMiddleware, blocksRoutes);\napp.use('/api/reactions', authMiddleware, reactionsRoutes);\napp.use('/api/pins', authMiddleware, pinsRoutes);\napp.use('/api/invites', authMiddleware, invitesRoutes);\napp.use('/api/search', authMiddleware, searchRoutes);\napp.use('/api/roles', authMiddleware, rolesRoutes);\napp.use('/api/categories', authMiddleware, categoriesRoutes);\napp.use('/api/audit', authMiddleware, auditRoutes);\napp.use('/api/shop', shopRoutes);\napp.use('/api/changelogs', changelogsRoutes);\napp.use('/api/shortcuts', shortcutsRoutes);\napp.use('/api/archive', archiveRoutes);\napp.use('/api/notes', notesRoutes);\napp.use('/api/polls', pollsRoutes);\napp.use('/api/preferences', preferencesRoutes);\napp.use('/api/proxy', proxyRoutes);\napp.use('/api/bookmarks', bookmarksRoutes);\napp.use('/api/permissions', permissionsRoutes);\napp.use('/api/xp', xpRoutes);\napp.use('/api/activity', activityRoutes);\napp.use('/api/activity-log', activityLogRoutes);\napp.use('/api/tasks', tasksRoutes);\napp.use('/api/announcements', announcementsRoutes);\napp.use('/api/games', gamesRoutes);\napp.use('/api/customization', customizationRoutes);\napp.use('/api/youtube', youtubeRoutes);\napp.use('/api/leaderboards', leaderboardsRoutes);\napp.use('/api/speedruns', speedrunsRoutes);\napp.use('/api/widgets', widgetsRoutes);\napp.use('/api/themes', themesRoutes);\napp.use('/api/forums', forumsRoutes);\napp.use('/api/bug-reports', bugReportsRoutes);\napp.use('/api/chat', authMiddleware, aiChatRoutes);\n\n// XOR encode/decode functions for proxy URLs\nfunction xorDecode(encoded) {\n  return encoded.split('').map((c, i) => i % 2 ? String.fromCharCode(c.charCodeAt(0) ^ 2) : c).join('');\n}\n\nfunction xorEncode(url) {\n  return url.split('').map((c, i) => i % 2 ? String.fromCharCode(c.charCodeAt(0) ^ 2) : c).join('');\n}\n\n// Robust proxy handler using native http/https modules for streaming\nconst proxyHttp = require('http');\nconst proxyHttps = require('https');\n\nfunction proxyRequest(targetUrl, req, res, prefix) {\n  const parsedUrl = new URL(targetUrl);\n  const protocol = parsedUrl.protocol === 'https:' ? proxyHttps : proxyHttp;\n  \n  const options = {\n    hostname: parsedUrl.hostname,\n    port: parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80),\n    path: parsedUrl.pathname + parsedUrl.search,\n    method: req.method,\n    headers: {\n      'Host': parsedUrl.host,\n      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',\n      'Accept-Language': 'en-US,en;q=0.9',\n      'Accept-Encoding': 'identity',\n      'Connection': 'keep-alive',\n      'Upgrade-Insecure-Requests': '1'\n    }\n  };\n\n  const proxyReq = protocol.request(options, (proxyRes) => {\n    // Handle redirects\n    if (proxyRes.statusCode >= 300 && proxyRes.statusCode < 400 && proxyRes.headers.location) {\n      let redirectUrl = proxyRes.headers.location;\n      if (!redirectUrl.startsWith('http')) {\n        redirectUrl = parsedUrl.origin + (redirectUrl.startsWith('/') ? '' : '/') + redirectUrl;\n      }\n      return proxyRequest(redirectUrl, req, res, prefix);\n    }\n\n    const contentType = proxyRes.headers['content-type'] || '';\n    \n    // Set response headers - strip security headers that block iframes\n    res.status(proxyRes.statusCode);\n    const blockedHeaders = [\n      'content-encoding', \n      'transfer-encoding', \n      'content-length', \n      'content-security-policy',\n      'content-security-policy-report-only',\n      'x-frame-options',\n      'x-content-type-options',\n      'strict-transport-security',\n      'cross-origin-opener-policy',\n      'cross-origin-embedder-policy',\n      'cross-origin-resource-policy',\n      'permissions-policy',\n      'document-policy',\n      'x-download-options'\n    ];\n    Object.keys(proxyRes.headers).forEach(key => {\n      if (!blockedHeaders.includes(key.toLowerCase())) {\n        res.setHeader(key, proxyRes.headers[key]);\n      }\n    });\n    // Add permissive headers\n    res.setHeader('Access-Control-Allow-Origin', '*');\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n    res.setHeader('Access-Control-Allow-Headers', '*');\n    \n    // For HTML, buffer and inject base tag + fetch interceptor\n    if (contentType.includes('text/html')) {\n      let chunks = [];\n      proxyRes.on('data', chunk => chunks.push(chunk));\n      proxyRes.on('end', () => {\n        let html = Buffer.concat(chunks).toString('utf-8');\n        \n        const currentOrigin = parsedUrl.origin;\n        \n        // XOR encode function for client-side\n        const xorEncodeJS = `function __xorEncode(u){return u.split('').map((c,i)=>i%2?String.fromCharCode(c.charCodeAt(0)^2):c).join('')}`;\n        \n        // Fetch/XHR interceptor script + frame-busting bypass\n        const interceptorScript = `\n<script>\n(function(){\n  // Frame-busting bypass - make the page think it's the top window\n  try {\n    Object.defineProperty(window, 'top', { get: function() { return window; } });\n    Object.defineProperty(window, 'parent', { get: function() { return window; } });\n    Object.defineProperty(window, 'frameElement', { get: function() { return null; } });\n  } catch(e) {}\n  \n  // Block common frame-busting patterns\n  window.onbeforeunload = null;\n  if (window.stop) window.stop = function(){};\n  \n  ${xorEncodeJS}\n  const BASE=\"${currentOrigin}\";\n  const PROXY_PREFIX=\"/service/\";\n  \n  function toProxyUrl(url){\n    try{\n      const u=new URL(url,BASE);\n      if(u.origin!==location.origin){\n        return PROXY_PREFIX+encodeURIComponent(__xorEncode(u.href));\n      }\n    }catch(e){}\n    return url;\n  }\n  \n  // Intercept fetch\n  const _fetch=window.fetch;\n  window.fetch=function(url,opts){\n    if(typeof url==='string'){\n      url=toProxyUrl(url);\n    }else if(url instanceof Request){\n      url=new Request(toProxyUrl(url.url),url);\n    }\n    return _fetch.call(this,url,opts);\n  };\n  \n  // Intercept XMLHttpRequest\n  const _open=XMLHttpRequest.prototype.open;\n  XMLHttpRequest.prototype.open=function(method,url){\n    arguments[1]=toProxyUrl(url);\n    return _open.apply(this,arguments);\n  };\n  \n  // Intercept WebSocket (basic)\n  const _WS=window.WebSocket;\n  window.WebSocket=function(url,protocols){\n    console.log('[Proxy] WebSocket blocked:',url);\n    return {send:()=>{},close:()=>{},addEventListener:()=>{}};\n  };\n})();\n</script>`;\n        \n        // Inject interceptor at the VERY START of the document (before any other scripts)\n        // This ensures our code runs first\n        const baseTag = `<base href=\"${currentOrigin}/\">`;\n        \n        // Inject at the absolute beginning, before <!DOCTYPE> if possible\n        if (html.toLowerCase().includes('<!doctype')) {\n          html = html.replace(/<!doctype[^>]*>/i, (match) => match + interceptorScript);\n          // Also inject base tag in head\n          if (html.includes('<head>')) {\n            html = html.replace('<head>', '<head>' + baseTag);\n          } else if (html.includes('<HEAD>')) {\n            html = html.replace('<HEAD>', '<HEAD>' + baseTag);\n          }\n        } else if (html.includes('<html')) {\n          html = html.replace(/<html[^>]*>/i, (match) => match + interceptorScript);\n          if (html.includes('<head>')) {\n            html = html.replace('<head>', '<head>' + baseTag);\n          } else if (html.includes('<HEAD>')) {\n            html = html.replace('<HEAD>', '<HEAD>' + baseTag);\n          }\n        } else if (html.includes('<head>')) {\n          html = html.replace('<head>', '<head>' + baseTag + interceptorScript);\n        } else if (html.includes('<HEAD>')) {\n          html = html.replace('<HEAD>', '<HEAD>' + baseTag + interceptorScript);\n        } else {\n          html = interceptorScript + baseTag + html;\n        }\n        \n        res.send(html);\n      });\n    } else {\n      // Stream non-HTML content directly\n      proxyRes.pipe(res);\n    }\n  });\n\n  proxyReq.on('error', (err) => {\n    console.error('Proxy request error:', err.message);\n    if (!res.headersSent) {\n      res.status(502).send('Proxy error: ' + err.message);\n    }\n  });\n\n  proxyReq.setTimeout(30000, () => {\n    proxyReq.destroy();\n    if (!res.headersSent) {\n      res.status(504).send('Proxy timeout');\n    }\n  });\n\n  proxyReq.end();\n}\n\nfunction handleProxyRequest(req, res, prefix) {\n  // Express strips mount path, so req.url starts with / + the encoded URL\n  const encodedPath = req.url.slice(1); // Remove leading /\n  if (!encodedPath) return res.status(400).send('No URL provided');\n  \n  try {\n    // The path may still be URL encoded, decode it first\n    const decoded = decodeURIComponent(encodedPath.split('?')[0]);\n    const decodedUrl = xorDecode(decoded);\n    \n    console.log('Proxy request - Encoded:', encodedPath.substring(0, 30), '-> Decoded:', decodedUrl.substring(0, 50));\n    \n    if (!decodedUrl.startsWith('http://') && !decodedUrl.startsWith('https://')) {\n      return res.status(400).send('Invalid URL: ' + decodedUrl.substring(0, 50));\n    }\n\n    proxyRequest(decodedUrl, req, res, prefix);\n  } catch (error) {\n    console.error('Proxy decode error:', error.message);\n    res.status(500).send('Proxy error: ' + error.message);\n  }\n}\n\n\n// File upload endpoint\napp.post('/api/upload', authMiddleware, upload.single('file'), (req, res) => {\n  if (!req.file) return res.status(400).json({ error: 'No file uploaded' });\n  res.json({ \n    success: true, \n    filename: req.file.filename,\n    originalName: req.file.originalname,\n    url: `/uploads/${req.file.filename}`,\n    size: req.file.size,\n    type: req.file.mimetype\n  });\n});\n\n// Cover login page\napp.get('/login', (req, res) => {\n  res.sendFile(path.join(__dirname, '../frontend/login.html'));\n});\n\n// Private directory - redirect to dashboard (cover login should be checked client-side)\napp.get('/private', (req, res) => {\n  res.redirect('/private/dashboard.html');\n});\n\napp.get('/private/', (req, res) => {\n  res.redirect('/private/dashboard.html');\n});\n\n// Socket.io events for real-time communication\nconst userSockets = {};\nconst typingUsers = {};\n\nio.on('connection', (socket) => {\n  console.log('[SOCKET] User connected:', socket.id, new Date().toISOString());\n\n  // User joins\n  socket.on('user_join', (data) => {\n    userSockets[data.userId] = socket.id;\n    socket.userId = data.userId;\n    socket.join('global-chat');\n    db.run('UPDATE users SET is_online = TRUE WHERE id = ?', [data.userId], (err) => {\n      if (!err) {\n        io.emit('user_online', { userId: data.userId });\n      }\n    });\n  });\n\n  // Enhanced typing indicator - supports all chat types\n  socket.on('user_typing', (data) => {\n    const { channelId, groupChatId, dmPartnerId, isGlobal, userId, username } = data;\n    const key = channelId ? `channel-${channelId}` : \n                groupChatId ? `group-${groupChatId}` :\n                dmPartnerId ? `dm-${Math.min(userId, dmPartnerId)}-${Math.max(userId, dmPartnerId)}` :\n                isGlobal ? 'global-chat' : null;\n    \n    if (!typingUsers[key]) typingUsers[key] = {};\n    typingUsers[key][userId] = { username, timestamp: Date.now() };\n    \n    if (key) socket.to(key).emit('user_typing', { userId, username, chatKey: key });\n  });\n\n  socket.on('user_stop_typing', (data) => {\n    const { channelId, groupChatId, dmPartnerId, isGlobal, userId } = data;\n    const key = channelId ? `channel-${channelId}` : \n                groupChatId ? `group-${groupChatId}` :\n                dmPartnerId ? `dm-${Math.min(userId, dmPartnerId)}-${Math.max(userId, dmPartnerId)}` :\n                isGlobal ? 'global-chat' : null;\n    \n    if (typingUsers[key]) delete typingUsers[key][userId];\n    if (key) socket.to(key).emit('user_stop_typing', { userId, chatKey: key });\n  });\n\n  // Reaction events\n  socket.on('add_reaction', (data) => {\n    const { messageId, emoji, userId, username } = data;\n    io.emit('reaction_added', { messageId, emoji, userId, username });\n  });\n\n  socket.on('remove_reaction', (data) => {\n    const { messageId, emoji, userId } = data;\n    io.emit('reaction_removed', { messageId, emoji, userId });\n  });\n\n  // Message edit event\n  socket.on('edit_message', (data) => {\n    const { messageId, newContent, userId } = data;\n    db.get('SELECT user_id FROM messages WHERE id = ?', [messageId], (err, msg) => {\n      if (msg && msg.user_id === userId) {\n        db.run('UPDATE messages SET content = ?, is_edited = 1, edited_at = CURRENT_TIMESTAMP WHERE id = ?',\n          [newContent, messageId], (err) => {\n            if (!err) {\n              io.emit('message_edited', { messageId, newContent, editedAt: new Date().toISOString() });\n            }\n          });\n      }\n    });\n  });\n\n  // Mark messages as read\n  socket.on('mark_read', (data) => {\n    const { userId, channelId, groupChatId, dmPartnerId, isGlobal, lastMessageId } = data;\n    db.run(`\n      INSERT INTO message_read_status \n      (user_id, channel_id, group_chat_id, dm_partner_id, is_global, last_read_message_id, last_read_at)\n      VALUES (?, COALESCE(?, 0), COALESCE(?, 0), COALESCE(?, 0), ?, ?, CURRENT_TIMESTAMP)\n      ON CONFLICT (user_id, channel_id, group_chat_id, dm_partner_id, is_global) DO UPDATE SET\n        last_read_message_id = excluded.last_read_message_id,\n        last_read_at = CURRENT_TIMESTAMP\n    `, [userId, channelId || 0, groupChatId || 0, dmPartnerId || 0, isGlobal ? 1 : 0, lastMessageId]);\n  });\n\n  // Join channel room\n  socket.on('join_channel', async (data) => {\n    const { channelId, userId } = data;\n    \n    if (!channelId) {\n      socket.emit('channel_error', { error: 'Channel ID required' });\n      return;\n    }\n    \n    try {\n      const channel = await new Promise((resolve, reject) => {\n        db.get('SELECT server_id FROM channels WHERE id = ?', [channelId], (err, ch) => {\n          if (err) reject(err);\n          else resolve(ch);\n        });\n      });\n      \n      if (!channel) {\n        socket.emit('channel_error', { error: 'Channel not found' });\n        return;\n      }\n      \n      const canView = await permissionsHelper.canViewChannel(channel.server_id, channelId, userId || socket.userId);\n      if (!canView) {\n        socket.emit('channel_error', { error: 'You do not have permission to view this channel' });\n        return;\n      }\n      \n      socket.join(`channel-${channelId}`);\n    } catch (err) {\n      console.error('Join channel error:', err);\n      socket.join(`channel-${channelId}`);\n    }\n  });\n\n  // Leave channel room\n  socket.on('leave_channel', (data) => {\n    socket.leave(`channel-${data.channelId}`);\n  });\n\n  // Send message (channel, group chat, DM, or global) with reply and attachment support\n  socket.on('send_message', (data) => {\n    console.log('[DEBUG] send_message received:', JSON.stringify(data));\n    const { channelId, groupChatId, dmPartnerId, userId, content, isGlobal, replyToId, attachment } = data;\n    \n    // First check if user is banned from chatting\n    db.get('SELECT role, ban_until FROM users WHERE id = ?', [userId], (err, user) => {\n      if (err || !user) {\n        socket.emit('message_error', { error: 'User not found' });\n        return;\n      }\n      \n      // Check if user is currently banned (ban_until is in the future)\n      if (user.ban_until) {\n        const banUntil = new Date(user.ban_until);\n        if (banUntil > new Date()) {\n          socket.emit('message_error', { \n            error: 'You are banned from chatting',\n            banUntil: user.ban_until\n          });\n          return;\n        }\n      }\n      \n      // Check if trying to message in a channel\n      if (channelId) {\n        db.get('SELECT server_id FROM channels WHERE id = ?', [channelId], async (err, channel) => {\n          if (!channel) {\n            socket.emit('message_error', { error: 'Channel not found' });\n            return;\n          }\n          \n          // Welcome server (ID: 1) - admin only\n          if (channel.server_id === 1 && user.role !== 'admin') {\n            socket.emit('message_error', { error: 'Only admins can send messages in this server' });\n            return;\n          }\n          \n          // Check permission to send messages in channel\n          try {\n            const canSend = await permissionsHelper.canSendMessages(channel.server_id, channelId, userId);\n            if (!canSend) {\n              socket.emit('message_error', { error: 'You do not have permission to send messages in this channel' });\n              return;\n            }\n            // Proceed with sending message\n            sendMessageToDb(channelId, groupChatId, dmPartnerId, userId, content, isGlobal, socket, replyToId, attachment);\n          } catch (permErr) {\n            console.error('Permission check error:', permErr);\n            socket.emit('message_error', { error: 'Failed to check permissions' });\n          }\n        });\n      } else {\n        // Not a channel message, proceed\n        sendMessageToDb(channelId, groupChatId, dmPartnerId, userId, content, isGlobal, socket, replyToId, attachment);\n      }\n    });\n  });\n  \n  // Helper function to send message to database\n  function sendMessageToDb(channelId, groupChatId, dmPartnerId, userId, content, isGlobal, socket, replyToId, attachment) {\n    // Check for blocks on DMs\n    if (dmPartnerId) {\n      db.get('SELECT id FROM user_blocks WHERE (blocker_id = ? AND blocked_id = ?) OR (blocker_id = ? AND blocked_id = ?)',\n        [userId, dmPartnerId, dmPartnerId, userId], (err, block) => {\n          if (block) {\n            socket.emit('message_error', { error: 'Cannot send message to this user' });\n            return;\n          }\n          insertMessage(channelId, groupChatId, dmPartnerId, userId, content, isGlobal, socket, replyToId, attachment);\n        });\n    } else {\n      insertMessage(channelId, groupChatId, dmPartnerId, userId, content, isGlobal, socket, replyToId, attachment);\n    }\n  }\n  \n  function insertMessage(channelId, groupChatId, dmPartnerId, userId, content, isGlobal, socket, replyToId, attachment) {\n    let query, params;\n    if (isGlobal) {\n      query = `INSERT INTO messages (user_id, content, is_global, reply_to_id) VALUES (?, ?, TRUE, ?)`;\n      params = [userId, content, replyToId || null];\n    } else if (dmPartnerId) {\n      query = `INSERT INTO messages (channel_id, group_chat_id, dm_partner_id, user_id, content, reply_to_id)\n               VALUES (?, ?, ?, ?, ?, ?)`;\n      params = [null, null, dmPartnerId, userId, content, replyToId || null];\n    } else {\n      query = `INSERT INTO messages (channel_id, group_chat_id, user_id, content, reply_to_id)\n               VALUES (?, ?, ?, ?, ?)`;\n      params = [channelId || null, groupChatId || null, userId, content, replyToId || null];\n    }\n    \n    db.run(query, params, function(err) {\n      if (err) {\n        console.error('Message insert error:', err);\n        return;\n      }\n      const messageId = this.lastID;\n      \n      if (attachment) {\n        db.run(`INSERT INTO attachments (message_id, filename, original_name, file_type, file_size, url) \n                VALUES (?, ?, ?, ?, ?, ?)`,\n          [messageId, attachment.filename, attachment.originalName, attachment.type, attachment.size, attachment.url]);\n      }\n      \n      db.get(\n        `SELECT m.*, u.username, u.profile_picture,\n                rm.content as reply_content, ru.username as reply_username\n         FROM messages m \n         JOIN users u ON m.user_id = u.id \n         LEFT JOIN messages rm ON m.reply_to_id = rm.id\n         LEFT JOIN users ru ON rm.user_id = ru.id\n         WHERE m.id = ?`,\n        [messageId],\n        (err, message) => {\n          if (!err && message) {\n            if (attachment) {\n              message.attachment = attachment;\n            }\n            \n            if (message.reply_to_id) {\n              message.replyTo = {\n                id: message.reply_to_id,\n                content: message.reply_content,\n                username: message.reply_username\n              };\n            }\n            \n            if (isGlobal) {\n              message.isGlobal = true;\n              message.createdAt = new Date(message.created_at).toISOString();\n              io.to('global-chat').emit('new_message', message);\n            } else if (channelId) {\n              message.channelId = channelId;\n              io.to(`channel-${channelId}`).emit('new_message', message);\n            } else if (groupChatId) {\n              message.groupChatId = groupChatId;\n              io.to(`group-${groupChatId}`).emit('new_message', message);\n            } else if (dmPartnerId) {\n              message.dmPartnerId = dmPartnerId;\n              message.createdAt = new Date(message.created_at).toISOString();\n              const roomId = `dm-${Math.min(userId, dmPartnerId)}-${Math.max(userId, dmPartnerId)}`;\n              io.to(roomId).emit('new_message', message);\n            }\n            \n            // Check for @mentions and notify\n            const mentions = content.match(/@(\\w+)/g);\n            if (mentions) {\n              mentions.forEach(mention => {\n                const mentionedUsername = mention.slice(1);\n                db.get('SELECT id FROM users WHERE username = ?', [mentionedUsername], (err, mentionedUser) => {\n                  if (mentionedUser && userSockets[mentionedUser.id]) {\n                    io.to(userSockets[mentionedUser.id]).emit('mention_notification', {\n                      messageId,\n                      fromUsername: message.username,\n                      content: content.substring(0, 100),\n                      channelId,\n                      groupChatId,\n                      dmPartnerId,\n                      isGlobal\n                    });\n                  }\n                });\n              });\n            }\n          }\n        }\n      );\n    });\n  }\n\n  // Join DM room (use consistent naming to avoid duplicates)\n  socket.on('join_dm', (data) => {\n    const { userId, dmPartnerId } = data;\n    const roomId = `dm-${Math.min(userId, dmPartnerId)}-${Math.max(userId, dmPartnerId)}`;\n    socket.join(roomId);\n  });\n\n  // Join group chat room\n  socket.on('join_group', (data) => {\n    socket.join(`group-${data.groupChatId}`);\n  });\n\n  // Delete message\n  socket.on('delete_message', async (data) => {\n    const { messageId, userId, isAdmin } = data;\n    \n    db.get('SELECT m.user_id, m.channel_id, c.server_id FROM messages m LEFT JOIN channels c ON m.channel_id = c.id WHERE m.id = ?', [messageId], async (err, msg) => {\n      if (!msg) return;\n      \n      // User can always delete their own messages\n      if (msg.user_id === userId) {\n        db.run('DELETE FROM messages WHERE id = ?', [messageId], () => {\n          io.emit('message_deleted', { messageId });\n        });\n        return;\n      }\n      \n      // For channel messages, check DELETE_MESSAGES permission\n      if (msg.channel_id && msg.server_id) {\n        try {\n          const canDelete = await permissionsHelper.canDeleteMessages(msg.server_id, msg.channel_id, userId);\n          if (canDelete || isAdmin) {\n            db.run('DELETE FROM messages WHERE id = ?', [messageId], () => {\n              io.emit('message_deleted', { messageId });\n            });\n          }\n        } catch (permErr) {\n          console.error('Permission check error:', permErr);\n        }\n      } else if (isAdmin) {\n        // For non-channel messages, only admin can delete\n        db.run('DELETE FROM messages WHERE id = ?', [messageId], () => {\n          io.emit('message_deleted', { messageId });\n        });\n      }\n    });\n  });\n\n  // User disconnect\n  socket.on('disconnect', () => {\n    for (let userId in userSockets) {\n      if (userSockets[userId] === socket.id) {\n        db.run('UPDATE users SET is_online = FALSE WHERE id = ?', [userId], (err) => {\n          if (!err) {\n            io.emit('user_offline', { userId });\n          }\n        });\n        delete userSockets[userId];\n        break;\n      }\n    }\n  });\n});\n\nconst PORT = process.env.PORT || 5000;\nserver.listen(PORT, '0.0.0.0', () => {\n  console.log(`Chat server running on http://0.0.0.0:${PORT}`);\n});\n","path":null,"size_bytes":33717,"size_tokens":null},"frontend/js/themes.js":{"content":"// ======================================\n// ENHANCED THEME MANAGEMENT - 36 THEMES\n// ======================================\n\nconst THEMES = {\n  nebulacore: { name: 'NebulaCore', category: 'Sci-Fi', icon: 'ðŸŒŒ' },\n  ocean: { name: 'Deep Ocean', category: 'Nature', icon: 'ðŸŒŠ' },\n  arcade: { name: 'Neon Arcade', category: 'Gaming', icon: 'ðŸ•¹ï¸' },\n  candy: { name: 'Cotton Candy', category: 'Light', icon: 'ðŸ­' },\n  eclipse: { name: 'Solar Eclipse', category: 'Dark', icon: 'ðŸŒ‘' },\n  matrix: { name: 'Cyber Matrix', category: 'Sci-Fi', icon: 'ðŸ’»' },\n  notebook: { name: 'School Notebook', category: 'Light', icon: 'ðŸ““' },\n  gaming: { name: 'Midnight Gaming', category: 'Gaming', icon: 'ðŸŽ®' },\n  pixel: { name: 'Retro Pixel', category: 'Retro', icon: 'ðŸ‘¾' },\n  cloudy: { name: 'Cloudy Day', category: 'Light', icon: 'â˜ï¸' },\n  academia: { name: 'Royal Academia', category: 'Classic', icon: 'ðŸ“š' },\n  aurora: { name: 'Aurora Borealis', category: 'Nature', icon: 'ðŸŒˆ' },\n  cherry: { name: 'Cherry Blossom', category: 'Nature', icon: 'ðŸŒ¸' },\n  volcanic: { name: 'Volcanic', category: 'Dark', icon: 'ðŸŒ‹' },\n  forest: { name: 'Forest Depths', category: 'Nature', icon: 'ðŸŒ²' },\n  cyberpunk: { name: 'Cyberpunk', category: 'Sci-Fi', icon: 'ðŸ¤–' },\n  sunset: { name: 'Sunset Vibes', category: 'Warm', icon: 'ðŸŒ…' },\n  arctic: { name: 'Arctic Ice', category: 'Cool', icon: 'â„ï¸' },\n  grape: { name: 'Grape Soda', category: 'Fun', icon: 'ðŸ‡' },\n  coffee: { name: 'Coffee House', category: 'Classic', icon: 'â˜•' },\n  midnight: { name: 'Midnight Purple', category: 'Dark', icon: 'ðŸ”®' },\n  tokyo: { name: 'Neon Tokyo', category: 'Sci-Fi', icon: 'ðŸ—¼' },\n  emerald: { name: 'Emerald City', category: 'Nature', icon: 'ðŸ’Ž' },\n  bloodmoon: { name: 'Blood Moon', category: 'Dark', icon: 'ðŸ©¸' },\n  cottonblue: { name: 'Cotton Blue', category: 'Light', icon: 'ðŸ©µ' },\n  steampunk: { name: 'Steampunk', category: 'Retro', icon: 'âš™ï¸' },\n  lavender: { name: 'Lavender Dream', category: 'Light', icon: 'ðŸ’œ' },\n  spacegray: { name: 'Space Gray', category: 'Minimal', icon: 'ðŸŒ‘' },\n  mint: { name: 'Mint Fresh', category: 'Light', icon: 'ðŸƒ' },\n  darkrose: { name: 'Dark Rose', category: 'Dark', icon: 'ðŸŒ¹' },\n  electric: { name: 'Electric Blue', category: 'Neon', icon: 'âš¡' },\n  golden: { name: 'Golden Hour', category: 'Warm', icon: 'âœ¨' },\n  synthwave: { name: 'Synthwave', category: 'Retro', icon: 'ðŸŽµ' },\n  breeze: { name: 'Ocean Breeze', category: 'Light', icon: 'ðŸŒ´' },\n  mono: { name: 'Dark Mono', category: 'Minimal', icon: 'â¬›' },\n  jungle: { name: 'Neon Jungle', category: 'Nature', icon: 'ðŸŒ¿' }\n};\n\nconst THEME_CATEGORIES = [\n  { id: 'all', name: 'All Themes', icon: 'ðŸŽ¨' },\n  { id: 'Sci-Fi', name: 'Sci-Fi', icon: 'ðŸš€' },\n  { id: 'Gaming', name: 'Gaming', icon: 'ðŸŽ®' },\n  { id: 'Nature', name: 'Nature', icon: 'ðŸŒ¿' },\n  { id: 'Dark', name: 'Dark', icon: 'ðŸŒ™' },\n  { id: 'Light', name: 'Light', icon: 'â˜€ï¸' },\n  { id: 'Neon', name: 'Neon', icon: 'ðŸ’¡' },\n  { id: 'Retro', name: 'Retro', icon: 'ðŸ“º' },\n  { id: 'Warm', name: 'Warm', icon: 'ðŸ”¥' },\n  { id: 'Cool', name: 'Cool', icon: 'â„ï¸' },\n  { id: 'Classic', name: 'Classic', icon: 'ðŸ“–' },\n  { id: 'Minimal', name: 'Minimal', icon: 'â¬œ' },\n  { id: 'Fun', name: 'Fun', icon: 'ðŸŽ‰' }\n];\n\n// Initialize theme on page load\nfunction initTheme() {\n  // Check for custom theme first\n  const customTheme = localStorage.getItem('customTheme');\n  if (customTheme) {\n    try {\n      applyCustomTheme(JSON.parse(customTheme));\n      createStarField();\n      return;\n    } catch (e) {\n      console.error('Failed to parse custom theme:', e);\n    }\n  }\n  \n  const saved = localStorage.getItem('theme') || 'nebulacore';\n  applyTheme(saved);\n  updateThemeSelector(saved);\n  createStarField();\n}\n\n// Apply a custom theme from theme creator\nfunction applyCustomTheme(themeData) {\n  if (!themeData || !themeData.colors) return;\n  \n  const colors = themeData.colors;\n  const root = document.documentElement;\n  \n  // Apply custom CSS variables\n  root.style.setProperty('--bg', colors.bg);\n  root.style.setProperty('--bg-secondary', colors.bgSecondary);\n  root.style.setProperty('--bg-tertiary', colors.card);\n  root.style.setProperty('--accent', colors.accent);\n  root.style.setProperty('--primary', colors.accent);\n  root.style.setProperty('--text', colors.text);\n  root.style.setProperty('--text-secondary', colors.text + 'aa');\n  root.style.setProperty('--border', colors.border);\n  root.style.setProperty('--card', colors.card);\n  root.style.setProperty('--glass-bg', colors.card + 'cc');\n  root.style.setProperty('--glass-border', colors.border);\n  \n  // Mark as custom theme\n  root.setAttribute('data-theme', 'custom');\n  \n  // Update star colors\n  if (window.updateStarColors) {\n    window.updateStarColors();\n  }\n}\n\n// Clear custom theme and use preset\nfunction clearCustomTheme() {\n  localStorage.removeItem('customTheme');\n  document.documentElement.style.cssText = '';\n  const saved = localStorage.getItem('theme') || 'nebulacore';\n  applyTheme(saved);\n}\n\n// Apply theme to document\nfunction applyTheme(themeId) {\n  // Clear any custom theme styles\n  document.documentElement.style.cssText = '';\n  localStorage.removeItem('customTheme');\n  \n  if (!THEMES[themeId]) themeId = 'nebulacore';\n  document.documentElement.setAttribute('data-theme', themeId);\n  localStorage.setItem('theme', themeId);\n  updateThemeSelector(themeId);\n  \n  // Update star colors for particle system\n  if (window.updateStarColors) {\n    window.updateStarColors();\n  }\n}\n\n// Update theme selector dropdown\nfunction updateThemeSelector(themeId) {\n  const selector = document.getElementById('themeSelector');\n  if (selector) {\n    selector.value = themeId;\n  }\n}\n\n// Create star field background effect\nfunction createStarField() {\n  // Check if star field already exists\n  if (document.getElementById('star-field-canvas')) return;\n  \n  const canvas = document.createElement('canvas');\n  canvas.id = 'star-field-canvas';\n  canvas.style.cssText = `\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: -1;\n    pointer-events: none;\n    opacity: 0.6;\n  `;\n  document.body.insertBefore(canvas, document.body.firstChild);\n  \n  const ctx = canvas.getContext('2d');\n  let stars = [];\n  let animationId;\n  \n  function resize() {\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n    initStars();\n  }\n  \n  function initStars() {\n    stars = [];\n    const numStars = Math.floor((canvas.width * canvas.height) / 10000);\n    for (let i = 0; i < Math.min(numStars, 200); i++) {\n      stars.push({\n        x: Math.random() * canvas.width,\n        y: Math.random() * canvas.height,\n        size: Math.random() * 2 + 0.5,\n        speed: Math.random() * 0.3 + 0.05,\n        opacity: Math.random() * 0.8 + 0.2,\n        twinkle: Math.random() * Math.PI * 2\n      });\n    }\n  }\n  \n  function getStarColor() {\n    const style = getComputedStyle(document.documentElement);\n    return style.getPropertyValue('--star-color').trim() || '#4CC9F0';\n  }\n  \n  window.updateStarColors = function() {\n    // Colors will be fetched on next render\n  };\n  \n  function animate() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    const starColor = getStarColor();\n    \n    stars.forEach(star => {\n      star.twinkle += 0.02;\n      star.y += star.speed;\n      \n      if (star.y > canvas.height) {\n        star.y = 0;\n        star.x = Math.random() * canvas.width;\n      }\n      \n      const twinkleOpacity = star.opacity * (0.5 + 0.5 * Math.sin(star.twinkle));\n      \n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n      ctx.fillStyle = starColor.replace(')', `, ${twinkleOpacity})`).replace('rgb', 'rgba');\n      \n      // Fallback if color format doesn't match\n      if (!ctx.fillStyle.includes('rgba')) {\n        ctx.fillStyle = `rgba(76, 201, 240, ${twinkleOpacity})`;\n      }\n      \n      ctx.fill();\n    });\n    \n    animationId = requestAnimationFrame(animate);\n  }\n  \n  window.addEventListener('resize', resize);\n  resize();\n  animate();\n}\n\n// Generate theme selector HTML with all 36 themes\nfunction generateThemeSelectorHTML() {\n  let html = '';\n  Object.entries(THEMES).forEach(([id, theme]) => {\n    html += `<option value=\"${id}\">${theme.icon} ${theme.name}</option>\\n`;\n  });\n  return html;\n}\n\n// Create theme modal for enhanced theme selection\nfunction createThemeModal() {\n  if (document.getElementById('theme-modal')) return;\n  \n  const modal = document.createElement('div');\n  modal.id = 'theme-modal';\n  modal.className = 'theme-modal-overlay';\n  modal.innerHTML = `\n    <div class=\"theme-modal\">\n      <div class=\"theme-modal-header\">\n        <h2>Choose Your Theme</h2>\n        <button class=\"theme-modal-close\" onclick=\"closeThemeModal()\">&times;</button>\n      </div>\n      <div class=\"theme-modal-categories\" id=\"themeCategoryFilter\">\n        ${THEME_CATEGORIES.map(cat => `\n          <button class=\"theme-category-btn ${cat.id === 'all' ? 'active' : ''}\" \n                  data-category=\"${cat.id}\" \n                  onclick=\"filterThemesByCategory('${cat.id}')\">\n            ${cat.icon} ${cat.name}\n          </button>\n        `).join('')}\n      </div>\n      <div class=\"theme-modal-grid\" id=\"themeGrid\">\n        ${Object.entries(THEMES).map(([id, theme]) => `\n          <div class=\"theme-card\" data-theme=\"${id}\" data-category=\"${theme.category}\" onclick=\"selectTheme('${id}')\">\n            <div class=\"theme-card-preview theme-preview-${id}\">\n              <span class=\"theme-card-icon\">${theme.icon}</span>\n            </div>\n            <div class=\"theme-card-name\">${theme.name}</div>\n            <div class=\"theme-card-category\">${theme.category}</div>\n          </div>\n        `).join('')}\n      </div>\n    </div>\n  `;\n  document.body.appendChild(modal);\n  \n  // Add modal styles\n  addThemeModalStyles();\n}\n\nfunction addThemeModalStyles() {\n  if (document.getElementById('theme-modal-styles')) return;\n  \n  const styles = document.createElement('style');\n  styles.id = 'theme-modal-styles';\n  styles.textContent = `\n    .theme-modal-overlay {\n      position: fixed;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      background: rgba(0, 0, 0, 0.85);\n      backdrop-filter: blur(10px);\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      z-index: 10000;\n      opacity: 0;\n      visibility: hidden;\n      transition: all 0.3s ease;\n    }\n    \n    .theme-modal-overlay.active {\n      opacity: 1;\n      visibility: visible;\n    }\n    \n    .theme-modal {\n      background: var(--glass-bg, rgba(20, 20, 30, 0.95));\n      border: 1px solid var(--glass-border, rgba(255, 255, 255, 0.1));\n      border-radius: 24px;\n      width: 90%;\n      max-width: 900px;\n      max-height: 85vh;\n      overflow: hidden;\n      display: flex;\n      flex-direction: column;\n      transform: scale(0.9);\n      transition: transform 0.3s ease;\n    }\n    \n    .theme-modal-overlay.active .theme-modal {\n      transform: scale(1);\n    }\n    \n    .theme-modal-header {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      padding: 24px 28px;\n      border-bottom: 1px solid var(--glass-border, rgba(255, 255, 255, 0.1));\n    }\n    \n    .theme-modal-header h2 {\n      margin: 0;\n      font-size: 1.5rem;\n      background: var(--gradient-primary, linear-gradient(135deg, #4CC9F0, #A04FF9));\n      -webkit-background-clip: text;\n      -webkit-text-fill-color: transparent;\n      background-clip: text;\n    }\n    \n    .theme-modal-close {\n      width: 40px;\n      height: 40px;\n      border-radius: 50%;\n      border: none;\n      background: rgba(255, 255, 255, 0.1);\n      color: var(--text, white);\n      font-size: 24px;\n      cursor: pointer;\n      transition: all 0.2s;\n    }\n    \n    .theme-modal-close:hover {\n      background: var(--primary, #4CC9F0);\n      transform: rotate(90deg);\n    }\n    \n    .theme-modal-categories {\n      display: flex;\n      gap: 8px;\n      padding: 16px 28px;\n      overflow-x: auto;\n      border-bottom: 1px solid var(--glass-border, rgba(255, 255, 255, 0.1));\n    }\n    \n    .theme-category-btn {\n      padding: 8px 16px;\n      border-radius: 20px;\n      border: 1px solid var(--glass-border, rgba(255, 255, 255, 0.1));\n      background: transparent;\n      color: var(--text-secondary, #aaa);\n      font-size: 13px;\n      cursor: pointer;\n      white-space: nowrap;\n      transition: all 0.2s;\n    }\n    \n    .theme-category-btn:hover {\n      border-color: var(--primary, #4CC9F0);\n      color: var(--primary, #4CC9F0);\n    }\n    \n    .theme-category-btn.active {\n      background: var(--primary, #4CC9F0);\n      border-color: var(--primary, #4CC9F0);\n      color: var(--bg, #0D1B2A);\n    }\n    \n    .theme-modal-grid {\n      display: grid;\n      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));\n      gap: 16px;\n      padding: 24px 28px;\n      overflow-y: auto;\n      max-height: calc(85vh - 180px);\n    }\n    \n    .theme-card {\n      background: var(--card, rgba(30, 30, 40, 0.8));\n      border: 2px solid transparent;\n      border-radius: 16px;\n      padding: 12px;\n      cursor: pointer;\n      transition: all 0.3s ease;\n      text-align: center;\n    }\n    \n    .theme-card:hover {\n      border-color: var(--primary, #4CC9F0);\n      transform: translateY(-4px);\n      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);\n    }\n    \n    .theme-card.active {\n      border-color: var(--primary, #4CC9F0);\n      box-shadow: 0 0 20px var(--primary-glow, rgba(76, 201, 240, 0.5));\n    }\n    \n    .theme-card-preview {\n      height: 80px;\n      border-radius: 10px;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      margin-bottom: 10px;\n      position: relative;\n      overflow: hidden;\n    }\n    \n    .theme-card-icon {\n      font-size: 32px;\n      filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3));\n    }\n    \n    .theme-card-name {\n      font-size: 13px;\n      font-weight: 600;\n      color: var(--text, white);\n      margin-bottom: 4px;\n    }\n    \n    .theme-card-category {\n      font-size: 11px;\n      color: var(--text-muted, #888);\n    }\n    \n    .theme-card.hidden {\n      display: none;\n    }\n    \n    /* Theme preview backgrounds */\n    .theme-preview-nebulacore { background: linear-gradient(135deg, #0D1B2A, #1B263B); }\n    .theme-preview-ocean { background: linear-gradient(135deg, #0a0e27, #1a1f3a); }\n    .theme-preview-arcade { background: linear-gradient(135deg, #0a0a0a, #1a1a1a); border: 1px solid #ff00ff; }\n    .theme-preview-candy { background: linear-gradient(135deg, #fff5f8, #ffe8f0); }\n    .theme-preview-eclipse { background: linear-gradient(135deg, #0d0d0d, #1a1a1a); border: 1px solid #ffd700; }\n    .theme-preview-matrix { background: linear-gradient(135deg, #0a0a0a, #0d1a0d); border: 1px solid #00ff00; }\n    .theme-preview-notebook { background: linear-gradient(135deg, #f0f0f0, #e8e8e8); }\n    .theme-preview-gaming { background: linear-gradient(135deg, #0a0a14, #1a1a2e); border: 1px solid #00d9ff; }\n    .theme-preview-pixel { background: linear-gradient(135deg, #1a1a2e, #16213e); border: 1px solid #ff00ff; }\n    .theme-preview-cloudy { background: linear-gradient(135deg, #e8eef3, #d4dfe8); }\n    .theme-preview-academia { background: linear-gradient(135deg, #1a1410, #2a221a); border: 1px solid #d4af37; }\n    .theme-preview-aurora { background: linear-gradient(135deg, #0a1628, #102035); border: 1px solid #4fd1c5; }\n    .theme-preview-cherry { background: linear-gradient(135deg, #1a1215, #2a1f22); border: 1px solid #f48fb1; }\n    .theme-preview-volcanic { background: linear-gradient(135deg, #1a0a0a, #2a1010); border: 1px solid #ff6b35; }\n    .theme-preview-forest { background: linear-gradient(135deg, #0a1a0f, #102a18); border: 1px solid #66bb6a; }\n    .theme-preview-cyberpunk { background: linear-gradient(135deg, #0d0221, #1a0533); border: 1px solid #f72585; }\n    .theme-preview-sunset { background: linear-gradient(135deg, #1a0f15, #2a1520); border: 1px solid #ff7f50; }\n    .theme-preview-arctic { background: linear-gradient(135deg, #0a1520, #102030); border: 1px solid #00bcd4; }\n    .theme-preview-grape { background: linear-gradient(135deg, #1a0a2e, #2a1048); border: 1px solid #9c27b0; }\n    .theme-preview-coffee { background: linear-gradient(135deg, #1a1510, #2a2218); border: 1px solid #a67c52; }\n    .theme-preview-midnight { background: linear-gradient(135deg, #0f0a1a, #1a1030); border: 1px solid #8b5cf6; }\n    .theme-preview-tokyo { background: linear-gradient(135deg, #0a0a12, #141420); border: 1px solid #ff1493; }\n    .theme-preview-emerald { background: linear-gradient(135deg, #0a1a15, #103025); border: 1px solid #10b981; }\n    .theme-preview-bloodmoon { background: linear-gradient(135deg, #0a0508, #1a0a10); border: 1px solid #dc2626; }\n    .theme-preview-cottonblue { background: linear-gradient(135deg, #f0f8ff, #e0f0ff); }\n    .theme-preview-steampunk { background: linear-gradient(135deg, #1a1408, #2a2210); border: 1px solid #cd7f32; }\n    .theme-preview-lavender { background: linear-gradient(135deg, #f8f5ff, #f0e8ff); }\n    .theme-preview-spacegray { background: linear-gradient(135deg, #1c1c1e, #2c2c2e); }\n    .theme-preview-mint { background: linear-gradient(135deg, #f0fff8, #e0fff0); }\n    .theme-preview-darkrose { background: linear-gradient(135deg, #1a0a10, #2a1018); border: 1px solid #e11d48; }\n    .theme-preview-electric { background: linear-gradient(135deg, #000814, #001d3d); border: 1px solid #00b4d8; }\n    .theme-preview-golden { background: linear-gradient(135deg, #1a1408, #2a2010); border: 1px solid #f59e0b; }\n    .theme-preview-synthwave { background: linear-gradient(135deg, #090014, #15002a); border: 1px solid #ff71ce; }\n    .theme-preview-breeze { background: linear-gradient(135deg, #f0fdfa, #e0f7f5); }\n    .theme-preview-mono { background: linear-gradient(135deg, #0a0a0a, #141414); }\n    .theme-preview-jungle { background: linear-gradient(135deg, #021a09, #042b10); border: 1px solid #22c55e; }\n    \n    @media (max-width: 600px) {\n      .theme-modal-grid {\n        grid-template-columns: repeat(2, 1fr);\n      }\n      \n      .theme-modal-categories {\n        padding: 12px 16px;\n      }\n      \n      .theme-category-btn {\n        padding: 6px 12px;\n        font-size: 12px;\n      }\n    }\n  `;\n  document.head.appendChild(styles);\n}\n\n// Open theme modal\nfunction openThemeModal() {\n  createThemeModal();\n  const modal = document.getElementById('theme-modal');\n  if (modal) {\n    modal.classList.add('active');\n    highlightCurrentTheme();\n  }\n}\n\n// Close theme modal\nfunction closeThemeModal() {\n  const modal = document.getElementById('theme-modal');\n  if (modal) {\n    modal.classList.remove('active');\n  }\n}\n\n// Select theme from modal\nfunction selectTheme(themeId) {\n  applyTheme(themeId);\n  highlightCurrentTheme();\n  \n  // Brief animation feedback\n  const card = document.querySelector(`.theme-card[data-theme=\"${themeId}\"]`);\n  if (card) {\n    card.style.transform = 'scale(1.1)';\n    setTimeout(() => {\n      card.style.transform = '';\n    }, 200);\n  }\n}\n\n// Highlight current theme in modal\nfunction highlightCurrentTheme() {\n  const current = localStorage.getItem('theme') || 'nebulacore';\n  document.querySelectorAll('.theme-card').forEach(card => {\n    card.classList.toggle('active', card.dataset.theme === current);\n  });\n}\n\n// Filter themes by category\nfunction filterThemesByCategory(category) {\n  // Update active category button\n  document.querySelectorAll('.theme-category-btn').forEach(btn => {\n    btn.classList.toggle('active', btn.dataset.category === category);\n  });\n  \n  // Filter theme cards\n  document.querySelectorAll('.theme-card').forEach(card => {\n    if (category === 'all' || card.dataset.category === category) {\n      card.classList.remove('hidden');\n    } else {\n      card.classList.add('hidden');\n    }\n  });\n}\n\n// Get current theme info\nfunction getCurrentTheme() {\n  const themeId = localStorage.getItem('theme') || 'nebulacore';\n  return { id: themeId, ...THEMES[themeId] };\n}\n\n// Initialize on DOM ready\ndocument.addEventListener('DOMContentLoaded', () => {\n  initTheme();\n  \n  // Setup theme selector dropdown if exists\n  const selector = document.getElementById('themeSelector');\n  if (selector) {\n    // Populate with all themes\n    selector.innerHTML = generateThemeSelectorHTML();\n    selector.value = localStorage.getItem('theme') || 'nebulacore';\n    \n    selector.addEventListener('change', (e) => {\n      applyTheme(e.target.value);\n    });\n    \n    // Add click handler to open modal on double-click\n    selector.addEventListener('dblclick', (e) => {\n      e.preventDefault();\n      openThemeModal();\n    });\n  }\n  \n  // Add theme button if exists\n  const themeBtn = document.getElementById('openThemeModalBtn');\n  if (themeBtn) {\n    themeBtn.addEventListener('click', openThemeModal);\n  }\n});\n\n// Close modal on escape key\ndocument.addEventListener('keydown', (e) => {\n  if (e.key === 'Escape') {\n    closeThemeModal();\n  }\n});\n\n// Close modal on overlay click\ndocument.addEventListener('click', (e) => {\n  if (e.target.classList.contains('theme-modal-overlay')) {\n    closeThemeModal();\n  }\n});\n\n// Export for use in other scripts\nwindow.THEMES = THEMES;\nwindow.THEME_CATEGORIES = THEME_CATEGORIES;\nwindow.applyTheme = applyTheme;\nwindow.openThemeModal = openThemeModal;\nwindow.closeThemeModal = closeThemeModal;\nwindow.selectTheme = selectTheme;\nwindow.filterThemesByCategory = filterThemesByCategory;\nwindow.getCurrentTheme = getCurrentTheme;\n","path":null,"size_bytes":21543,"size_tokens":null},"backend/routes/invites.js":{"content":"const express = require('express');\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\n\nconst router = express.Router();\n\nfunction getUserId(req) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return null;\n  try {\n    const decoded = jwt.verify(token, 'real_user_auth_secret_2025');\n    return decoded.userId;\n  } catch {\n    return null;\n  }\n}\n\nfunction generateCode() {\n  return crypto.randomBytes(4).toString('hex').toUpperCase();\n}\n\nrouter.get('/server/:serverId', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { serverId } = req.params;\n  \n  db.get('SELECT * FROM server_members WHERE server_id = ? AND user_id = ?',\n    [serverId, userId], (err, member) => {\n      if (!member) return res.status(403).json({ error: 'Not a member of this server' });\n      \n      db.all(`\n        SELECT si.*, u.username as created_by_username\n        FROM server_invites si\n        JOIN users u ON si.created_by = u.id\n        WHERE si.server_id = ? AND (si.expires_at IS NULL OR si.expires_at > CURRENT_TIMESTAMP)\n        ORDER BY si.created_at DESC\n      `, [serverId], (err, invites) => {\n        if (err) return res.status(500).json({ error: err.message });\n        res.json(invites || []);\n      });\n    });\n});\n\nrouter.post('/server/:serverId', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { serverId } = req.params;\n  const { maxUses, expiresIn } = req.body;\n  \n  db.get('SELECT * FROM server_members WHERE server_id = ? AND user_id = ?',\n    [serverId, userId], (err, member) => {\n      if (!member) return res.status(403).json({ error: 'Not a member of this server' });\n      \n      const code = generateCode();\n      let expiresAt = null;\n      \n      if (expiresIn) {\n        const hours = parseInt(expiresIn);\n        if (hours > 0) {\n          expiresAt = new Date(Date.now() + hours * 60 * 60 * 1000).toISOString();\n        }\n      }\n      \n      db.run(`INSERT INTO server_invites (server_id, code, created_by, max_uses, expires_at)\n              VALUES (?, ?, ?, ?, ?)`,\n        [serverId, code, userId, maxUses || 0, expiresAt], function(err) {\n          if (err) return res.status(500).json({ error: err.message });\n          res.json({ success: true, code, inviteId: this.lastID });\n        });\n    });\n});\n\nrouter.get('/code/:code', (req, res) => {\n  const { code } = req.params;\n  \n  db.get(`\n    SELECT si.*, s.name as server_name, s.icon as server_icon,\n           u.username as created_by_username,\n           (SELECT COUNT(*) FROM server_members WHERE server_id = si.server_id) as member_count\n    FROM server_invites si\n    JOIN servers s ON si.server_id = s.id\n    JOIN users u ON si.created_by = u.id\n    WHERE si.code = ? AND (si.expires_at IS NULL OR si.expires_at > CURRENT_TIMESTAMP)\n  `, [code.toUpperCase()], (err, invite) => {\n    if (err) return res.status(500).json({ error: err.message });\n    if (!invite) return res.status(404).json({ error: 'Invalid or expired invite' });\n    if (invite.max_uses > 0 && invite.uses >= invite.max_uses) {\n      return res.status(400).json({ error: 'Invite has reached max uses' });\n    }\n    res.json(invite);\n  });\n});\n\nrouter.post('/join/:code', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { code } = req.params;\n  \n  db.get(`\n    SELECT * FROM server_invites \n    WHERE code = ? AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)\n  `, [code.toUpperCase()], (err, invite) => {\n    if (!invite) return res.status(404).json({ error: 'Invalid or expired invite' });\n    if (invite.max_uses > 0 && invite.uses >= invite.max_uses) {\n      return res.status(400).json({ error: 'Invite has reached max uses' });\n    }\n    \n    db.get('SELECT * FROM server_members WHERE server_id = ? AND user_id = ?',\n      [invite.server_id, userId], (err, existing) => {\n        if (existing) {\n          return res.json({ success: true, message: 'Already a member', serverId: invite.server_id });\n        }\n        \n        db.run('INSERT INTO server_members (server_id, user_id) VALUES (?, ?)',\n          [invite.server_id, userId], (err) => {\n            if (err) return res.status(500).json({ error: err.message });\n            \n            db.run('UPDATE server_invites SET uses = uses + 1 WHERE id = ?', [invite.id]);\n            \n            res.json({ success: true, message: 'Joined server', serverId: invite.server_id });\n          });\n      });\n  });\n});\n\nrouter.delete('/:inviteId', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { inviteId } = req.params;\n  \n  db.get('SELECT * FROM server_invites WHERE id = ?', [inviteId], (err, invite) => {\n    if (!invite) return res.status(404).json({ error: 'Invite not found' });\n    \n    db.get('SELECT owner_id FROM servers WHERE id = ?', [invite.server_id], (err, server) => {\n      if (invite.created_by !== userId && server?.owner_id !== userId) {\n        return res.status(403).json({ error: 'Not authorized to delete this invite' });\n      }\n      \n      db.run('DELETE FROM server_invites WHERE id = ?', [inviteId], (err) => {\n        if (err) return res.status(500).json({ error: err.message });\n        res.json({ success: true });\n      });\n    });\n  });\n});\n\nrouter.post('/server/:serverId/direct/:userId', (req, res) => {\n  const inviterId = getUserId(req);\n  if (!inviterId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { serverId, userId } = req.params;\n  \n  db.get('SELECT * FROM server_members WHERE server_id = ? AND user_id = ?',\n    [serverId, inviterId], (err, member) => {\n      if (!member) return res.status(403).json({ error: 'Not a member of this server' });\n      \n      db.get('SELECT * FROM users WHERE id = ?', [userId], (err, targetUser) => {\n        if (!targetUser) return res.status(404).json({ error: 'User not found' });\n        \n        db.get('SELECT * FROM server_members WHERE server_id = ? AND user_id = ?',\n          [serverId, userId], (err, existing) => {\n            if (existing) {\n              return res.json({ success: true, message: 'User is already a member' });\n            }\n            \n            db.run('INSERT INTO server_members (server_id, user_id) VALUES (?, ?)',\n              [serverId, userId], (err) => {\n                if (err) return res.status(500).json({ error: err.message });\n                res.json({ success: true, message: `${targetUser.username} has been added to the server` });\n              });\n          });\n      });\n    });\n});\n\nrouter.post('/group/:groupId/add/:userId', (req, res) => {\n  const inviterId = getUserId(req);\n  if (!inviterId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { groupId, userId } = req.params;\n  \n  db.get('SELECT * FROM group_chat_members WHERE group_id = ? AND user_id = ?',\n    [groupId, inviterId], (err, member) => {\n      if (!member) return res.status(403).json({ error: 'Not a member of this group' });\n      \n      db.get('SELECT * FROM users WHERE id = ?', [userId], (err, targetUser) => {\n        if (!targetUser) return res.status(404).json({ error: 'User not found' });\n        \n        db.get('SELECT * FROM group_chat_members WHERE group_id = ? AND user_id = ?',\n          [groupId, userId], (err, existing) => {\n            if (existing) {\n              return res.json({ success: true, message: 'User is already a member' });\n            }\n            \n            db.run('INSERT INTO group_chat_members (group_id, user_id) VALUES (?, ?)',\n              [groupId, userId], (err) => {\n                if (err) return res.status(500).json({ error: err.message });\n                res.json({ success: true, message: `${targetUser.username} has been added to the group` });\n              });\n          });\n      });\n    });\n});\n\nrouter.get('/friends-to-invite/server/:serverId', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { serverId } = req.params;\n  \n  db.all(`\n    SELECT DISTINCT u.id, u.username, u.profile_picture as \"profilePicture\"\n    FROM users u\n    JOIN friends f ON (\n      (f.user_id = ? AND f.friend_id = u.id) OR \n      (f.friend_id = ? AND f.user_id = u.id)\n    )\n    WHERE f.status = 'accepted'\n    AND u.id NOT IN (\n      SELECT user_id FROM server_members WHERE server_id = ?\n    )\n  `, [userId, userId, serverId], (err, friends) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(friends || []);\n  });\n});\n\nrouter.get('/friends-to-invite/group/:groupId', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const { groupId } = req.params;\n  \n  db.all(`\n    SELECT DISTINCT u.id, u.username, u.profile_picture as \"profilePicture\"\n    FROM users u\n    JOIN friends f ON (\n      (f.user_id = ? AND f.friend_id = u.id) OR \n      (f.friend_id = ? AND f.user_id = u.id)\n    )\n    WHERE f.status = 'accepted'\n    AND u.id NOT IN (\n      SELECT user_id FROM group_chat_members WHERE group_id = ?\n    )\n  `, [userId, userId, groupId], (err, friends) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(friends || []);\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":9483,"size_tokens":null},"backend/routes/archive.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst db = require('../db');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n\n  const jwt = require('jsonwebtoken');\n  const JWT_SECRET = 'real_user_auth_secret_2025';\n  \n  jwt.verify(token, JWT_SECRET, (err, user) => {\n    if (err) return res.status(403).json({ error: 'Invalid token' });\n    req.user = user;\n    next();\n  });\n};\n\nrouter.get('/', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  \n  db.all(`\n    SELECT ac.*, \n           CASE \n             WHEN ac.chat_type = 'dm' THEN u.username\n             WHEN ac.chat_type = 'group' THEN gc.name\n             WHEN ac.chat_type = 'channel' THEN ch.name\n           END as chat_name,\n           CASE \n             WHEN ac.chat_type = 'dm' THEN u.profile_picture\n             WHEN ac.chat_type = 'group' THEN NULL\n             WHEN ac.chat_type = 'channel' THEN NULL\n           END as chat_icon\n    FROM archived_chats ac\n    LEFT JOIN users u ON ac.chat_type = 'dm' AND ac.chat_id = u.id\n    LEFT JOIN group_chats gc ON ac.chat_type = 'group' AND ac.chat_id = gc.id\n    LEFT JOIN channels ch ON ac.chat_type = 'channel' AND ac.chat_id = ch.id\n    WHERE ac.user_id = ?\n    ORDER BY ac.archived_at DESC\n  `, [userId], (err, archived) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json(archived || []);\n  });\n});\n\nrouter.post('/archive', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  const { chat_type, chat_id } = req.body;\n  \n  if (!chat_type || !chat_id) {\n    return res.status(400).json({ error: 'Chat type and ID are required' });\n  }\n  \n  const validTypes = ['dm', 'group', 'channel'];\n  if (!validTypes.includes(chat_type)) {\n    return res.status(400).json({ error: 'Invalid chat type' });\n  }\n  \n  const validateChat = (callback) => {\n    if (chat_type === 'dm') {\n      db.get('SELECT id FROM users WHERE id = ?', [chat_id], callback);\n    } else if (chat_type === 'group') {\n      db.get('SELECT id FROM group_chat_members WHERE group_chat_id = ? AND user_id = ?', \n        [chat_id, userId], callback);\n    } else if (chat_type === 'channel') {\n      db.get(`\n        SELECT ch.id FROM channels ch\n        JOIN server_members sm ON ch.server_id = sm.server_id\n        WHERE ch.id = ? AND sm.user_id = ?\n      `, [chat_id, userId], callback);\n    }\n  };\n  \n  validateChat((err, valid) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!valid) return res.status(404).json({ error: 'Chat not found or access denied' });\n    \n    db.run(`\n      INSERT INTO archived_chats (user_id, chat_type, chat_id, archived_at)\n      VALUES (?, ?, ?, CURRENT_TIMESTAMP)\n      ON CONFLICT (user_id, chat_type, chat_id) DO UPDATE SET\n        archived_at = CURRENT_TIMESTAMP\n    `, [userId, chat_type, chat_id], function(err) {\n      if (err) return res.status(500).json({ error: 'Failed to archive chat' });\n      \n      res.json({ success: true, message: 'Chat archived' });\n    });\n  });\n});\n\nrouter.post('/unarchive', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  const { chat_type, chat_id } = req.body;\n  \n  if (!chat_type || !chat_id) {\n    return res.status(400).json({ error: 'Chat type and ID are required' });\n  }\n  \n  db.run(`\n    DELETE FROM archived_chats \n    WHERE user_id = ? AND chat_type = ? AND chat_id = ?\n  `, [userId, chat_type, chat_id], function(err) {\n    if (err) return res.status(500).json({ error: 'Failed to unarchive chat' });\n    if (this.changes === 0) return res.status(404).json({ error: 'Archived chat not found' });\n    \n    res.json({ success: true, message: 'Chat unarchived' });\n  });\n});\n\nrouter.get('/check/:chat_type/:chat_id', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  const { chat_type, chat_id } = req.params;\n  \n  db.get(`\n    SELECT id FROM archived_chats \n    WHERE user_id = ? AND chat_type = ? AND chat_id = ?\n  `, [userId, chat_type, chat_id], (err, archived) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json({ is_archived: !!archived });\n  });\n});\n\nrouter.post('/channel/:channelId/archive', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  const { channelId } = req.params;\n  \n  db.get(`\n    SELECT ch.*, s.owner_id FROM channels ch\n    JOIN servers s ON ch.server_id = s.id\n    WHERE ch.id = ?\n  `, [channelId], (err, channel) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!channel) return res.status(404).json({ error: 'Channel not found' });\n    \n    if (channel.owner_id !== userId) {\n      db.get(`\n        SELECT smr.* FROM server_member_roles smr\n        JOIN server_roles sr ON smr.role_id = sr.id\n        WHERE smr.server_id = ? AND smr.user_id = ? AND sr.permissions LIKE '%manage_channels%'\n      `, [channel.server_id, userId], (err, hasPermission) => {\n        if (err) return res.status(500).json({ error: 'Database error' });\n        if (!hasPermission) return res.status(403).json({ error: 'Permission denied' });\n        \n        archiveChannel();\n      });\n    } else {\n      archiveChannel();\n    }\n    \n    function archiveChannel() {\n      db.run(`\n        UPDATE channels SET is_archived = true, archived_at = CURRENT_TIMESTAMP\n        WHERE id = ?\n      `, [channelId], function(err) {\n        if (err) return res.status(500).json({ error: 'Failed to archive channel' });\n        \n        res.json({ success: true, message: 'Channel archived' });\n      });\n    }\n  });\n});\n\nrouter.post('/channel/:channelId/unarchive', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  const { channelId } = req.params;\n  \n  db.get(`\n    SELECT ch.*, s.owner_id FROM channels ch\n    JOIN servers s ON ch.server_id = s.id\n    WHERE ch.id = ?\n  `, [channelId], (err, channel) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!channel) return res.status(404).json({ error: 'Channel not found' });\n    \n    if (channel.owner_id !== userId) {\n      return res.status(403).json({ error: 'Only server owner can unarchive channels' });\n    }\n    \n    db.run(`\n      UPDATE channels SET is_archived = FALSE, archived_at = NULL\n      WHERE id = ?\n    `, [channelId], function(err) {\n      if (err) return res.status(500).json({ error: 'Failed to unarchive channel' });\n      \n      res.json({ success: true, message: 'Channel unarchived' });\n    });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":6662,"size_tokens":null},"backend/routes/shop.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst db = require('../db');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'Unauthorized' });\n  \n  const jwt = require('jsonwebtoken');\n  const JWT_SECRET = 'real_user_auth_secret_2025';\n  \n  jwt.verify(token, JWT_SECRET, (err, user) => {\n    if (err) return res.status(403).json({ error: 'Invalid token' });\n    req.user = user;\n    next();\n  });\n};\n\nrouter.get('/categories', authenticateToken, (req, res) => {\n  db.all('SELECT * FROM shop_categories ORDER BY position', (err, categories) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json(categories);\n  });\n});\n\nrouter.get('/items', authenticateToken, (req, res) => {\n  const { category, search, rarity } = req.query;\n  let sql = `\n    SELECT si.*, sc.name as category_name, sc.slug as category_slug\n    FROM shop_items si\n    JOIN shop_categories sc ON si.category_id = sc.id\n    WHERE si.is_available = TRUE\n  `;\n  const params = [];\n  \n  if (category) {\n    sql += ' AND (sc.slug = ? OR sc.id = ?)';\n    params.push(category, category);\n  }\n  if (search) {\n    sql += ' AND (si.name LIKE ? OR si.description LIKE ?)';\n    params.push(`%${search}%`, `%${search}%`);\n  }\n  if (rarity) {\n    sql += ' AND si.rarity = ?';\n    params.push(rarity);\n  }\n  \n  sql += ' ORDER BY sc.position, si.price';\n  \n  db.all(sql, params, (err, items) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json(items);\n  });\n});\n\nrouter.get('/item/:id', authenticateToken, (req, res) => {\n  db.get(`\n    SELECT si.*, sc.name as category_name, sc.slug as category_slug\n    FROM shop_items si\n    JOIN shop_categories sc ON si.category_id = sc.id\n    WHERE si.id = ?\n  `, [req.params.id], (err, item) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!item) return res.status(404).json({ error: 'Item not found' });\n    res.json(item);\n  });\n});\n\nrouter.get('/wallet', authenticateToken, (req, res) => {\n  db.get('SELECT coins FROM users WHERE id = ?', [req.user.userId], (err, user) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    \n    db.all(`\n      SELECT * FROM coin_transactions \n      WHERE user_id = ? \n      ORDER BY created_at DESC \n      LIMIT 20\n    `, [req.user.userId], (err, transactions) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      res.json({\n        coins: user?.coins || 0,\n        transactions: transactions || []\n      });\n    });\n  });\n});\n\nrouter.post('/purchase/:itemId', authenticateToken, (req, res) => {\n  const itemId = parseInt(req.params.itemId);\n  const userId = req.user.userId;\n  \n  db.get('SELECT * FROM shop_items WHERE id = ? AND is_available = TRUE', [itemId], (err, item) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!item) return res.status(404).json({ error: 'Item not found or unavailable' });\n    \n    db.get('SELECT * FROM user_purchases WHERE user_id = ? AND item_id = ?', [userId, itemId], (err, existing) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      if (existing) return res.status(400).json({ error: 'You already own this item' });\n      \n      db.get('SELECT coins FROM users WHERE id = ?', [userId], (err, user) => {\n        if (err) return res.status(500).json({ error: 'Database error' });\n        if (!user || user.coins < item.price) {\n          return res.status(400).json({ error: 'Not enough coins', required: item.price, current: user?.coins || 0 });\n        }\n        \n        const newBalance = user.coins - item.price;\n        \n        db.run('UPDATE users SET coins = ? WHERE id = ?', [newBalance, userId], function(err) {\n          if (err) return res.status(500).json({ error: 'Transaction failed' });\n          \n          db.run(`\n            INSERT INTO user_purchases (user_id, item_id, price_paid)\n            VALUES (?, ?, ?)\n          `, [userId, itemId, item.price], function(err) {\n            if (err) {\n              db.run('UPDATE users SET coins = ? WHERE id = ?', [user.coins, userId], () => {});\n              return res.status(500).json({ error: 'Purchase failed' });\n            }\n            \n            db.run(`\n              INSERT INTO coin_transactions (user_id, amount, balance_after, transaction_type, description, reference_id)\n              VALUES (?, ?, ?, 'purchase', ?, ?)\n            `, [userId, -item.price, newBalance, `Purchased ${item.name}`, itemId], () => {});\n            \n            res.json({\n              success: true,\n              message: `Successfully purchased ${item.name}!`,\n              item: item,\n              newBalance: newBalance\n            });\n          });\n        });\n      });\n    });\n  });\n});\n\nrouter.get('/inventory', authenticateToken, (req, res) => {\n  db.all(`\n    SELECT si.*, up.purchased_at, sc.name as category_name, sc.slug as category_slug\n    FROM user_purchases up\n    JOIN shop_items si ON up.item_id = si.id\n    JOIN shop_categories sc ON si.category_id = sc.id\n    WHERE up.user_id = ?\n    ORDER BY up.purchased_at DESC\n  `, [req.user.userId], (err, items) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json(items || []);\n  });\n});\n\nrouter.get('/equipped', authenticateToken, (req, res) => {\n  db.all(`\n    SELECT ue.*, si.name, si.item_type, si.css_class, si.css_vars, si.asset_url, si.metadata, si.is_animated\n    FROM user_equipped ue\n    JOIN shop_items si ON ue.item_id = si.id\n    WHERE ue.user_id = ? AND (ue.server_id IS NULL OR ue.server_id = 0)\n  `, [req.user.userId], (err, equipped) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    \n    const equippedMap = {};\n    (equipped || []).forEach(item => {\n      equippedMap[item.slot] = item;\n    });\n    \n    res.json(equippedMap);\n  });\n});\n\nrouter.post('/equip', authenticateToken, (req, res) => {\n  const { itemId, slot, serverId } = req.body;\n  const userId = req.user.userId;\n  \n  if (!itemId || !slot) {\n    return res.status(400).json({ error: 'Item ID and slot are required' });\n  }\n  \n  db.get(`\n    SELECT si.* FROM user_purchases up\n    JOIN shop_items si ON up.item_id = si.id\n    WHERE up.user_id = ? AND up.item_id = ?\n  `, [userId, itemId], (err, item) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!item) return res.status(400).json({ error: 'You do not own this item' });\n    \n    const slotMap = {\n      'theme': 'theme',\n      'frame': 'frame',\n      'badge': 'badge',\n      'bubble': 'bubble',\n      'sound': 'sound',\n      'avatar': 'avatar',\n      'status': 'status',\n      'bio_upgrade': 'bio_upgrade',\n      'boost': 'boost',\n      'server_icon': 'server_icon',\n      'server_banner': 'server_banner'\n    };\n    \n    if (!slotMap[item.item_type] || slotMap[item.item_type] !== slot) {\n      return res.status(400).json({ error: 'Item type does not match slot' });\n    }\n    \n    const serverIdValue = serverId || null;\n    \n    const doEquip = () => {\n      db.run(`\n        INSERT INTO user_equipped (user_id, slot, item_id, server_id, equipped_at)\n        VALUES (?, ?, ?, COALESCE(?, 0), CURRENT_TIMESTAMP)\n        ON CONFLICT (user_id, slot, server_id) DO UPDATE SET \n          item_id = excluded.item_id,\n          equipped_at = CURRENT_TIMESTAMP\n      `, [userId, slot, itemId, serverIdValue], function(err) {\n        if (err) return res.status(500).json({ error: 'Failed to equip item' });\n        \n        res.json({\n          success: true,\n          message: `Equipped ${item.name}`,\n          item: item\n        });\n      });\n    };\n    \n    if ((slot === 'server_icon' || slot === 'server_banner') && serverId) {\n      db.get(`\n        SELECT s.owner_id, sm.user_id as member_id\n        FROM servers s\n        LEFT JOIN server_members sm ON s.id = sm.server_id AND sm.user_id = ?\n        WHERE s.id = ?\n      `, [userId, serverId], (err, serverData) => {\n        if (err) return res.status(500).json({ error: 'Database error' });\n        if (!serverData) return res.status(404).json({ error: 'Server not found' });\n        \n        const isOwner = serverData.owner_id === userId;\n        const isMember = serverData.member_id === userId;\n        \n        if (!isOwner && !isMember) {\n          return res.status(403).json({ error: 'You must be a member of this server' });\n        }\n        \n        if (!isOwner) {\n          return res.status(403).json({ error: 'Only the server owner can change server cosmetics' });\n        }\n        \n        doEquip();\n      });\n    } else {\n      doEquip();\n    }\n  });\n});\n\nrouter.post('/unequip', authenticateToken, (req, res) => {\n  const { slot, serverId } = req.body;\n  const userId = req.user.userId;\n  \n  if (!slot) {\n    return res.status(400).json({ error: 'Slot is required' });\n  }\n  \n  let sql = 'DELETE FROM user_equipped WHERE user_id = ? AND slot = ?';\n  let params = [userId, slot];\n  \n  if (serverId) {\n    sql += ' AND server_id = ?';\n    params.push(serverId);\n  } else {\n    sql += ' AND (server_id IS NULL OR server_id = 0)';\n  }\n  \n  db.run(sql, params, function(err) {\n    if (err) return res.status(500).json({ error: 'Failed to unequip item' });\n    \n    res.json({\n      success: true,\n      message: `Unequipped ${slot}`\n    });\n  });\n});\n\nconst DAILY_REWARDS = [\n  { day: 1, coins: 50, item: null },\n  { day: 2, coins: 150, item: null },\n  { day: 3, coins: 200, item: null },\n  { day: 4, coins: 250, item: null },\n  { day: 5, coins: 300, item: null },\n  { day: 6, coins: 350, item: null },\n  { day: 7, coins: 400, item: null },\n  { day: 8, coins: 0, item: 'daily-special-badge' }\n];\n\nrouter.post('/daily', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  const today = new Date().toISOString().split('T')[0];\n  \n  db.get(`\n    SELECT * FROM daily_rewards \n    WHERE user_id = ? AND reward_date = ?\n  `, [userId, today], (err, existing) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (existing) return res.status(400).json({ error: 'Already claimed today', nextClaim: 'tomorrow' });\n    \n    db.get(`\n      SELECT * FROM daily_rewards \n      WHERE user_id = ? \n      ORDER BY reward_date DESC \n      LIMIT 1\n    `, [userId], (err, lastReward) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      \n      let streak = 1;\n      if (lastReward) {\n        const lastDate = new Date(lastReward.reward_date);\n        const yesterday = new Date();\n        yesterday.setDate(yesterday.getDate() - 1);\n        \n        if (lastDate.toISOString().split('T')[0] === yesterday.toISOString().split('T')[0]) {\n          streak = (lastReward.streak % 8) + 1;\n        }\n      }\n      \n      const dayIndex = ((streak - 1) % 8);\n      const reward = DAILY_REWARDS[dayIndex];\n      let amount = reward.coins;\n      \n      db.get(`\n        SELECT si.metadata FROM user_equipped ue\n        JOIN shop_items si ON ue.item_id = si.id\n        WHERE ue.user_id = ? AND ue.slot = 'boost' AND si.slug = 'boost-daily'\n      `, [userId], (err, boost) => {\n        let bonusMultiplier = 1;\n        if (!err && boost) {\n          try {\n            const meta = JSON.parse(boost.metadata);\n            if (meta.coinBonus) bonusMultiplier = meta.coinBonus;\n          } catch(e) {}\n        }\n        \n        amount = Math.floor(amount * bonusMultiplier);\n        \n        db.get('SELECT coins FROM users WHERE id = ?', [userId], (err, user) => {\n          if (err) return res.status(500).json({ error: 'Database error' });\n          \n          const newBalance = (user?.coins || 0) + amount;\n          \n          const processReward = () => {\n            db.run('UPDATE users SET coins = ? WHERE id = ?', [newBalance, userId], function(err) {\n              if (err) return res.status(500).json({ error: 'Failed to add coins' });\n              \n              db.run(`\n                INSERT INTO daily_rewards (user_id, reward_date, amount, streak)\n                VALUES (?, ?, ?, ?)\n              `, [userId, today, amount, streak], function(err) {\n                if (err) return res.status(500).json({ error: 'Failed to record daily reward' });\n                \n                if (amount > 0) {\n                  db.run(`\n                    INSERT INTO coin_transactions (user_id, amount, balance_after, transaction_type, description)\n                    VALUES (?, ?, ?, 'daily_reward', ?)\n                  `, [userId, amount, newBalance, `Day ${streak} daily reward`], () => {});\n                }\n                \n                res.json({\n                  success: true,\n                  day: streak,\n                  amount: amount,\n                  itemAwarded: reward.item,\n                  streak: streak,\n                  newBalance: newBalance,\n                  message: reward.item ? `Day ${streak} reward! You earned a special item!` : `Day ${streak} reward! +${amount} coins`\n                });\n              });\n            });\n          };\n          \n          if (reward.item) {\n            db.get('SELECT id FROM shop_items WHERE slug = ?', [reward.item], (err, item) => {\n              if (item) {\n                db.run(`\n                  INSERT INTO user_purchases (user_id, item_id, purchased_at)\n                  VALUES (?, ?, CURRENT_TIMESTAMP)\n                  ON CONFLICT DO NOTHING\n                `, [userId, item.id], () => {});\n              }\n              processReward();\n            });\n          } else {\n            processReward();\n          }\n        });\n      });\n    });\n  });\n});\n\nrouter.get('/daily/status', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  const today = new Date().toISOString().split('T')[0];\n  \n  db.get(`\n    SELECT * FROM daily_rewards \n    WHERE user_id = ? AND reward_date = ?\n  `, [userId, today], (err, todayReward) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    \n    db.get(`\n      SELECT * FROM daily_rewards \n      WHERE user_id = ? \n      ORDER BY reward_date DESC \n      LIMIT 1\n    `, [userId], (err, lastReward) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      \n      let currentDay = 1;\n      let streakActive = false;\n      \n      if (lastReward) {\n        const lastDate = new Date(lastReward.reward_date);\n        const yesterday = new Date();\n        yesterday.setDate(yesterday.getDate() - 1);\n        \n        if (lastDate.toISOString().split('T')[0] === yesterday.toISOString().split('T')[0]) {\n          currentDay = (lastReward.streak % 8) + 1;\n          streakActive = true;\n        } else if (lastDate.toISOString().split('T')[0] === today) {\n          currentDay = lastReward.streak;\n          streakActive = true;\n        }\n      }\n      \n      res.json({\n        claimed: !!todayReward,\n        lastClaim: lastReward?.reward_date,\n        currentStreak: lastReward?.streak || 0,\n        currentDay: currentDay,\n        streakActive: streakActive,\n        todayAmount: todayReward?.amount,\n        rewards: DAILY_REWARDS\n      });\n    });\n  });\n});\n\nrouter.get('/user/:userId/cosmetics', authenticateToken, (req, res) => {\n  const targetUserId = parseInt(req.params.userId);\n  \n  db.all(`\n    SELECT ue.slot, si.name, si.item_type, si.css_class, si.css_vars, si.asset_url, si.metadata, si.is_animated\n    FROM user_equipped ue\n    JOIN shop_items si ON ue.item_id = si.id\n    WHERE ue.user_id = ? AND (ue.server_id IS NULL OR ue.server_id = 0)\n  `, [targetUserId], (err, equipped) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    \n    const cosmetics = {};\n    (equipped || []).forEach(item => {\n      cosmetics[item.slot] = {\n        name: item.name,\n        css_class: item.css_class,\n        css_vars: item.css_vars,\n        asset_url: item.asset_url,\n        metadata: item.metadata,\n        is_animated: item.is_animated\n      };\n    });\n    \n    res.json(cosmetics);\n  });\n});\n\nrouter.post('/admin/give-coins', authenticateToken, (req, res) => {\n  const { targetUserId, amount, reason } = req.body;\n  \n  db.get('SELECT role FROM users WHERE id = ?', [req.user.userId], (err, user) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!user || user.role !== 'admin') {\n      return res.status(403).json({ error: 'Admin access required' });\n    }\n    \n    db.get('SELECT coins FROM users WHERE id = ?', [targetUserId], (err, target) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      if (!target) return res.status(404).json({ error: 'User not found' });\n      \n      const newBalance = (target.coins || 0) + amount;\n      \n      db.run('UPDATE users SET coins = ? WHERE id = ?', [newBalance, targetUserId], function(err) {\n        if (err) return res.status(500).json({ error: 'Failed to update coins' });\n        \n        db.run(`\n          INSERT INTO coin_transactions (user_id, amount, balance_after, transaction_type, description)\n          VALUES (?, ?, ?, 'admin_grant', ?)\n        `, [targetUserId, amount, newBalance, reason || 'Admin grant'], () => {});\n        \n        res.json({\n          success: true,\n          newBalance: newBalance\n        });\n      });\n    });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":17390,"size_tokens":null},"backend/routes/shortcuts.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst db = require('../db');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n\n  const jwt = require('jsonwebtoken');\n  const JWT_SECRET = 'real_user_auth_secret_2025';\n  \n  jwt.verify(token, JWT_SECRET, (err, user) => {\n    if (err) return res.status(403).json({ error: 'Invalid token' });\n    req.user = user;\n    next();\n  });\n};\n\nrouter.get('/defaults', (req, res) => {\n  db.all('SELECT * FROM default_shortcuts ORDER BY category, action', [], (err, shortcuts) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json(shortcuts || []);\n  });\n});\n\nrouter.get('/', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  \n  db.all(`\n    SELECT ds.action, ds.description, ds.category,\n           COALESCE(us.shortcut, ds.shortcut) as shortcut,\n           COALESCE(us.is_enabled, TRUE) as is_enabled\n    FROM default_shortcuts ds\n    LEFT JOIN user_shortcuts us ON ds.action = us.action AND us.user_id = ?\n    ORDER BY ds.category, ds.action\n  `, [userId], (err, shortcuts) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json(shortcuts || []);\n  });\n});\n\nrouter.put('/:action', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  const { action } = req.params;\n  const { shortcut, is_enabled } = req.body;\n  \n  if (!shortcut) {\n    return res.status(400).json({ error: 'Shortcut key is required' });\n  }\n  \n  const normalizedShortcut = shortcut.toLowerCase();\n  \n  db.get('SELECT id FROM default_shortcuts WHERE action = ?', [action], (err, defaultShortcut) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!defaultShortcut) return res.status(404).json({ error: 'Invalid action' });\n    \n    db.get('SELECT id FROM user_shortcuts WHERE user_id = ? AND shortcut = ? AND action != ?', \n      [userId, normalizedShortcut, action], (err, userConflict) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      if (userConflict) return res.status(400).json({ error: 'Shortcut already in use by another action' });\n      \n      db.all(`\n        SELECT ds.action, COALESCE(us.shortcut, ds.shortcut) as shortcut\n        FROM default_shortcuts ds\n        LEFT JOIN user_shortcuts us ON ds.action = us.action AND us.user_id = ?\n        WHERE ds.action != ?\n      `, [userId, action], (err, allShortcuts) => {\n        if (err) return res.status(500).json({ error: 'Database error' });\n        \n        const conflictingAction = allShortcuts.find(s => s.shortcut === normalizedShortcut);\n        if (conflictingAction) {\n          return res.status(400).json({ \n            error: `Shortcut \"${shortcut}\" is already used by \"${conflictingAction.action.replace(/_/g, ' ')}\"` \n          });\n        }\n        \n        db.run(`\n          INSERT INTO user_shortcuts (user_id, action, shortcut, is_enabled)\n          VALUES (?, ?, ?, ?)\n          ON CONFLICT (user_id, action) DO UPDATE SET\n            shortcut = excluded.shortcut,\n            is_enabled = excluded.is_enabled\n        `, [userId, action, normalizedShortcut, is_enabled !== false], function(err) {\n          if (err) return res.status(500).json({ error: 'Failed to update shortcut' });\n          \n          res.json({ success: true, message: 'Shortcut updated' });\n        });\n      });\n    });\n  });\n});\n\nrouter.post('/reset', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  \n  db.run('DELETE FROM user_shortcuts WHERE user_id = ?', [userId], function(err) {\n    if (err) return res.status(500).json({ error: 'Failed to reset shortcuts' });\n    \n    res.json({ success: true, message: 'Shortcuts reset to defaults' });\n  });\n});\n\nrouter.put('/:action/toggle', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  const { action } = req.params;\n  \n  db.get(`\n    SELECT ds.shortcut as default_shortcut, us.shortcut, us.is_enabled\n    FROM default_shortcuts ds\n    LEFT JOIN user_shortcuts us ON ds.action = us.action AND us.user_id = ?\n    WHERE ds.action = ?\n  `, [userId, action], (err, data) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!data) return res.status(404).json({ error: 'Invalid action' });\n    \n    const currentEnabled = data.is_enabled !== undefined ? data.is_enabled : true;\n    const newEnabled = !currentEnabled;\n    const shortcut = data.shortcut || data.default_shortcut;\n    \n    db.run(`\n      INSERT INTO user_shortcuts (user_id, action, shortcut, is_enabled)\n      VALUES (?, ?, ?, ?)\n      ON CONFLICT (user_id, action) DO UPDATE SET\n        shortcut = excluded.shortcut,\n        is_enabled = excluded.is_enabled\n    `, [userId, action, shortcut, newEnabled], function(err) {\n      if (err) return res.status(500).json({ error: 'Failed to toggle shortcut' });\n      \n      res.json({ success: true, is_enabled: newEnabled });\n    });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":5142,"size_tokens":null},"backend/routes/changelogs.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst db = require('../db');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n\n  const jwt = require('jsonwebtoken');\n  const JWT_SECRET = 'real_user_auth_secret_2025';\n  \n  jwt.verify(token, JWT_SECRET, (err, user) => {\n    if (err) return res.status(403).json({ error: 'Invalid token' });\n    req.user = user;\n    next();\n  });\n};\n\nconst requireAdmin = (req, res, next) => {\n  if (req.user.role !== 'admin') {\n    return res.status(403).json({ error: 'Admin access required' });\n  }\n  next();\n};\n\nrouter.get('/', (req, res) => {\n  db.all(`\n    SELECT c.*, u.username as author_name\n    FROM changelogs c\n    LEFT JOIN users u ON c.author_id = u.id\n    WHERE c.is_published = TRUE\n    ORDER BY c.created_at DESC\n  `, [], (err, changelogs) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json(changelogs || []);\n  });\n});\n\nrouter.get('/all', authenticateToken, requireAdmin, (req, res) => {\n  db.all(`\n    SELECT c.*, u.username as author_name\n    FROM changelogs c\n    LEFT JOIN users u ON c.author_id = u.id\n    ORDER BY c.created_at DESC\n  `, [], (err, changelogs) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json(changelogs || []);\n  });\n});\n\nrouter.get('/:id', (req, res) => {\n  db.get(`\n    SELECT c.*, u.username as author_name\n    FROM changelogs c\n    LEFT JOIN users u ON c.author_id = u.id\n    WHERE c.id = ? AND c.is_published = TRUE\n  `, [req.params.id], (err, changelog) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!changelog) return res.status(404).json({ error: 'Changelog not found' });\n    res.json(changelog);\n  });\n});\n\nrouter.post('/', authenticateToken, requireAdmin, (req, res) => {\n  const { version, title, content, change_type, is_published } = req.body;\n  \n  if (!title || !content) {\n    return res.status(400).json({ error: 'Title and content are required' });\n  }\n  \n  const validTypes = ['feature', 'bugfix', 'improvement', 'security', 'removed', 'ui'];\n  const type = validTypes.includes(change_type) ? change_type : 'feature';\n  \n  db.run(`\n    INSERT INTO changelogs (version, title, content, change_type, author_id, is_published)\n    VALUES (?, ?, ?, ?, ?, ?)\n  `, [version || null, title, content, type, req.user.userId, is_published !== false ? 1 : 0], function(err) {\n    if (err) return res.status(500).json({ error: 'Failed to create changelog' });\n    \n    res.json({\n      success: true,\n      id: this.lastID,\n      message: 'Changelog created successfully'\n    });\n  });\n});\n\nrouter.put('/:id', authenticateToken, requireAdmin, (req, res) => {\n  const { version, title, content, change_type, is_published } = req.body;\n  \n  if (!title || !content) {\n    return res.status(400).json({ error: 'Title and content are required' });\n  }\n  \n  const validTypes = ['feature', 'bugfix', 'improvement', 'security', 'removed', 'ui'];\n  const type = validTypes.includes(change_type) ? change_type : 'feature';\n  \n  db.run(`\n    UPDATE changelogs \n    SET version = ?, title = ?, content = ?, change_type = ?, is_published = ?\n    WHERE id = ?\n  `, [version || null, title, content, type, is_published ? 1 : 0, req.params.id], function(err) {\n    if (err) return res.status(500).json({ error: 'Failed to update changelog' });\n    if (this.changes === 0) return res.status(404).json({ error: 'Changelog not found' });\n    \n    res.json({ success: true, message: 'Changelog updated' });\n  });\n});\n\nrouter.delete('/:id', authenticateToken, requireAdmin, (req, res) => {\n  db.run('DELETE FROM changelogs WHERE id = ?', [req.params.id], function(err) {\n    if (err) return res.status(500).json({ error: 'Failed to delete changelog' });\n    if (this.changes === 0) return res.status(404).json({ error: 'Changelog not found' });\n    \n    res.json({ success: true, message: 'Changelog deleted' });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":4124,"size_tokens":null},"backend/routes/notes.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst JWT_SECRET = 'real_user_auth_secret_2025';\n\nfunction authenticateToken(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n  \n  try {\n    req.user = jwt.verify(token, JWT_SECRET);\n    next();\n  } catch {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\nrouter.get('/:friendId', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  const friendId = parseInt(req.params.friendId);\n  \n  db.get('SELECT note, updated_at FROM friend_notes WHERE user_id = ? AND friend_id = ?',\n    [userId, friendId], (err, note) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      res.json(note || { note: '', updated_at: null });\n    });\n});\n\nrouter.put('/:friendId', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  const friendId = parseInt(req.params.friendId);\n  const { note } = req.body;\n  \n  if (friendId === userId) {\n    return res.status(400).json({ error: 'Cannot add note to yourself' });\n  }\n  \n  db.get('SELECT id FROM users WHERE id = ?', [friendId], (err, user) => {\n    if (!user) return res.status(404).json({ error: 'User not found' });\n    \n    db.run(`\n      INSERT INTO friend_notes (user_id, friend_id, note, updated_at)\n      VALUES (?, ?, ?, CURRENT_TIMESTAMP)\n      ON CONFLICT(user_id, friend_id) DO UPDATE SET\n        note = excluded.note,\n        updated_at = CURRENT_TIMESTAMP\n    `, [userId, friendId, note || ''], function(err) {\n      if (err) return res.status(500).json({ error: 'Failed to save note' });\n      res.json({ success: true, message: 'Note saved' });\n    });\n  });\n});\n\nrouter.delete('/:friendId', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  const friendId = parseInt(req.params.friendId);\n  \n  db.run('DELETE FROM friend_notes WHERE user_id = ? AND friend_id = ?',\n    [userId, friendId], function(err) {\n      if (err) return res.status(500).json({ error: 'Failed to delete note' });\n      res.json({ success: true, message: 'Note deleted' });\n    });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":2270,"size_tokens":null},"frontend/js/stealth-mode.js":{"content":"const StealthMode = {\n  originalTitle: document.title,\n  originalFavicon: null,\n  isActive: false,\n  \n  // ClassLink favicon\n  classLinkIcon: 'https://www.classlink.com/favicon.ico',\n  \n  panicTargets: [\n    { name: 'ClassLink Launchpad', url: 'https://myapps.classlink.com/home', title: 'ClassLink Launchpad', favicon: 'https://www.classlink.com/favicon.ico' },\n    { name: 'Staff Portal Login', url: '/classlink', title: 'Staff Portal | K-12 Learning Portal', favicon: '/favicon.png' }\n  ],\n  \n  // Custom flood history URL\n  customFloodUrl: localStorage.getItem('customFloodUrl') || '',\n  \n  disguises: [\n    { name: 'Google Docs', title: 'Untitled document - Google Docs', favicon: 'https://ssl.gstatic.com/docs/documents/images/kix-favicon7.ico', url: 'https://docs.google.com' },\n    { name: 'Google Classroom', title: 'Google Classroom', favicon: 'https://ssl.gstatic.com/classroom/favicon.png', url: 'https://classroom.google.com' },\n    { name: 'Khan Academy', title: 'Khan Academy | Free Online Courses', favicon: 'https://cdn.kastatic.org/images/favicon.ico', url: 'https://khanacademy.org' },\n    { name: 'Google Drive', title: 'My Drive - Google Drive', favicon: 'https://ssl.gstatic.com/images/branding/product/1x/drive_2020q4_32dp.png', url: 'https://drive.google.com' }\n  ],\n  \n  currentPanicTarget: null,\n  currentDisguise: null,\n  \n  init() {\n    this.originalFavicon = this.getFavicon();\n    this.loadSettings();\n    this.createPanicButton();\n    this.setupKeyboardShortcut();\n    this.createSettingsUI();\n    this.applyTabCloak();\n  },\n  \n  getFavicon() {\n    const link = document.querySelector(\"link[rel*='icon']\");\n    return link ? link.href : '/favicon.ico';\n  },\n  \n  setFavicon(url) {\n    let link = document.querySelector(\"link[rel*='icon']\");\n    if (!link) {\n      link = document.createElement('link');\n      link.rel = 'icon';\n      document.head.appendChild(link);\n    }\n    link.href = url;\n  },\n  \n  loadSettings() {\n    const savedPanic = localStorage.getItem('panicTarget');\n    this.currentPanicTarget = this.panicTargets.find(p => p.name === savedPanic) || this.panicTargets[0];\n    \n    const savedDisguise = localStorage.getItem('stealthDisguise');\n    this.currentDisguise = this.disguises.find(d => d.name === savedDisguise) || this.disguises[0];\n  },\n  \n  createPanicButton() {\n    // Panic button removed - use keyboard shortcuts only (ESC twice or ` twice)\n  },\n  \n  setupKeyboardShortcut() {\n    let escCount = 0;\n    let backtickCount = 0;\n    let escTimer = null;\n    let backtickTimer = null;\n    \n    document.addEventListener('keydown', (e) => {\n      if (e.key === '`' && !e.target.matches('input, textarea, [contenteditable]')) {\n        e.preventDefault();\n        backtickCount++;\n        if (backtickCount >= 2) {\n          this.panic();\n          backtickCount = 0;\n        }\n        clearTimeout(backtickTimer);\n        backtickTimer = setTimeout(() => backtickCount = 0, 500);\n      }\n      \n      if (e.key === 'Escape') {\n        escCount++;\n        if (escCount >= 2) {\n          this.panic();\n          escCount = 0;\n        }\n        clearTimeout(escTimer);\n        escTimer = setTimeout(() => escCount = 0, 500);\n      }\n    });\n  },\n  \n  panic() {\n    window.location.href = this.currentPanicTarget.url;\n  },\n  \n  openInAboutBlank() {\n    const newWindow = window.open('about:blank', '_blank');\n    if (newWindow) {\n      const currentUrl = window.location.href;\n      newWindow.document.write(`\n        <!DOCTYPE html>\n        <html>\n        <head>\n          <title>${this.currentPanicTarget.title}</title>\n          <link rel=\"icon\" href=\"${this.currentPanicTarget.favicon}\">\n          <style>\n            * { margin: 0; padding: 0; }\n            body { overflow: hidden; }\n            iframe { width: 100vw; height: 100vh; border: none; }\n          </style>\n        </head>\n        <body>\n          <iframe src=\"${currentUrl}\"></iframe>\n        </body>\n        </html>\n      `);\n      newWindow.document.close();\n      window.location.href = this.currentPanicTarget.url;\n    }\n  },\n  \n  floodHistory(count = 50, customUrl = null) {\n    const baseUrls = [\n      'https://myapps.classlink.com/home',\n      'https://myapps.classlink.com/home#dashboard',\n      'https://myapps.classlink.com/home#apps',\n      'https://classroom.google.com',\n      'https://classroom.google.com/u/0/h',\n      'https://docs.google.com/document',\n      'https://drive.google.com/drive/my-drive',\n      'https://www.khanacademy.org',\n      'https://www.onenote.com/notebooks',\n      'https://outlook.office.com/mail'\n    ];\n    \n    // Add custom URL if provided\n    const urls = customUrl ? [customUrl, ...baseUrls] : baseUrls;\n    \n    for (let i = 0; i < count; i++) {\n      const randomUrl = urls[Math.floor(Math.random() * urls.length)];\n      history.pushState({}, '', window.location.pathname + '?t=' + Date.now() + i);\n    }\n    history.replaceState({}, '', window.location.pathname);\n    \n    return `Flooded history with ${count} entries`;\n  },\n  \n  openInBlobLink() {\n    const currentUrl = window.location.href;\n    const htmlContent = `\n      <!DOCTYPE html>\n      <html>\n      <head>\n        <title>${this.currentPanicTarget.title}</title>\n        <link rel=\"icon\" href=\"${this.currentPanicTarget.favicon}\">\n        <style>\n          * { margin: 0; padding: 0; box-sizing: border-box; }\n          body { overflow: hidden; }\n          iframe { width: 100vw; height: 100vh; border: none; }\n        </style>\n      </head>\n      <body>\n        <iframe src=\"${currentUrl}\"></iframe>\n      </body>\n      </html>\n    `;\n    \n    const blob = new Blob([htmlContent], { type: 'text/html' });\n    const blobUrl = URL.createObjectURL(blob);\n    window.open(blobUrl, '_blank');\n  },\n  \n  saveCustomFloodUrl() {\n    const input = document.getElementById('customFloodUrl');\n    if (input && input.value.trim()) {\n      this.customFloodUrl = input.value.trim();\n      localStorage.setItem('customFloodUrl', this.customFloodUrl);\n      alert('Custom flood URL saved!');\n    } else {\n      localStorage.removeItem('customFloodUrl');\n      this.customFloodUrl = '';\n      alert('Custom flood URL cleared!');\n    }\n  },\n  \n  floodWithCustomUrl() {\n    const input = document.getElementById('customFloodUrl');\n    const url = input ? input.value.trim() : this.customFloodUrl;\n    if (url) {\n      this.floodHistory(50, url);\n      alert(`History flooded with custom URL: ${url}`);\n    } else {\n      alert('Please enter a custom URL first!');\n    }\n  },\n  \n  manipulateHistory() {\n    const fakeEntries = [\n      { title: 'ClassLink Launchpad', url: 'https://myapps.classlink.com/home' },\n      { title: 'Google Classroom', url: 'https://classroom.google.com' },\n      { title: 'OneNote', url: 'https://www.onenote.com/notebooks' }\n    ];\n    \n    fakeEntries.forEach((entry, i) => {\n      setTimeout(() => {\n        history.pushState({ fake: true }, entry.title, window.location.pathname);\n      }, i * 10);\n    });\n    \n    setTimeout(() => {\n      history.replaceState({}, document.title, window.location.pathname);\n    }, fakeEntries.length * 10 + 50);\n    \n    return 'History manipulated successfully';\n  },\n  \n  activateDisguise() {\n    if (this.isActive) return;\n    this.isActive = true;\n    \n    document.title = this.currentDisguise.title;\n    this.setFavicon(this.currentDisguise.favicon);\n    \n    const overlay = document.createElement('div');\n    overlay.id = 'stealthOverlay';\n    overlay.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100vw;\n      height: 100vh;\n      background: #fff;\n      z-index: 999999;\n      display: flex;\n      flex-direction: column;\n      font-family: 'Google Sans', Roboto, Arial, sans-serif;\n    `;\n    \n    overlay.innerHTML = this.getDisguiseContent();\n    document.body.appendChild(overlay);\n    \n    const panicBtn = document.getElementById('panicButton');\n    if (panicBtn) panicBtn.style.display = 'none';\n    \n    document.addEventListener('keydown', this.deactivateHandler);\n  },\n  \n  deactivateHandler: function(e) {\n    if (e.key === 'Escape' || e.key === '`') {\n      StealthMode.deactivateDisguise();\n    }\n  },\n  \n  deactivateDisguise() {\n    this.isActive = false;\n    document.title = this.originalTitle;\n    this.setFavicon(this.originalFavicon);\n    \n    const overlay = document.getElementById('stealthOverlay');\n    if (overlay) overlay.remove();\n    \n    const panicBtn = document.getElementById('panicButton');\n    if (panicBtn) panicBtn.style.display = 'flex';\n    \n    document.removeEventListener('keydown', this.deactivateHandler);\n  },\n  \n  getDisguiseContent() {\n    const name = this.currentDisguise.name;\n    \n    if (name === 'Google Docs') {\n      return `\n        <div style=\"height: 64px; background: #1a73e8; display: flex; align-items: center; padding: 0 20px;\">\n          <img src=\"https://ssl.gstatic.com/docs/documents/images/kix-favicon7.ico\" style=\"width: 40px; margin-right: 15px;\">\n          <span style=\"color: white; font-size: 18px;\">Untitled document</span>\n        </div>\n        <div style=\"flex: 1; background: #f8f9fa; display: flex; justify-content: center; padding-top: 40px;\">\n          <div style=\"width: 816px; min-height: 1056px; background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); padding: 96px;\">\n            <p style=\"color: #5f6368; font-size: 14px;\">Start typing or paste (Ctrl + V) content here...</p>\n            <p style=\"color: #999; font-size: 12px; margin-top: 20px;\">Press ESC or \\` to return</p>\n          </div>\n        </div>\n      `;\n    }\n    \n    if (name === 'Google Classroom') {\n      return `\n        <div style=\"height: 64px; background: #1967d2; display: flex; align-items: center; padding: 0 20px;\">\n          <span style=\"color: white; font-size: 22px; font-weight: 500;\">Google Classroom</span>\n        </div>\n        <div style=\"flex: 1; background: #f1f3f4; padding: 24px;\">\n          <div style=\"max-width: 800px; margin: 0 auto;\">\n            <div style=\"background: white; border-radius: 8px; padding: 24px; margin-bottom: 16px; box-shadow: 0 1px 2px rgba(0,0,0,0.1);\">\n              <h2 style=\"margin: 0 0 8px; color: #1967d2;\">Welcome to Class</h2>\n              <p style=\"color: #5f6368; margin: 0;\">No assignments due today.</p>\n            </div>\n            <p style=\"color: #999; font-size: 12px; text-align: center;\">Press ESC or \\` to return</p>\n          </div>\n        </div>\n      `;\n    }\n    \n    return `\n      <div style=\"flex: 1; background: #f8f9fa; display: flex; align-items: center; justify-content: center; flex-direction: column;\">\n        <h1 style=\"color: #333;\">${this.currentDisguise.name}</h1>\n        <p style=\"color: #666;\">Loading...</p>\n        <p style=\"color: #999; font-size: 12px; margin-top: 20px;\">Press ESC or \\` to return</p>\n      </div>\n    `;\n  },\n  \n  createSettingsUI() {\n    const style = document.createElement('style');\n    style.textContent = `\n      #stealthSettings {\n        position: fixed;\n        bottom: 80px;\n        right: 20px;\n        background: var(--card, #1e1e2e);\n        border: 2px solid var(--accent, #45475a);\n        border-radius: 12px;\n        padding: 15px;\n        z-index: 99998;\n        display: none;\n        pointer-events: none;\n        min-width: 280px;\n        max-height: 80vh;\n        overflow-y: auto;\n        box-shadow: 0 4px 20px rgba(0,0,0,0.3);\n      }\n      #stealthSettings.active { display: block; pointer-events: auto; }\n      #stealthSettings h4 {\n        margin: 0 0 12px;\n        color: var(--primary, #89b4fa);\n        font-size: 14px;\n        border-bottom: 1px solid var(--accent, #45475a);\n        padding-bottom: 8px;\n      }\n      .stealth-option {\n        display: flex;\n        align-items: center;\n        padding: 8px;\n        margin: 4px 0;\n        border-radius: 6px;\n        cursor: pointer;\n        transition: background 0.2s;\n        color: var(--text, #cdd6f4);\n        font-size: 13px;\n      }\n      .stealth-option:hover {\n        background: var(--bg, #11111b);\n      }\n      .stealth-option.selected {\n        background: var(--primary, #89b4fa);\n        color: var(--bg, #11111b);\n      }\n      .stealth-option input {\n        margin-right: 8px;\n      }\n      .stealth-btn {\n        width: 100%;\n        padding: 10px;\n        margin: 5px 0;\n        border: none;\n        border-radius: 6px;\n        cursor: pointer;\n        font-size: 12px;\n        font-weight: 600;\n        transition: all 0.2s;\n      }\n      .stealth-btn.primary {\n        background: linear-gradient(135deg, var(--primary, #89b4fa), var(--accent, #cba6f7));\n        color: var(--bg, #11111b);\n      }\n      .stealth-btn.secondary {\n        background: var(--bg, #11111b);\n        color: var(--text, #cdd6f4);\n        border: 1px solid var(--accent, #45475a);\n      }\n      .stealth-btn:hover {\n        filter: brightness(1.1);\n        transform: translateY(-1px);\n      }\n      .stealth-section {\n        margin-bottom: 15px;\n      }\n      .stealth-divider {\n        height: 1px;\n        background: var(--accent, #45475a);\n        margin: 12px 0;\n      }\n    `;\n    document.head.appendChild(style);\n    \n    const settings = document.createElement('div');\n    settings.id = 'stealthSettings';\n    settings.innerHTML = `\n      <div class=\"stealth-section\">\n        <h4>ðŸš¨ Panic Target (Redirect To)</h4>\n        ${this.panicTargets.map(p => `\n          <label class=\"stealth-option ${p.name === this.currentPanicTarget.name ? 'selected' : ''}\">\n            <input type=\"radio\" name=\"panicTarget\" value=\"${p.name}\" ${p.name === this.currentPanicTarget.name ? 'checked' : ''}>\n            ${p.name}\n          </label>\n        `).join('')}\n      </div>\n      \n      <div class=\"stealth-divider\"></div>\n      \n      <div class=\"stealth-section\">\n        <h4>ðŸŽ­ Tab Cloak (Disguise Tab)</h4>\n        <label class=\"stealth-option ${!localStorage.getItem('tabCloakEnabled') ? 'selected' : ''}\">\n          <input type=\"radio\" name=\"tabCloak\" value=\"none\" ${!localStorage.getItem('tabCloakEnabled') ? 'checked' : ''}>\n          None (Original)\n        </label>\n        ${this.panicTargets.map(p => `\n          <label class=\"stealth-option ${localStorage.getItem('tabCloakName') === p.name ? 'selected' : ''}\">\n            <input type=\"radio\" name=\"tabCloak\" value=\"${p.name}\" ${localStorage.getItem('tabCloakName') === p.name ? 'checked' : ''}>\n            ${p.name}\n          </label>\n        `).join('')}\n      </div>\n      \n      <div class=\"stealth-divider\"></div>\n      \n      <div class=\"stealth-section\">\n        <h4>ðŸ”§ Stealth Tools</h4>\n        <button class=\"stealth-btn primary\" onclick=\"StealthMode.openInAboutBlank()\">\n          ðŸ“„ Open in about:blank\n        </button>\n        <button class=\"stealth-btn primary\" onclick=\"StealthMode.openInBlobLink()\">\n          ðŸ”— Open in Blob Link\n        </button>\n        <button class=\"stealth-btn secondary\" onclick=\"StealthMode.floodHistory(); alert('History flooded!')\">\n          ðŸ“š Flood History (50 entries)\n        </button>\n        <button class=\"stealth-btn secondary\" onclick=\"StealthMode.manipulateHistory(); alert('History manipulated!')\">\n          ðŸ”„ Manipulate History\n        </button>\n      </div>\n      \n      <div class=\"stealth-divider\"></div>\n      \n      <div class=\"stealth-section\">\n        <h4>ðŸŒŠ Custom Flood URL</h4>\n        <input type=\"text\" id=\"customFloodUrl\" placeholder=\"Enter custom URL (e.g. Flood Escape link)\" \n          value=\"${this.customFloodUrl}\"\n          style=\"width: 100%; padding: 8px; border-radius: 6px; border: 1px solid var(--accent, #45475a); background: var(--bg, #11111b); color: var(--text, #cdd6f4); font-size: 12px; margin-bottom: 8px;\">\n        <button class=\"stealth-btn secondary\" onclick=\"StealthMode.saveCustomFloodUrl()\">\n          ðŸ’¾ Save Custom URL\n        </button>\n        <button class=\"stealth-btn secondary\" onclick=\"StealthMode.floodWithCustomUrl()\">\n          ðŸŒŠ Flood with Custom URL\n        </button>\n      </div>\n      \n      <div class=\"stealth-divider\"></div>\n      \n      <div class=\"stealth-section\">\n        <h4>ðŸŽ¨ Quick Disguise (Overlay)</h4>\n        ${this.disguises.map(d => `\n          <label class=\"stealth-option\" onclick=\"StealthMode.currentDisguise = StealthMode.disguises.find(x => x.name === '${d.name}'); StealthMode.activateDisguise();\">\n            ${d.name}\n          </label>\n        `).join('')}\n      </div>\n    `;\n    document.body.appendChild(settings);\n    \n    settings.querySelectorAll('input[name=\"panicTarget\"]').forEach(input => {\n      input.addEventListener('change', (e) => {\n        this.currentPanicTarget = this.panicTargets.find(p => p.name === e.target.value);\n        localStorage.setItem('panicTarget', e.target.value);\n        settings.querySelectorAll('input[name=\"panicTarget\"]').forEach(i => {\n          i.parentElement.classList.toggle('selected', i.checked);\n        });\n      });\n    });\n    \n    settings.querySelectorAll('input[name=\"tabCloak\"]').forEach(input => {\n      input.addEventListener('change', (e) => {\n        const value = e.target.value;\n        if (value === 'none') {\n          localStorage.removeItem('tabCloakEnabled');\n          localStorage.removeItem('tabCloakName');\n          document.title = this.originalTitle;\n          this.setFavicon(this.originalFavicon);\n        } else {\n          const target = this.panicTargets.find(p => p.name === value);\n          if (target) {\n            localStorage.setItem('tabCloakEnabled', 'true');\n            localStorage.setItem('tabCloakName', value);\n            document.title = target.title;\n            this.setFavicon(target.favicon);\n          }\n        }\n        settings.querySelectorAll('input[name=\"tabCloak\"]').forEach(i => {\n          i.parentElement.classList.toggle('selected', i.checked);\n        });\n      });\n    });\n    \n    const panicBtn = document.getElementById('panicButton');\n    if (panicBtn) {\n      panicBtn.addEventListener('contextmenu', (e) => {\n        e.preventDefault();\n        settings.classList.toggle('active');\n      });\n      \n      document.addEventListener('click', (e) => {\n        if (!settings.contains(e.target) && e.target !== panicBtn) {\n          settings.classList.remove('active');\n        }\n      });\n    }\n  },\n  \n  applyTabCloak() {\n    if (localStorage.getItem('tabCloakEnabled') === 'true') {\n      const cloakName = localStorage.getItem('tabCloakName');\n      const target = this.panicTargets.find(p => p.name === cloakName);\n      if (target) {\n        document.title = target.title;\n        this.setFavicon(target.favicon);\n      }\n    }\n  }\n};\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  if (window.location.pathname.includes('/private/')) {\n    StealthMode.init();\n  }\n});\n","path":null,"size_bytes":18706,"size_tokens":null},"backend/routes/preferences.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst JWT_SECRET = 'real_user_auth_secret_2025';\n\nfunction authenticateToken(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n  \n  try {\n    req.user = jwt.verify(token, JWT_SECRET);\n    next();\n  } catch {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\nrouter.get('/', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  \n  db.get('SELECT * FROM user_preferences WHERE user_id = ?', [userId], (err, prefs) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    \n    if (!prefs) {\n      prefs = {\n        theme_mode: 'manual',\n        auto_theme_schedule: null,\n        tab_cloak_enabled: false,\n        tab_cloak_title: null,\n        tab_cloak_favicon: null,\n        panic_key: '`'\n      };\n    }\n    \n    res.json(prefs);\n  });\n});\n\nrouter.put('/', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  const { \n    theme_mode, \n    auto_theme_schedule, \n    tab_cloak_enabled, \n    tab_cloak_title, \n    tab_cloak_favicon,\n    panic_key \n  } = req.body;\n  \n  db.run(`\n    INSERT INTO user_preferences (user_id, theme_mode, auto_theme_schedule, tab_cloak_enabled, tab_cloak_title, tab_cloak_favicon, panic_key, updated_at)\n    VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)\n    ON CONFLICT(user_id) DO UPDATE SET\n      theme_mode = COALESCE(excluded.theme_mode, user_preferences.theme_mode),\n      auto_theme_schedule = COALESCE(excluded.auto_theme_schedule, user_preferences.auto_theme_schedule),\n      tab_cloak_enabled = COALESCE(excluded.tab_cloak_enabled, user_preferences.tab_cloak_enabled),\n      tab_cloak_title = COALESCE(excluded.tab_cloak_title, user_preferences.tab_cloak_title),\n      tab_cloak_favicon = COALESCE(excluded.tab_cloak_favicon, user_preferences.tab_cloak_favicon),\n      panic_key = COALESCE(excluded.panic_key, user_preferences.panic_key),\n      updated_at = CURRENT_TIMESTAMP\n  `, [\n    userId,\n    theme_mode || 'manual',\n    auto_theme_schedule || null,\n    tab_cloak_enabled ? 1 : 0,\n    tab_cloak_title || null,\n    tab_cloak_favicon || null,\n    panic_key || '`'\n  ], function(err) {\n    if (err) return res.status(500).json({ error: 'Failed to save preferences' });\n    res.json({ success: true, message: 'Preferences saved' });\n  });\n});\n\nrouter.get('/theme-suggestion', authenticateToken, (req, res) => {\n  const userId = req.user.userId;\n  \n  db.get('SELECT theme_mode, auto_theme_schedule FROM user_preferences WHERE user_id = ?', \n    [userId], (err, prefs) => {\n      if (!prefs || prefs.theme_mode === 'manual') {\n        return res.json({ suggestion: null });\n      }\n      \n      const hour = new Date().getHours();\n      let theme = 'ocean';\n      \n      if (prefs.theme_mode === 'system') {\n        return res.json({ suggestion: 'system' });\n      }\n      \n      if (prefs.theme_mode === 'time') {\n        if (hour >= 6 && hour < 12) {\n          theme = 'cloudy';\n        } else if (hour >= 12 && hour < 18) {\n          theme = 'ocean';\n        } else if (hour >= 18 && hour < 21) {\n          theme = 'eclipse';\n        } else {\n          theme = 'gaming';\n        }\n      }\n      \n      if (prefs.auto_theme_schedule) {\n        try {\n          const schedule = JSON.parse(prefs.auto_theme_schedule);\n          for (const slot of schedule) {\n            if (hour >= slot.start && hour < slot.end) {\n              theme = slot.theme;\n              break;\n            }\n          }\n        } catch (e) {}\n      }\n      \n      res.json({ suggestion: theme });\n    });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":3764,"size_tokens":null},"frontend/js/auto-theme.js":{"content":"const AutoTheme = {\n  async init() {\n    await this.loadPreferences();\n    this.checkAndApply();\n    \n    if (window.matchMedia) {\n      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {\n        this.checkAndApply();\n      });\n    }\n    \n    setInterval(() => this.checkAndApply(), 60000);\n  },\n  \n  async loadPreferences() {\n    try {\n      const token = localStorage.getItem('authToken') || localStorage.getItem('userToken');\n      if (!token) return;\n      \n      const res = await fetch('/api/preferences', {\n        headers: { 'Authorization': `Bearer ${token}` }\n      });\n      \n      if (res.ok) {\n        const prefs = await res.json();\n        if (prefs.theme_mode) {\n          localStorage.setItem('themeMode', prefs.theme_mode);\n        }\n        if (prefs.auto_theme_schedule) {\n          localStorage.setItem('themeSchedule', prefs.auto_theme_schedule);\n        }\n      }\n    } catch (e) {\n      console.log('Failed to load preferences:', e);\n    }\n  },\n  \n  async checkAndApply() {\n    const mode = localStorage.getItem('themeMode') || 'manual';\n    \n    if (mode === 'manual') return;\n    \n    if (mode === 'system') {\n      this.applySystemTheme();\n      return;\n    }\n    \n    if (mode === 'time') {\n      this.applyTimeBasedTheme();\n      return;\n    }\n    \n    try {\n      const token = localStorage.getItem('authToken') || localStorage.getItem('userToken');\n      if (!token) return;\n      \n      const res = await fetch('/api/preferences/theme-suggestion', {\n        headers: { 'Authorization': `Bearer ${token}` }\n      });\n      const data = await res.json();\n      \n      if (data.suggestion && data.suggestion !== 'system') {\n        this.setTheme(data.suggestion);\n      } else if (data.suggestion === 'system') {\n        this.applySystemTheme();\n      }\n    } catch (e) {\n      console.log('Auto theme check failed:', e);\n    }\n  },\n  \n  applySystemTheme() {\n    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n    const theme = prefersDark ? 'gaming' : 'cloudy';\n    this.setTheme(theme);\n  },\n  \n  applyTimeBasedTheme() {\n    const hour = new Date().getHours();\n    let theme;\n    \n    if (hour >= 6 && hour < 12) {\n      theme = 'cloudy';\n    } else if (hour >= 12 && hour < 18) {\n      theme = 'ocean';\n    } else if (hour >= 18 && hour < 21) {\n      theme = 'eclipse';\n    } else {\n      theme = 'gaming';\n    }\n    \n    this.setTheme(theme);\n  },\n  \n  setTheme(themeName) {\n    const currentTheme = localStorage.getItem('selectedTheme');\n    if (currentTheme === themeName) return;\n    \n    localStorage.setItem('selectedTheme', themeName);\n    \n    if (window.applyTheme) {\n      window.applyTheme(themeName);\n    } else {\n      const selector = document.getElementById('themeSelector');\n      if (selector) {\n        selector.value = themeName;\n        selector.dispatchEvent(new Event('change'));\n      }\n    }\n  },\n  \n  async setMode(mode) {\n    localStorage.setItem('themeMode', mode);\n    \n    try {\n      const token = localStorage.getItem('authToken') || localStorage.getItem('userToken');\n      if (token) {\n        await fetch('/api/preferences', {\n          method: 'PUT',\n          headers: {\n            'Authorization': `Bearer ${token}`,\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({ theme_mode: mode })\n        });\n      }\n    } catch (e) {\n      console.log('Failed to save theme mode:', e);\n    }\n    \n    this.checkAndApply();\n  }\n};\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  if (window.location.pathname.includes('/private/')) {\n    AutoTheme.init();\n  }\n});\n","path":null,"size_bytes":3662,"size_tokens":null},"backend/routes/polls.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst JWT_SECRET = 'real_user_auth_secret_2025';\n\nfunction authenticateToken(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n  \n  try {\n    req.user = jwt.verify(token, JWT_SECRET);\n    next();\n  } catch {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\nfunction checkServerMembership(userId, serverId, callback) {\n  if (!serverId) return callback(null, true);\n  db.get('SELECT id FROM server_members WHERE server_id = ? AND user_id = ?',\n    [serverId, userId], (err, member) => {\n      callback(err, !!member);\n    });\n}\n\nrouter.post('/', authenticateToken, (req, res) => {\n  const { question, options, channel_id, server_id, poll_type, is_anonymous, expires_in_hours } = req.body;\n  const creatorId = req.user.userId;\n  \n  if (!question || !options || options.length < 2) {\n    return res.status(400).json({ error: 'Question and at least 2 options required' });\n  }\n  \n  if (options.length > 10) {\n    return res.status(400).json({ error: 'Maximum 10 options allowed' });\n  }\n  \n  checkServerMembership(creatorId, server_id, (err, isMember) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!isMember) return res.status(403).json({ error: 'Not a member of this server' });\n    \n    let expiresAt = null;\n    if (expires_in_hours) {\n      const hours = parseInt(expires_in_hours);\n      if (hours > 0) {\n        expiresAt = new Date(Date.now() + hours * 60 * 60 * 1000).toISOString();\n      }\n    }\n    \n    db.run(`\n      INSERT INTO polls (channel_id, server_id, creator_id, question, poll_type, is_anonymous, expires_at)\n      VALUES (?, ?, ?, ?, ?, ?, ?)\n    `, [channel_id || null, server_id || null, creatorId, question, poll_type || 'single', is_anonymous ? 1 : 0, expiresAt],\n    function(err) {\n      if (err) return res.status(500).json({ error: 'Failed to create poll' });\n      \n      const pollId = this.lastID;\n      \n      const insertOptions = options.map((opt, idx) => {\n        return new Promise((resolve, reject) => {\n          db.run('INSERT INTO poll_options (poll_id, option_text, position) VALUES (?, ?, ?)',\n            [pollId, opt, idx], (err) => {\n              if (err) reject(err);\n              else resolve();\n            });\n        });\n      });\n      \n      Promise.all(insertOptions)\n        .then(() => {\n          res.json({ success: true, pollId, message: 'Poll created' });\n        })\n        .catch(err => {\n          db.run('DELETE FROM polls WHERE id = ?', [pollId]);\n          res.status(500).json({ error: 'Failed to create poll options' });\n        });\n    });\n  });\n});\n\nrouter.get('/channel/:channelId', authenticateToken, (req, res) => {\n  const channelId = parseInt(req.params.channelId);\n  \n  db.all(`\n    SELECT p.*, u.username as creator_name,\n           (SELECT COUNT(*) FROM poll_votes WHERE poll_id = p.id) as total_votes\n    FROM polls p\n    JOIN users u ON p.creator_id = u.id\n    WHERE p.channel_id = ? AND p.is_closed = 0\n    ORDER BY p.created_at DESC\n  `, [channelId], (err, polls) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json(polls || []);\n  });\n});\n\nrouter.get('/:pollId', authenticateToken, (req, res) => {\n  const pollId = parseInt(req.params.pollId);\n  const userId = req.user.userId;\n  \n  db.get(`\n    SELECT p.*, u.username as creator_name\n    FROM polls p\n    JOIN users u ON p.creator_id = u.id\n    WHERE p.id = ?\n  `, [pollId], (err, poll) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!poll) return res.status(404).json({ error: 'Poll not found' });\n    \n    db.all('SELECT * FROM poll_options WHERE poll_id = ? ORDER BY position', [pollId], (err, options) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      \n      db.all('SELECT option_id, COUNT(*) as votes FROM poll_votes WHERE poll_id = ? GROUP BY option_id',\n        [pollId], (err, voteCounts) => {\n          if (err) return res.status(500).json({ error: 'Database error' });\n          \n          db.all('SELECT option_id FROM poll_votes WHERE poll_id = ? AND user_id = ?',\n            [pollId, userId], (err, userVotes) => {\n              const voteMap = {};\n              (voteCounts || []).forEach(v => voteMap[v.option_id] = v.votes);\n              \n              const optionsWithVotes = (options || []).map(opt => ({\n                ...opt,\n                votes: voteMap[opt.id] || 0,\n                voted: (userVotes || []).some(uv => uv.option_id === opt.id)\n              }));\n              \n              res.json({\n                ...poll,\n                options: optionsWithVotes,\n                total_votes: optionsWithVotes.reduce((sum, o) => sum + o.votes, 0),\n                user_voted: (userVotes || []).length > 0\n              });\n            });\n        });\n    });\n  });\n});\n\nrouter.post('/:pollId/vote', authenticateToken, (req, res) => {\n  const pollId = parseInt(req.params.pollId);\n  const userId = req.user.userId;\n  const { option_id } = req.body;\n  \n  if (!option_id) {\n    return res.status(400).json({ error: 'Option ID required' });\n  }\n  \n  db.get('SELECT * FROM polls WHERE id = ?', [pollId], (err, poll) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!poll) return res.status(404).json({ error: 'Poll not found' });\n    if (poll.is_closed) return res.status(400).json({ error: 'Poll is closed' });\n    \n    if (poll.expires_at && new Date(poll.expires_at) < new Date()) {\n      return res.status(400).json({ error: 'Poll has expired' });\n    }\n    \n    checkServerMembership(userId, poll.server_id, (err, isMember) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      if (!isMember) return res.status(403).json({ error: 'Not a member of this server' });\n      \n      if (poll.poll_type === 'single') {\n        db.get('SELECT id FROM poll_votes WHERE poll_id = ? AND user_id = ?',\n          [pollId, userId], (err, existingVote) => {\n            if (existingVote) {\n              return res.status(400).json({ error: 'Already voted on this poll' });\n            }\n            castVote();\n          });\n      } else {\n        db.get('SELECT id FROM poll_votes WHERE poll_id = ? AND user_id = ? AND option_id = ?',\n          [pollId, userId, option_id], (err, existingVote) => {\n            if (existingVote) {\n              return res.status(400).json({ error: 'Already voted for this option' });\n            }\n            castVote();\n          });\n      }\n    });\n    \n    function castVote() {\n      db.get('SELECT id FROM poll_options WHERE id = ? AND poll_id = ?',\n        [option_id, pollId], (err, option) => {\n          if (!option) return res.status(400).json({ error: 'Invalid option' });\n          \n          db.run('INSERT INTO poll_votes (poll_id, option_id, user_id) VALUES (?, ?, ?)',\n            [pollId, option_id, userId], function(err) {\n              if (err) return res.status(500).json({ error: 'Failed to vote' });\n              res.json({ success: true, message: 'Vote recorded' });\n            });\n        });\n    }\n  });\n});\n\nrouter.delete('/:pollId/vote', authenticateToken, (req, res) => {\n  const pollId = parseInt(req.params.pollId);\n  const userId = req.user.userId;\n  const { option_id } = req.body;\n  \n  db.run('DELETE FROM poll_votes WHERE poll_id = ? AND user_id = ? AND option_id = ?',\n    [pollId, userId, option_id || 0], function(err) {\n      if (err) return res.status(500).json({ error: 'Failed to remove vote' });\n      res.json({ success: true, message: 'Vote removed' });\n    });\n});\n\nrouter.post('/:pollId/close', authenticateToken, (req, res) => {\n  const pollId = parseInt(req.params.pollId);\n  const userId = req.user.userId;\n  \n  db.get('SELECT * FROM polls WHERE id = ?', [pollId], (err, poll) => {\n    if (!poll) return res.status(404).json({ error: 'Poll not found' });\n    if (poll.creator_id !== userId) {\n      return res.status(403).json({ error: 'Only creator can close poll' });\n    }\n    \n    db.run('UPDATE polls SET is_closed = TRUE WHERE id = ?', [pollId], function(err) {\n      if (err) return res.status(500).json({ error: 'Failed to close poll' });\n      res.json({ success: true, message: 'Poll closed' });\n    });\n  });\n});\n\nrouter.delete('/:pollId', authenticateToken, (req, res) => {\n  const pollId = parseInt(req.params.pollId);\n  const userId = req.user.userId;\n  \n  db.get('SELECT * FROM polls WHERE id = ?', [pollId], (err, poll) => {\n    if (!poll) return res.status(404).json({ error: 'Poll not found' });\n    \n    db.get('SELECT role FROM users WHERE id = ?', [userId], (err, user) => {\n      if (poll.creator_id !== userId && user?.role !== 'admin') {\n        return res.status(403).json({ error: 'Permission denied' });\n      }\n      \n      db.run('DELETE FROM poll_votes WHERE poll_id = ?', [pollId], () => {\n        db.run('DELETE FROM poll_options WHERE poll_id = ?', [pollId], () => {\n          db.run('DELETE FROM polls WHERE id = ?', [pollId], function(err) {\n            if (err) return res.status(500).json({ error: 'Failed to delete poll' });\n            res.json({ success: true, message: 'Poll deleted' });\n          });\n        });\n      });\n    });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":9419,"size_tokens":null},"frontend/js/quick-switcher.js":{"content":"const QuickSwitcher = {\n  isOpen: false,\n  results: [],\n  selectedIndex: 0,\n  \n  init() {\n    this.createUI();\n    this.setupKeyboardShortcuts();\n  },\n  \n  createUI() {\n    const style = document.createElement('style');\n    style.textContent = `\n      #quickSwitcher {\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background: rgba(0,0,0,0.7);\n        z-index: 100000;\n        display: none;\n        align-items: flex-start;\n        justify-content: center;\n        padding-top: 15vh;\n      }\n      #quickSwitcher.active { display: flex; }\n      .qs-container {\n        background: var(--card, #1e1e2e);\n        border-radius: 12px;\n        width: 90%;\n        max-width: 600px;\n        box-shadow: 0 10px 40px rgba(0,0,0,0.5);\n        overflow: hidden;\n      }\n      .qs-input-wrap {\n        padding: 16px;\n        border-bottom: 1px solid var(--accent, #45475a);\n      }\n      .qs-input {\n        width: 100%;\n        padding: 12px 16px;\n        background: var(--bg, #11111b);\n        border: 2px solid var(--accent, #45475a);\n        border-radius: 8px;\n        color: var(--text, #cdd6f4);\n        font-size: 16px;\n        outline: none;\n      }\n      .qs-input:focus {\n        border-color: var(--primary, #89b4fa);\n      }\n      .qs-input::placeholder {\n        color: var(--text-light, #6c7086);\n      }\n      .qs-results {\n        max-height: 400px;\n        overflow-y: auto;\n      }\n      .qs-section {\n        padding: 8px 16px;\n      }\n      .qs-section-title {\n        font-size: 11px;\n        font-weight: 600;\n        color: var(--text-light, #6c7086);\n        text-transform: uppercase;\n        margin-bottom: 8px;\n      }\n      .qs-item {\n        display: flex;\n        align-items: center;\n        padding: 10px 12px;\n        border-radius: 6px;\n        cursor: pointer;\n        transition: background 0.1s;\n        gap: 12px;\n      }\n      .qs-item:hover, .qs-item.selected {\n        background: var(--primary, #89b4fa);\n        color: var(--bg, #11111b);\n      }\n      .qs-item-icon {\n        font-size: 20px;\n        width: 32px;\n        text-align: center;\n      }\n      .qs-item-info {\n        flex: 1;\n      }\n      .qs-item-name {\n        font-weight: 500;\n        font-size: 14px;\n      }\n      .qs-item-desc {\n        font-size: 12px;\n        opacity: 0.7;\n      }\n      .qs-item-badge {\n        font-size: 11px;\n        padding: 2px 8px;\n        border-radius: 10px;\n        background: var(--accent, #45475a);\n      }\n      .qs-empty {\n        padding: 40px;\n        text-align: center;\n        color: var(--text-light, #6c7086);\n      }\n      .qs-hint {\n        padding: 12px 16px;\n        background: var(--bg, #11111b);\n        font-size: 12px;\n        color: var(--text-light, #6c7086);\n        display: flex;\n        gap: 20px;\n      }\n      .qs-hint kbd {\n        background: var(--accent, #45475a);\n        padding: 2px 6px;\n        border-radius: 4px;\n        font-family: monospace;\n      }\n    `;\n    document.head.appendChild(style);\n    \n    const overlay = document.createElement('div');\n    overlay.id = 'quickSwitcher';\n    overlay.innerHTML = `\n      <div class=\"qs-container\">\n        <div class=\"qs-input-wrap\">\n          <input type=\"text\" class=\"qs-input\" placeholder=\"Search users, servers, games, pages...\" autofocus>\n        </div>\n        <div class=\"qs-results\"></div>\n        <div class=\"qs-hint\">\n          <span><kbd>â†‘â†“</kbd> Navigate</span>\n          <span><kbd>Enter</kbd> Select</span>\n          <span><kbd>Esc</kbd> Close</span>\n        </div>\n      </div>\n    `;\n    document.body.appendChild(overlay);\n    \n    const input = overlay.querySelector('.qs-input');\n    input.addEventListener('input', (e) => this.search(e.target.value));\n    input.addEventListener('keydown', (e) => this.handleKeydown(e));\n    \n    overlay.addEventListener('click', (e) => {\n      if (e.target === overlay) this.close();\n    });\n  },\n  \n  setupKeyboardShortcuts() {\n    document.addEventListener('keydown', (e) => {\n      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {\n        e.preventDefault();\n        this.toggle();\n      }\n      if (e.key === '/' && !e.target.matches('input, textarea, [contenteditable]')) {\n        e.preventDefault();\n        this.open();\n      }\n    });\n  },\n  \n  toggle() {\n    this.isOpen ? this.close() : this.open();\n  },\n  \n  open() {\n    this.isOpen = true;\n    const overlay = document.getElementById('quickSwitcher');\n    overlay.classList.add('active');\n    const input = overlay.querySelector('.qs-input');\n    input.value = '';\n    input.focus();\n    this.search('');\n  },\n  \n  close() {\n    this.isOpen = false;\n    document.getElementById('quickSwitcher').classList.remove('active');\n  },\n  \n  async search(query) {\n    const results = [];\n    const q = query.toLowerCase().trim();\n    \n    const pages = [\n      { name: 'Dashboard', icon: 'ðŸ ', desc: 'Home page', url: '/private/dashboard.html', type: 'page' },\n      { name: 'Games', icon: 'ðŸŽ®', desc: 'Play games', url: '/private/games.html', type: 'page' },\n      { name: 'Chat', icon: 'ðŸ’¬', desc: 'Chat & servers', url: '/private/chat.html', type: 'page' },\n      { name: 'Profile', icon: 'ðŸ‘¤', desc: 'Your profile', url: '/private/profile.html', type: 'page' },\n      { name: 'Shop', icon: 'ðŸ›’', desc: 'Cosmetic shop', url: '/private/shop.html', type: 'page' },\n      { name: 'Shortcuts', icon: 'âŒ¨ï¸', desc: 'Keyboard shortcuts', url: '/private/shortcuts.html', type: 'page' },\n      { name: 'Movies', icon: 'ðŸŽ¬', desc: 'Educational media', url: '/private/movies.html', type: 'page' },\n      { name: 'Proxy', icon: 'ðŸŒ', desc: 'Proxy tools', url: '/private/proxy.html', type: 'page' }\n    ];\n    \n    const commands = [\n      { name: 'Panic Mode', icon: 'ðŸ›¡ï¸', desc: 'Activate stealth mode', action: () => StealthMode.activate(), type: 'command' },\n      { name: 'Toggle Theme', icon: 'ðŸŽ¨', desc: 'Switch dark/light mode', action: () => this.toggleTheme(), type: 'command' },\n      { name: 'Logout', icon: 'ðŸšª', desc: 'Sign out of your account', action: () => { localStorage.clear(); location.href = '/auth'; }, type: 'command' },\n      { name: 'Clear Cache', icon: 'ðŸ—‘ï¸', desc: 'Clear local storage', action: () => { if(confirm('Clear all cached data?')) localStorage.clear(); }, type: 'command' }\n    ];\n    \n    if (q === '') {\n      results.push(...pages.slice(0, 4));\n      results.push(...commands.slice(0, 2));\n    } else {\n      const matchPages = pages.filter(p => \n        p.name.toLowerCase().includes(q) || p.desc.toLowerCase().includes(q)\n      );\n      const matchCommands = commands.filter(c => \n        c.name.toLowerCase().includes(q) || c.desc.toLowerCase().includes(q)\n      );\n      results.push(...matchPages, ...matchCommands);\n      \n      if (q.length >= 2) {\n        try {\n          const token = localStorage.getItem('authToken') || localStorage.getItem('userToken');\n          \n          const [usersRes, serversRes] = await Promise.all([\n            fetch(`/api/users/search-all?q=${encodeURIComponent(q)}`, {\n              headers: { 'Authorization': `Bearer ${token}` }\n            }).catch(() => ({ ok: false })),\n            fetch('/api/servers', {\n              headers: { 'Authorization': `Bearer ${token}` }\n            }).catch(() => ({ ok: false }))\n          ]);\n          \n          if (usersRes.ok) {\n            const users = await usersRes.json();\n            results.push(...(users || []).slice(0, 5).map(u => ({\n              name: u.username,\n              icon: 'ðŸ‘¤',\n              desc: u.is_online ? 'Online' : 'Offline',\n              type: 'user',\n              action: () => this.openUserProfile(u.id)\n            })));\n          }\n          \n          if (serversRes.ok) {\n            const servers = await serversRes.json();\n            const matchServers = (servers || []).filter(s => \n              s.name.toLowerCase().includes(q)\n            ).slice(0, 5);\n            results.push(...matchServers.map(s => ({\n              name: s.name,\n              icon: 'ðŸ“¡',\n              desc: `${s.member_count || 0} members`,\n              type: 'server',\n              action: () => this.openServer(s.id)\n            })));\n          }\n        } catch (e) {\n          console.log('Search API error:', e);\n        }\n      }\n    }\n    \n    this.results = results;\n    this.selectedIndex = 0;\n    this.renderResults();\n  },\n  \n  renderResults() {\n    const container = document.querySelector('.qs-results');\n    \n    if (this.results.length === 0) {\n      container.innerHTML = '<div class=\"qs-empty\">No results found</div>';\n      return;\n    }\n    \n    const grouped = {};\n    this.results.forEach((r, i) => {\n      const type = r.type || 'other';\n      if (!grouped[type]) grouped[type] = [];\n      grouped[type].push({ ...r, index: i });\n    });\n    \n    const typeLabels = {\n      page: 'Pages',\n      command: 'Commands',\n      user: 'Users',\n      server: 'Servers',\n      game: 'Games'\n    };\n    \n    container.innerHTML = Object.entries(grouped).map(([type, items]) => `\n      <div class=\"qs-section\">\n        <div class=\"qs-section-title\">${typeLabels[type] || type}</div>\n        ${items.map(item => `\n          <div class=\"qs-item ${item.index === this.selectedIndex ? 'selected' : ''}\" data-index=\"${item.index}\">\n            <span class=\"qs-item-icon\">${item.icon}</span>\n            <div class=\"qs-item-info\">\n              <div class=\"qs-item-name\">${item.name}</div>\n              <div class=\"qs-item-desc\">${item.desc || ''}</div>\n            </div>\n          </div>\n        `).join('')}\n      </div>\n    `).join('');\n    \n    container.querySelectorAll('.qs-item').forEach(el => {\n      el.addEventListener('click', () => {\n        this.selectedIndex = parseInt(el.dataset.index);\n        this.execute();\n      });\n    });\n  },\n  \n  handleKeydown(e) {\n    if (e.key === 'ArrowDown') {\n      e.preventDefault();\n      this.selectedIndex = Math.min(this.selectedIndex + 1, this.results.length - 1);\n      this.renderResults();\n    } else if (e.key === 'ArrowUp') {\n      e.preventDefault();\n      this.selectedIndex = Math.max(this.selectedIndex - 1, 0);\n      this.renderResults();\n    } else if (e.key === 'Enter') {\n      e.preventDefault();\n      this.execute();\n    } else if (e.key === 'Escape') {\n      this.close();\n    }\n  },\n  \n  execute() {\n    const item = this.results[this.selectedIndex];\n    if (!item) return;\n    \n    this.close();\n    \n    if (item.url) {\n      window.location.href = item.url;\n    } else if (item.action) {\n      item.action();\n    }\n  },\n  \n  toggleTheme() {\n    const current = localStorage.getItem('selectedTheme') || 'ocean';\n    const themes = ['ocean', 'arcade', 'candy', 'eclipse', 'matrix'];\n    const next = themes[(themes.indexOf(current) + 1) % themes.length];\n    localStorage.setItem('selectedTheme', next);\n    if (window.applyTheme) window.applyTheme(next);\n  },\n  \n  openUserProfile(userId) {\n    if (window.viewUserProfile) {\n      window.viewUserProfile(userId);\n    } else {\n      window.location.href = `/private/chat.html?viewUser=${userId}`;\n    }\n  },\n  \n  openServer(serverId) {\n    window.location.href = `/private/chat.html?server=${serverId}`;\n  }\n};\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  if (window.location.pathname.includes('/private/')) {\n    QuickSwitcher.init();\n  }\n});\n","path":null,"size_bytes":11362,"size_tokens":null},"frontend/baremod/V3.d.ts":{"content":"import type { BareHeaders, BareMethod } from \"./BareTypes.js\";\nimport { Client } from \"./Client.js\";\nimport type { BareTransport, TransferrableResponse } from \"@mercuryworkshop/bare-mux\";\nexport default class ClientV3 extends Client implements BareTransport {\n    ws: URL;\n    http: URL;\n    meta(): {};\n    constructor(server: URL);\n    ready: boolean;\n    init(): Promise<void>;\n    connect(url: URL, protocols: string[], requestHeaders: BareHeaders, onopen: (protocol: string) => void, onmessage: (data: Blob | ArrayBuffer | string) => void, onclose: (code: number, reason: string) => void, onerror: (error: string) => void): [(data: Blob | ArrayBuffer | string) => void, (code: number, reason: string) => void];\n    request(remote: URL, method: BareMethod, body: BodyInit | null, headers: BareHeaders, signal: AbortSignal | undefined): Promise<TransferrableResponse>;\n    private readBareResponse;\n    createBareHeaders(remote: URL, bareHeaders: BareHeaders, forwardHeaders?: string[], passHeaders?: string[], passStatus?: number[]): Headers;\n}\n","path":null,"size_bytes":1049,"size_tokens":null},"frontend/baremod/Client.d.ts":{"content":"import type { BareHeaders, BareWebSocketMeta } from \"./BareTypes.js\";\nexport declare const statusEmpty: number[];\nexport declare const statusRedirect: number[];\nexport interface BareErrorBody {\n    code: string;\n    id: string;\n    message?: string;\n    stack?: string;\n}\nexport declare class BareError extends Error {\n    status: number;\n    body: BareErrorBody;\n    constructor(status: number, body: BareErrorBody);\n}\nexport type MetaCallback = (meta: BareWebSocketMeta) => void;\nexport type ReadyStateCallback = (readyState: number) => void;\nexport type WebSocketImpl = {\n    new (...args: ConstructorParameters<typeof WebSocket>): WebSocket;\n};\nexport type GetRequestHeadersCallback = () => Promise<BareHeaders>;\nexport declare abstract class Client {\n    protected base: URL;\n    /**\n     *\n     * @param version Version provided by extension\n     * @param server Bare Server URL provided by BareClient\n     */\n    constructor(version: number, server: URL);\n}\n","path":null,"size_bytes":965,"size_tokens":null},"frontend/baremod/BareTypes.d.ts":{"content":"export type BareMethod = \"GET\" | \"POST\" | \"DELETE\" | \"OPTIONS\" | \"PUT\" | \"PATCH\" | \"UPDATE\" | string;\nexport type BareCache = \"default\" | \"no-store\" | \"reload\" | \"no-cache\" | \"force-cache\" | \"only-if-cached\" | string;\nexport interface BareWebSocketMeta {\n    protocol: string;\n    setCookies: string[];\n}\nexport type BareHTTPProtocol = \"blob:\" | \"http:\" | \"https:\" | string;\nexport type BareWSProtocol = \"ws:\" | \"wss:\" | string;\nexport declare const maxRedirects = 20;\nexport type BareHeaders = Record<string, string | string[]>;\n/**\n * A Response with additional properties.\n */\nexport interface BareResponse extends Response {\n    rawResponse: Response;\n    rawHeaders: BareHeaders;\n}\n/**\n * A BareResponse with additional properties.\n */\nexport interface BareResponseFetch extends BareResponse {\n    finalURL: string;\n}\nexport interface BareMaintainer {\n    email?: string;\n    website?: string;\n}\nexport interface BareProject {\n    name?: string;\n    description?: string;\n    email?: string;\n    website?: string;\n    repository?: string;\n    version?: string;\n}\nexport type BareLanguage = \"NodeJS\" | \"ServiceWorker\" | \"Deno\" | \"Java\" | \"PHP\" | \"Rust\" | \"C\" | \"C++\" | \"C#\" | \"Ruby\" | \"Go\" | \"Crystal\" | \"Shell\" | string;\nexport interface BareManifest {\n    maintainer?: BareMaintainer;\n    project?: BareProject;\n    versions: string[];\n    language: BareLanguage;\n    memoryUsage?: number;\n}\n","path":null,"size_bytes":1398,"size_tokens":null},"frontend/baremod/index.d.ts":{"content":"export { default as default } from \"./V3\";\nexport { default as BareClient } from \"./V3\";\n","path":null,"size_bytes":89,"size_tokens":null},"frontend/baremod/remoteUtil.d.ts":{"content":"export interface BareRemote {\n    host: string;\n    port: number | string;\n    path: string;\n    protocol: string;\n}\nexport declare function remoteToURL(remote: BareRemote): URL;\nexport declare function resolvePort(url: URL): number;\nexport declare function urlToRemote(url: URL): BareRemote;\n","path":null,"size_bytes":293,"size_tokens":null},"backend/routes/bookmarks.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst SECRET_KEY = 'real_user_auth_secret_2025';\n\nfunction authMiddleware(req, res, next) {\n  const authHeader = req.headers.authorization;\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return res.status(401).json({ error: 'No token provided' });\n  }\n  const token = authHeader.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, SECRET_KEY);\n    req.user = decoded;\n    next();\n  } catch (err) {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\nconst defaultBookmarks = [\n  { name: 'Google', url: 'https://www.google.com', icon: 'ðŸ”', bg_color: null },\n  { name: 'YouTube', url: 'https://www.youtube.com', icon: 'â–¶', bg_color: '#ff0000' },\n  { name: 'SoundCloud', url: 'https://soundcloud.com', icon: 'â˜', bg_color: '#ff5500' },\n  { name: 'Discord', url: 'https://discord.com', icon: 'ðŸ’¬', bg_color: '#5865f2' },\n  { name: 'GitHub', url: 'https://github.com', icon: 'ðŸ™', bg_color: '#333' },\n  { name: 'Reddit', url: 'https://reddit.com', icon: 'ðŸ‘½', bg_color: '#ff4500' },\n  { name: 'Twitch', url: 'https://twitch.tv', icon: 'ðŸ“º', bg_color: '#9146ff' },\n  { name: 'Twitter', url: 'https://twitter.com', icon: 'ðŸ¦', bg_color: '#1da1f2' },\n  { name: 'Spotify', url: 'https://spotify.com', icon: 'ðŸŽµ', bg_color: '#1db954' },\n  { name: 'Netflix', url: 'https://netflix.com', icon: 'ðŸŽ¬', bg_color: '#e50914' }\n];\n\nrouter.get('/', authMiddleware, (req, res) => {\n  db.all('SELECT * FROM user_bookmarks WHERE user_id = ? ORDER BY position, id', [req.user.userId], (err, bookmarks) => {\n    if (err) {\n      console.error('Error fetching bookmarks:', err);\n      return res.status(500).json({ error: 'Failed to fetch bookmarks' });\n    }\n    \n    if (!bookmarks || bookmarks.length === 0) {\n      let inserted = 0;\n      defaultBookmarks.forEach((b, i) => {\n        db.run(\n          'INSERT INTO user_bookmarks (user_id, name, url, icon, bg_color, position) VALUES (?, ?, ?, ?, ?, ?)',\n          [req.user.userId, b.name, b.url, b.icon, b.bg_color, i],\n          (err) => {\n            inserted++;\n            if (inserted === defaultBookmarks.length) {\n              db.all('SELECT * FROM user_bookmarks WHERE user_id = ? ORDER BY position, id', [req.user.userId], (err, newBookmarks) => {\n                if (err) return res.status(500).json({ error: 'Failed to fetch bookmarks' });\n                res.json(newBookmarks || []);\n              });\n            }\n          }\n        );\n      });\n    } else {\n      res.json(bookmarks);\n    }\n  });\n});\n\nrouter.post('/', authMiddleware, (req, res) => {\n  const { name, url, icon, bg_color } = req.body;\n  if (!name || !url) {\n    return res.status(400).json({ error: 'Name and URL are required' });\n  }\n  \n  db.get('SELECT COUNT(*) as count FROM user_bookmarks WHERE user_id = ?', [req.user.userId], (err, result) => {\n    if (err) {\n      console.error('Error counting bookmarks:', err);\n      return res.status(500).json({ error: 'Failed to create bookmark' });\n    }\n    \n    const position = result ? result.count : 0;\n    \n    db.run(\n      'INSERT INTO user_bookmarks (user_id, name, url, icon, bg_color, position) VALUES (?, ?, ?, ?, ?, ?)',\n      [req.user.userId, name, url, icon || 'ðŸ”—', bg_color || null, position],\n      function(err) {\n        if (err) {\n          console.error('Error creating bookmark:', err);\n          return res.status(500).json({ error: 'Failed to create bookmark' });\n        }\n        \n        db.get('SELECT * FROM user_bookmarks WHERE id = ?', [this.lastID], (err, bookmark) => {\n          if (err) return res.status(500).json({ error: 'Failed to fetch created bookmark' });\n          res.json(bookmark);\n        });\n      }\n    );\n  });\n});\n\nrouter.put('/:id', authMiddleware, (req, res) => {\n  const { id } = req.params;\n  const { name, url, icon, bg_color } = req.body;\n  \n  db.get('SELECT * FROM user_bookmarks WHERE id = ? AND user_id = ?', [id, req.user.userId], (err, bookmark) => {\n    if (err) {\n      console.error('Error finding bookmark:', err);\n      return res.status(500).json({ error: 'Failed to update bookmark' });\n    }\n    \n    if (!bookmark) {\n      return res.status(404).json({ error: 'Bookmark not found' });\n    }\n    \n    db.run(\n      'UPDATE user_bookmarks SET name = ?, url = ?, icon = ?, bg_color = ? WHERE id = ? AND user_id = ?',\n      [name || bookmark.name, url || bookmark.url, icon || bookmark.icon, bg_color, id, req.user.userId],\n      function(err) {\n        if (err) {\n          console.error('Error updating bookmark:', err);\n          return res.status(500).json({ error: 'Failed to update bookmark' });\n        }\n        \n        db.get('SELECT * FROM user_bookmarks WHERE id = ?', [id], (err, updated) => {\n          if (err) return res.status(500).json({ error: 'Failed to fetch updated bookmark' });\n          res.json(updated);\n        });\n      }\n    );\n  });\n});\n\nrouter.delete('/:id', authMiddleware, (req, res) => {\n  const { id } = req.params;\n  \n  db.get('SELECT * FROM user_bookmarks WHERE id = ? AND user_id = ?', [id, req.user.userId], (err, bookmark) => {\n    if (err) {\n      console.error('Error finding bookmark:', err);\n      return res.status(500).json({ error: 'Failed to delete bookmark' });\n    }\n    \n    if (!bookmark) {\n      return res.status(404).json({ error: 'Bookmark not found' });\n    }\n    \n    db.run('DELETE FROM user_bookmarks WHERE id = ? AND user_id = ?', [id, req.user.userId], function(err) {\n      if (err) {\n        console.error('Error deleting bookmark:', err);\n        return res.status(500).json({ error: 'Failed to delete bookmark' });\n      }\n      res.json({ success: true });\n    });\n  });\n});\n\nrouter.post('/reorder', authMiddleware, (req, res) => {\n  const { bookmarks } = req.body;\n  \n  if (!bookmarks || !Array.isArray(bookmarks)) {\n    return res.status(400).json({ error: 'Invalid bookmarks array' });\n  }\n  \n  let updated = 0;\n  bookmarks.forEach((bookmark, i) => {\n    db.run(\n      'UPDATE user_bookmarks SET position = ? WHERE id = ? AND user_id = ?',\n      [i, bookmark.id, req.user.userId],\n      (err) => {\n        updated++;\n        if (updated === bookmarks.length) {\n          res.json({ success: true });\n        }\n      }\n    );\n  });\n});\n\nrouter.post('/reset', authMiddleware, (req, res) => {\n  db.run('DELETE FROM user_bookmarks WHERE user_id = ?', [req.user.userId], (err) => {\n    if (err) {\n      console.error('Error resetting bookmarks:', err);\n      return res.status(500).json({ error: 'Failed to reset bookmarks' });\n    }\n    \n    let inserted = 0;\n    defaultBookmarks.forEach((b, i) => {\n      db.run(\n        'INSERT INTO user_bookmarks (user_id, name, url, icon, bg_color, position) VALUES (?, ?, ?, ?, ?, ?)',\n        [req.user.userId, b.name, b.url, b.icon, b.bg_color, i],\n        (err) => {\n          inserted++;\n          if (inserted === defaultBookmarks.length) {\n            db.all('SELECT * FROM user_bookmarks WHERE user_id = ? ORDER BY position, id', [req.user.userId], (err, bookmarks) => {\n              if (err) return res.status(500).json({ error: 'Failed to fetch bookmarks' });\n              res.json(bookmarks || []);\n            });\n          }\n        }\n      );\n    });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":7339,"size_tokens":null},"frontend/baremod/md5.d.ts":{"content":"/**\n * Calculates MD5 value for a given string.\n * If a key is provided, calculates the HMAC-MD5 value.\n * Returns a Hex encoded string unless the raw argument is given.\n *\n * @param string Input string\n * @param key HMAC key\n * @param raw Raw output switch\n * @returns MD5 output\n */\nexport default function md5(string: string, key?: string, raw?: boolean): string;\n","path":null,"size_bytes":367,"size_tokens":null},"frontend/scram/scramjet.config.js":{"content":"self.__scramjet$config = {\n    prefix: \"/scram/service/\",\n    codec: self.__scramjet$codecs ? self.__scramjet$codecs.xor : { encode: (s) => s, decode: (s) => s },\n    config: \"/scram/scramjet.config.js\",\n    bundle: \"/scram/scramjet.bundle.js\",\n    worker: \"/scram/scramjet.worker.js\",\n    client: \"/scram/scramjet.client.js\",\n    codecs: \"/scram/scramjet.codecs.js\"\n};\n","path":null,"size_bytes":370,"size_tokens":null},"frontend/baremod/webSocket.d.ts":{"content":"export declare function validProtocol(protocol: string): boolean;\n","path":null,"size_bytes":66,"size_tokens":null},"frontend/baremod/splitHeaderUtil.d.ts":{"content":"/**\n *\n * Splits headers according to spec\n * @param headers\n * @returns Split headers\n */\nexport declare function splitHeaders(headers: Headers): Headers;\n/**\n * Joins headers according to spec\n * @param headers\n * @returns Joined headers\n */\nexport declare function joinHeaders(headers: Headers): Headers;\n","path":null,"size_bytes":308,"size_tokens":null},"frontend/baremod/snapshot.d.ts":{"content":"export declare const fetch: typeof globalThis.fetch;\nexport declare const WebSocket: {\n    new (url: string | URL, protocols?: string | string[]): WebSocket;\n    prototype: WebSocket;\n    readonly CONNECTING: 0;\n    readonly OPEN: 1;\n    readonly CLOSING: 2;\n    readonly CLOSED: 3;\n};\nexport declare const Request: {\n    new (input: RequestInfo | URL, init?: RequestInit): Request;\n    prototype: Request;\n};\nexport declare const Response: {\n    new (body?: BodyInit | null, init?: ResponseInit): Response;\n    prototype: Response;\n    error(): Response;\n    json(data: any, init?: ResponseInit): Response;\n    redirect(url: string | URL, status?: number): Response;\n};\nexport declare const XMLHttpRequest: {\n    new (): XMLHttpRequest;\n    prototype: XMLHttpRequest;\n    readonly UNSENT: 0;\n    readonly OPENED: 1;\n    readonly HEADERS_RECEIVED: 2;\n    readonly LOADING: 3;\n    readonly DONE: 4;\n};\nexport declare const WebSocketFields: {\n    prototype: {\n        send: (data: string | ArrayBufferLike | Blob | ArrayBufferView) => void;\n    };\n    CLOSED: 3;\n    CLOSING: 2;\n    CONNECTING: 0;\n    OPEN: 1;\n};\n","path":null,"size_bytes":1112,"size_tokens":null},"frontend/baremod/index.js":{"content":"(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.BareMod = {}));\n})(this, (function (exports) { 'use strict';\n\n\t// The user likely has overwritten all networking functions after importing bare-client\n\t// It is our responsibility to make sure components of Bare-Client are using native networking functions\n\t// These exports are provided to plugins by @rollup/plugin-inject\n\tconst fetch = globalThis.fetch;\n\tconst WebSocket = globalThis.WebSocket;\n\tconst WebSocketFields = {\n\t    prototype: {\n\t        send: WebSocket.prototype.send,\n\t    },\n\t    CLOSED: WebSocket.CLOSED,\n\t    CLOSING: WebSocket.CLOSING,\n\t    CONNECTING: WebSocket.CONNECTING,\n\t    OPEN: WebSocket.OPEN,\n\t};\n\n\tclass BareError extends Error {\n\t    status;\n\t    body;\n\t    constructor(status, body) {\n\t        super(body.message || body.code);\n\t        this.status = status;\n\t        this.body = body;\n\t    }\n\t}\n\tclass Client {\n\t    base;\n\t    /**\n\t     *\n\t     * @param version Version provided by extension\n\t     * @param server Bare Server URL provided by BareClient\n\t     */\n\t    constructor(version, server) {\n\t        this.base = new URL(`./v${version}/`, server);\n\t    }\n\t}\n\n\t/*\n\t * JavaScript MD5\n\t * Adopted from https://github.com/blueimp/JavaScript-MD5\n\t *\n\t * Copyright 2011, Sebastian Tschan\n\t * https://blueimp.net\n\t *\n\t * Licensed under the MIT license:\n\t * https://opensource.org/licenses/MIT\n\t *\n\t * Based on\n\t * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n\t * Digest Algorithm, as defined in RFC 1321.\n\t * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n\t * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n\t * Distributed under the BSD License\n\t * See http://pajhome.org.uk/crypt/md5 for more info.\n\t */\n\t/**\n\t * Add integers, wrapping at 2^32.\n\t * This uses 16-bit operations internally to work around bugs in interpreters.\n\t *\n\t * @param x First integer\n\t * @param y Second integer\n\t * @returns Sum\n\t */\n\tfunction safeAdd(x, y) {\n\t    const lsw = (x & 0xffff) + (y & 0xffff);\n\t    const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n\t    return (msw << 16) | (lsw & 0xffff);\n\t}\n\t/**\n\t * Bitwise rotate a 32-bit number to the left.\n\t *\n\t * @param num 32-bit number\n\t * @param cnt Rotation count\n\t * @returns  Rotated number\n\t */\n\tfunction bitRotateLeft(num, cnt) {\n\t    return (num << cnt) | (num >>> (32 - cnt));\n\t}\n\t/**\n\t * Basic operation the algorithm uses.\n\t *\n\t * @param q q\n\t * @param a a\n\t * @param b b\n\t * @param x x\n\t * @param s s\n\t * @param t t\n\t * @returns Result\n\t */\n\tfunction md5cmn(q, a, b, x, s, t) {\n\t    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n\t}\n\t/**\n\t * Basic operation the algorithm uses.\n\t *\n\t * @param a a\n\t * @param b b\n\t * @param c c\n\t * @param d d\n\t * @param x x\n\t * @param s s\n\t * @param t t\n\t * @returns Result\n\t */\n\tfunction md5ff(a, b, c, d, x, s, t) {\n\t    return md5cmn((b & c) | (~b & d), a, b, x, s, t);\n\t}\n\t/**\n\t * Basic operation the algorithm uses.\n\t *\n\t * @param a a\n\t * @param b b\n\t * @param c c\n\t * @param d d\n\t * @param x x\n\t * @param s s\n\t * @param t t\n\t * @returns Result\n\t */\n\tfunction md5gg(a, b, c, d, x, s, t) {\n\t    return md5cmn((b & d) | (c & ~d), a, b, x, s, t);\n\t}\n\t/**\n\t * Basic operation the algorithm uses.\n\t *\n\t * @param a a\n\t * @param b b\n\t * @param c c\n\t * @param d d\n\t * @param x x\n\t * @param s s\n\t * @param t t\n\t * @returns Result\n\t */\n\tfunction md5hh(a, b, c, d, x, s, t) {\n\t    return md5cmn(b ^ c ^ d, a, b, x, s, t);\n\t}\n\t/**\n\t * Basic operation the algorithm uses.\n\t *\n\t * @param a a\n\t * @param b b\n\t * @param c c\n\t * @param d d\n\t * @param x x\n\t * @param s s\n\t * @param t t\n\t * @returns Result\n\t */\n\tfunction md5ii(a, b, c, d, x, s, t) {\n\t    return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n\t}\n\t/**\n\t * Calculate the MD5 of an array of little-endian words, and a bit length.\n\t *\n\t * @param x Array of little-endian words\n\t * @param len Bit length\n\t * @returns MD5 Array\n\t */\n\tfunction binlMD5(x, len) {\n\t    /* append padding */\n\t    x[len >> 5] |= 0x80 << len % 32;\n\t    x[(((len + 64) >>> 9) << 4) + 14] = len;\n\t    let a = 1732584193;\n\t    let b = -271733879;\n\t    let c = -1732584194;\n\t    let d = 271733878;\n\t    for (let i = 0; i < x.length; i += 16) {\n\t        const olda = a;\n\t        const oldb = b;\n\t        const oldc = c;\n\t        const oldd = d;\n\t        a = md5ff(a, b, c, d, x[i], 7, -680876936);\n\t        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n\t        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n\t        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n\t        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n\t        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n\t        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n\t        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n\t        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n\t        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n\t        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n\t        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n\t        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n\t        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n\t        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n\t        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n\t        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n\t        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n\t        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n\t        b = md5gg(b, c, d, a, x[i], 20, -373897302);\n\t        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n\t        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n\t        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n\t        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n\t        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n\t        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n\t        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n\t        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n\t        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n\t        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n\t        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n\t        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n\t        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n\t        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n\t        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n\t        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n\t        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n\t        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n\t        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n\t        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n\t        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n\t        d = md5hh(d, a, b, c, x[i], 11, -358537222);\n\t        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n\t        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n\t        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n\t        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n\t        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n\t        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n\t        a = md5ii(a, b, c, d, x[i], 6, -198630844);\n\t        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n\t        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n\t        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n\t        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n\t        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n\t        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n\t        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n\t        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n\t        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n\t        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n\t        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n\t        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n\t        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n\t        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n\t        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n\t        a = safeAdd(a, olda);\n\t        b = safeAdd(b, oldb);\n\t        c = safeAdd(c, oldc);\n\t        d = safeAdd(d, oldd);\n\t    }\n\t    return [a, b, c, d];\n\t}\n\t/**\n\t * Convert an array of little-endian words to a string\n\t *\n\t * @param input MD5 Array\n\t * @returns MD5 string\n\t */\n\tfunction binl2rstr(input) {\n\t    let output = \"\";\n\t    const length32 = input.length * 32;\n\t    for (let i = 0; i < length32; i += 8) {\n\t        output += String.fromCharCode((input[i >> 5] >>> i % 32) & 0xff);\n\t    }\n\t    return output;\n\t}\n\t/**\n\t * Convert a raw string to an array of little-endian words\n\t * Characters >255 have their high-byte silently ignored.\n\t *\n\t * @param input Raw input string\n\t * @returns Array of little-endian words\n\t */\n\tfunction rstr2binl(input) {\n\t    const output = [];\n\t    const outputLen = input.length >> 2;\n\t    for (let i = 0; i < outputLen; i += 1) {\n\t        output[i] = 0;\n\t    }\n\t    const length8 = input.length * 8;\n\t    for (let i = 0; i < length8; i += 8) {\n\t        output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32;\n\t    }\n\t    return output;\n\t}\n\t/**\n\t * Calculate the MD5 of a raw string\n\t *\n\t * @param s Input string\n\t * @returns Raw MD5 string\n\t */\n\tfunction rstrMD5(s) {\n\t    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));\n\t}\n\t/**\n\t * Convert a raw string to a hex string\n\t *\n\t * @param input Raw input string\n\t * @returns Hex encoded string\n\t */\n\tfunction rstr2hex(input) {\n\t    const hexTab = \"0123456789abcdef\";\n\t    let output = \"\";\n\t    for (let i = 0; i < input.length; i += 1) {\n\t        const x = input.charCodeAt(i);\n\t        output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f);\n\t    }\n\t    return output;\n\t}\n\t/**\n\t * Encode a string as UTF-8\n\t *\n\t * @param input Input string\n\t * @returns UTF8 string\n\t */\n\tfunction str2rstrUTF8(input) {\n\t    return unescape(encodeURIComponent(input));\n\t}\n\t/**\n\t * Encodes input string as raw MD5 string\n\t *\n\t * @param s Input string\n\t * @returns Raw MD5 string\n\t */\n\tfunction rawMD5(s) {\n\t    return rstrMD5(str2rstrUTF8(s));\n\t}\n\t/**\n\t * Encodes input string as Hex encoded string\n\t *\n\t * @param s Input string\n\t * @returns Hex encoded string\n\t */\n\tfunction hexMD5(s) {\n\t    return rstr2hex(rawMD5(s));\n\t}\n\t/**\n\t * Calculates MD5 value for a given string.\n\t * If a key is provided, calculates the HMAC-MD5 value.\n\t * Returns a Hex encoded string unless the raw argument is given.\n\t *\n\t * @param string Input string\n\t * @param key HMAC key\n\t * @param raw Raw output switch\n\t * @returns MD5 output\n\t */\n\tfunction md5(string, key, raw) {\n\t    {\n\t        {\n\t            return hexMD5(string);\n\t        }\n\t    }\n\t}\n\n\tconst MAX_HEADER_VALUE = 3072;\n\t/**\n\t *\n\t * Splits headers according to spec\n\t * @param headers\n\t * @returns Split headers\n\t */\n\tfunction splitHeaders(headers) {\n\t    const output = new Headers(headers);\n\t    if (headers.has(\"x-bare-headers\")) {\n\t        const value = headers.get(\"x-bare-headers\");\n\t        if (value.length > MAX_HEADER_VALUE) {\n\t            output.delete(\"x-bare-headers\");\n\t            let split = 0;\n\t            for (let i = 0; i < value.length; i += MAX_HEADER_VALUE) {\n\t                const part = value.slice(i, i + MAX_HEADER_VALUE);\n\t                const id = split++;\n\t                output.set(`x-bare-headers-${id}`, `;${part}`);\n\t            }\n\t        }\n\t    }\n\t    return output;\n\t}\n\t/**\n\t * Joins headers according to spec\n\t * @param headers\n\t * @returns Joined headers\n\t */\n\tfunction joinHeaders(headers) {\n\t    const output = new Headers(headers);\n\t    const prefix = \"x-bare-headers\";\n\t    if (headers.has(`${prefix}-0`)) {\n\t        const join = [];\n\t        for (const [header, value] of headers) {\n\t            if (!header.startsWith(prefix)) {\n\t                continue;\n\t            }\n\t            if (!value.startsWith(\";\")) {\n\t                throw new BareError(400, {\n\t                    code: \"INVALID_BARE_HEADER\",\n\t                    id: `request.headers.${header}`,\n\t                    message: \"Value didn't begin with semi-colon.\",\n\t                });\n\t            }\n\t            const id = parseInt(header.slice(prefix.length + 1));\n\t            join[id] = value.slice(1);\n\t            output.delete(header);\n\t        }\n\t        output.set(prefix, join.join(\"\"));\n\t    }\n\t    return output;\n\t}\n\n\tclass ClientV3 extends Client {\n\t    ws;\n\t    http;\n\t    meta() {\n\t        return {};\n\t    }\n\t    constructor(server) {\n\t        super(3, server);\n\t        this.ws = new URL(this.base);\n\t        this.http = new URL(this.base);\n\t        if (this.ws.protocol === \"https:\") {\n\t            this.ws.protocol = \"wss:\";\n\t        }\n\t        else {\n\t            this.ws.protocol = \"ws:\";\n\t        }\n\t    }\n\t    ready = true;\n\t    async init() {\n\t        this.ready = true;\n\t    }\n\t    connect(url, protocols, requestHeaders, onopen, onmessage, onclose, onerror) {\n\t        const ws = new WebSocket(this.ws);\n\t        requestHeaders[\"Host\"] = url.host;\n\t        requestHeaders[\"Upgrade\"] = \"websocket\";\n\t        requestHeaders[\"Connection\"] = \"Upgrade\";\n\t        const cleanup = () => {\n\t            ws.removeEventListener(\"close\", closeListener);\n\t            ws.removeEventListener(\"message\", messageListener);\n\t        };\n\t        const messageListener = (event) => {\n\t            cleanup();\n\t            // ws.binaryType is irrelevant when sending text\n\t            if (typeof event.data !== \"string\")\n\t                throw new TypeError(\"the first websocket message was not a text frame\");\n\t            const message = JSON.parse(event.data);\n\t            // finally\n\t            if (message.type !== \"open\")\n\t                throw new TypeError(\"message was not of open type\");\n\t            // onMeta({\n\t            // \tprotocol: message.protocol,\n\t            // \tsetCookies: message.setCookies,\n\t            // });\n\t            onopen(message.protocol);\n\t            ws.addEventListener(\"message\", (ev) => {\n\t                onmessage(ev.data);\n\t            });\n\t            ws.addEventListener(\"close\", (ev) => {\n\t                onclose(ev.code, ev.reason);\n\t            });\n\t        };\n\t        const closeListener = (event) => {\n\t            onclose(event.code, event.reason);\n\t            cleanup();\n\t        };\n\t        ws.addEventListener(\"message\", messageListener);\n\t        ws.addEventListener(\"close\", closeListener);\n\t        // CONNECTED TO THE BARE SERVER, NOT THE REMOTE\n\t        ws.addEventListener(\"open\", (event) => {\n\t            WebSocketFields.prototype.send.call(ws, JSON.stringify({\n\t                type: \"connect\",\n\t                remote: url.toString(),\n\t                protocols,\n\t                headers: requestHeaders,\n\t                forwardHeaders: [],\n\t            }));\n\t        }, \n\t        // only block the open event once\n\t        { once: true });\n\t        return [ws.send.bind(ws), ws.close.bind(ws)];\n\t    }\n\t    async request(remote, method, body, headers, signal) {\n\t        const options = {\n\t            credentials: \"omit\",\n\t            method: method,\n\t            signal,\n\t            //@ts-expect-error this exists but isnt typed ig\n\t            duplex: \"half\"\n\t        };\n\t        if (body !== undefined) {\n\t            options.body = body;\n\t        }\n\t        if (\"host\" in headers)\n\t            headers.host = remote.host;\n\t        else\n\t            headers.Host = remote.host;\n\t        options.headers = this.createBareHeaders(remote, headers);\n\t        const response = await fetch(this.http + \"?cache=\" + md5(remote.toString()), options);\n\t        const readResponse = await this.readBareResponse(response);\n\t        return {\n\t            body: response.body,\n\t            headers: readResponse.headers,\n\t            status: readResponse.status,\n\t            statusText: readResponse.statusText,\n\t        };\n\t    }\n\t    async readBareResponse(response) {\n\t        if (!response.ok) {\n\t            throw new BareError(response.status, await response.json());\n\t        }\n\t        const responseHeaders = joinHeaders(response.headers);\n\t        const result = {};\n\t        const xBareStatus = responseHeaders.get(\"x-bare-status\");\n\t        if (xBareStatus !== null)\n\t            result.status = parseInt(xBareStatus);\n\t        const xBareStatusText = responseHeaders.get(\"x-bare-status-text\");\n\t        if (xBareStatusText !== null)\n\t            result.statusText = xBareStatusText;\n\t        const xBareHeaders = responseHeaders.get(\"x-bare-headers\");\n\t        if (xBareHeaders !== null)\n\t            result.headers = JSON.parse(xBareHeaders);\n\t        return result;\n\t    }\n\t    createBareHeaders(remote, bareHeaders, forwardHeaders = [], passHeaders = [], passStatus = []) {\n\t        const headers = new Headers();\n\t        headers.set(\"x-bare-url\", remote.toString());\n\t        headers.set(\"x-bare-headers\", JSON.stringify(bareHeaders));\n\t        for (const header of forwardHeaders) {\n\t            headers.append(\"x-bare-forward-headers\", header);\n\t        }\n\t        for (const header of passHeaders) {\n\t            headers.append(\"x-bare-pass-headers\", header);\n\t        }\n\t        for (const status of passStatus) {\n\t            headers.append(\"x-bare-pass-status\", status.toString());\n\t        }\n\t        splitHeaders(headers);\n\t        return headers;\n\t    }\n\t}\n\n\texports.BareClient = ClientV3;\n\texports.default = ClientV3;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=index.js.map\n","path":null,"size_bytes":17579,"size_tokens":null},"frontend/js/permissions.js":{"content":"const PERMISSION_LABELS = {\n  view_channel: { name: 'View Channel', description: 'See this channel and read messages' },\n  send_messages: { name: 'Send Messages', description: 'Send messages in this channel' },\n  send_files: { name: 'Send Files', description: 'Upload and send files' },\n  add_reactions: { name: 'Add Reactions', description: 'Add emoji reactions to messages' },\n  mention_everyone: { name: 'Mention Everyone', description: 'Use @everyone and @here' },\n  delete_messages: { name: 'Delete Messages', description: 'Delete other users\\' messages' },\n  pin_messages: { name: 'Pin Messages', description: 'Pin messages to channel' },\n  manage_channel: { name: 'Manage Channel', description: 'Edit channel settings' },\n  manage_permissions: { name: 'Manage Permissions', description: 'Edit channel permissions' },\n  mute_members: { name: 'Mute Members', description: 'Prevent members from sending messages' },\n  kick_members: { name: 'Kick Members', description: 'Remove members from the server' },\n  ban_members: { name: 'Ban Members', description: 'Permanently ban members' },\n  manage_roles: { name: 'Manage Roles', description: 'Create and edit server roles' },\n  manage_server: { name: 'Manage Server', description: 'Full server administration' },\n  create_invites: { name: 'Create Invites', description: 'Create server invite links' }\n};\n\nlet permissionsData = null;\nlet currentPermTab = 'roles';\nlet pendingChanges = {};\nlet currentChannelId = null;\n\nfunction openPermissionsModal(channelId) {\n  currentChannelId = channelId;\n  pendingChanges = {};\n  document.getElementById('permissionsOverlay').style.display = 'block';\n  document.getElementById('permissionsModal').style.display = 'block';\n  loadPermissions(channelId);\n}\n\nfunction closePermissionsModal() {\n  document.getElementById('permissionsOverlay').style.display = 'none';\n  document.getElementById('permissionsModal').style.display = 'none';\n  permissionsData = null;\n  currentChannelId = null;\n  pendingChanges = {};\n}\n\nasync function loadPermissions(channelId) {\n  const token = localStorage.getItem('authToken');\n  try {\n    const response = await fetch(`/api/permissions/channel/${channelId}`, {\n      headers: { 'Authorization': `Bearer ${token}` }\n    });\n    \n    if (!response.ok) {\n      const err = await response.json();\n      alert(err.error || 'Failed to load permissions');\n      closePermissionsModal();\n      return;\n    }\n    \n    permissionsData = await response.json();\n    switchPermTab('roles');\n  } catch (err) {\n    console.error('Error loading permissions:', err);\n    alert('Failed to load permissions');\n    closePermissionsModal();\n  }\n}\n\nfunction switchPermTab(tab) {\n  currentPermTab = tab;\n  \n  document.getElementById('permRolesTab').style.background = tab === 'roles' ? 'var(--primary)' : 'var(--bg)';\n  document.getElementById('permRolesTab').style.color = tab === 'roles' ? 'var(--bg)' : 'var(--text)';\n  document.getElementById('permRolesTab').style.border = tab === 'roles' ? 'none' : '1px solid var(--accent)';\n  \n  document.getElementById('permUsersTab').style.background = tab === 'users' ? 'var(--primary)' : 'var(--bg)';\n  document.getElementById('permUsersTab').style.color = tab === 'users' ? 'var(--bg)' : 'var(--text)';\n  document.getElementById('permUsersTab').style.border = tab === 'users' ? 'none' : '1px solid var(--accent)';\n  \n  updateTargetSelect();\n}\n\nfunction updateTargetSelect() {\n  const select = document.getElementById('permTargetSelect');\n  select.innerHTML = '';\n  \n  if (currentPermTab === 'roles' && permissionsData?.roles) {\n    permissionsData.roles.forEach(role => {\n      const option = document.createElement('option');\n      option.value = role.id;\n      option.textContent = role.name;\n      option.style.color = role.color || '#99AAB5';\n      select.appendChild(option);\n    });\n  } else if (currentPermTab === 'users' && permissionsData?.members) {\n    const option = document.createElement('option');\n    option.value = '';\n    option.textContent = '-- Select a user to override permissions --';\n    select.appendChild(option);\n    \n    permissionsData.members.forEach(member => {\n      const option = document.createElement('option');\n      option.value = member.id;\n      option.textContent = member.username;\n      select.appendChild(option);\n    });\n  }\n  \n  select.onchange = () => renderPermissionsGrid();\n  renderPermissionsGrid();\n}\n\nfunction renderPermissionsGrid() {\n  const grid = document.getElementById('permissionsGrid');\n  const targetId = document.getElementById('permTargetSelect').value;\n  \n  if (!targetId) {\n    grid.innerHTML = '<div style=\"text-align:center;color:var(--text-light);padding:20px;\">Select a user or role to manage permissions</div>';\n    return;\n  }\n  \n  const targetType = currentPermTab === 'roles' ? 'role' : 'user';\n  \n  grid.innerHTML = '';\n  \n  permissionsData.permissionList.forEach(permKey => {\n    const permInfo = PERMISSION_LABELS[permKey] || { name: permKey, description: '' };\n    \n    const override = permissionsData.overrides.find(\n      o => o.target_type === targetType && o.target_id == targetId && o.permission === permKey\n    );\n    \n    const pendingValue = pendingChanges[`${targetType}-${targetId}-${permKey}`];\n    const currentValue = pendingValue !== undefined ? pendingValue : (override?.value ?? null);\n    \n    const row = document.createElement('div');\n    row.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:12px;background:var(--bg);border-radius:8px;';\n    \n    row.innerHTML = `\n      <div>\n        <div style=\"font-weight:600;color:var(--text);\">${permInfo.name}</div>\n        <div style=\"font-size:12px;color:var(--text-light);\">${permInfo.description}</div>\n      </div>\n      <div style=\"display:flex;gap:5px;\">\n        <button onclick=\"setPermValue('${targetType}', ${targetId}, '${permKey}', 1)\" \n                style=\"width:36px;height:36px;border-radius:50%;border:2px solid ${currentValue === 1 ? '#2ecc71' : 'var(--accent)'};\n                       background:${currentValue === 1 ? '#2ecc71' : 'transparent'};cursor:pointer;display:flex;align-items:center;justify-content:center;\n                       font-size:18px;color:${currentValue === 1 ? 'white' : '#2ecc71'};\">âœ“</button>\n        <button onclick=\"setPermValue('${targetType}', ${targetId}, '${permKey}', null)\" \n                style=\"width:36px;height:36px;border-radius:50%;border:2px solid ${currentValue === null ? 'var(--primary)' : 'var(--accent)'};\n                       background:${currentValue === null ? 'var(--primary)' : 'transparent'};cursor:pointer;display:flex;align-items:center;justify-content:center;\n                       font-size:14px;color:${currentValue === null ? 'var(--bg)' : 'var(--text-light)'};\">â€”</button>\n        <button onclick=\"setPermValue('${targetType}', ${targetId}, '${permKey}', 0)\" \n                style=\"width:36px;height:36px;border-radius:50%;border:2px solid ${currentValue === 0 ? '#e74c3c' : 'var(--accent)'};\n                       background:${currentValue === 0 ? '#e74c3c' : 'transparent'};cursor:pointer;display:flex;align-items:center;justify-content:center;\n                       font-size:18px;color:${currentValue === 0 ? 'white' : '#e74c3c'};\">âœ•</button>\n      </div>\n    `;\n    \n    grid.appendChild(row);\n  });\n}\n\nfunction setPermValue(targetType, targetId, permission, value) {\n  pendingChanges[`${targetType}-${targetId}-${permission}`] = value;\n  renderPermissionsGrid();\n}\n\nasync function savePermissions() {\n  const token = localStorage.getItem('authToken');\n  const changes = Object.entries(pendingChanges);\n  \n  if (changes.length === 0) {\n    closePermissionsModal();\n    return;\n  }\n  \n  try {\n    for (const [key, value] of changes) {\n      const [targetType, targetId, permission] = key.split('-');\n      \n      await fetch(`/api/permissions/channel/${currentChannelId}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify({\n          targetType,\n          targetId: parseInt(targetId),\n          permission,\n          value\n        })\n      });\n    }\n    \n    alert('Permissions saved successfully!');\n    closePermissionsModal();\n  } catch (err) {\n    console.error('Error saving permissions:', err);\n    alert('Failed to save some permissions');\n  }\n}\n\nwindow.openPermissionsModal = openPermissionsModal;\nwindow.closePermissionsModal = closePermissionsModal;\nwindow.switchPermTab = switchPermTab;\nwindow.setPermValue = setPermValue;\nwindow.savePermissions = savePermissions;\n","path":null,"size_bytes":8617,"size_tokens":null},"backend/permissions.js":{"content":"const db = require('./db');\n\nconst PERMISSIONS = {\n  VIEW_CHANNEL: 'view_channel',\n  SEND_MESSAGES: 'send_messages',\n  SEND_FILES: 'send_files',\n  ADD_REACTIONS: 'add_reactions',\n  MENTION_EVERYONE: 'mention_everyone',\n  DELETE_MESSAGES: 'delete_messages',\n  PIN_MESSAGES: 'pin_messages',\n  MANAGE_CHANNEL: 'manage_channel',\n  MANAGE_PERMISSIONS: 'manage_permissions',\n  MUTE_MEMBERS: 'mute_members',\n  KICK_MEMBERS: 'kick_members',\n  BAN_MEMBERS: 'ban_members',\n  MANAGE_ROLES: 'manage_roles',\n  MANAGE_SERVER: 'manage_server',\n  CREATE_INVITES: 'create_invites'\n};\n\nconst PERMISSION_VALUES = {\n  NEUTRAL: null,\n  ALLOW: 1,\n  DENY: 0\n};\n\nconst DEFAULT_ROLE_PERMISSIONS = {\n  admin: {\n    [PERMISSIONS.VIEW_CHANNEL]: true,\n    [PERMISSIONS.SEND_MESSAGES]: true,\n    [PERMISSIONS.SEND_FILES]: true,\n    [PERMISSIONS.ADD_REACTIONS]: true,\n    [PERMISSIONS.MENTION_EVERYONE]: true,\n    [PERMISSIONS.DELETE_MESSAGES]: true,\n    [PERMISSIONS.PIN_MESSAGES]: true,\n    [PERMISSIONS.MANAGE_CHANNEL]: true,\n    [PERMISSIONS.MANAGE_PERMISSIONS]: true,\n    [PERMISSIONS.MUTE_MEMBERS]: true,\n    [PERMISSIONS.KICK_MEMBERS]: true,\n    [PERMISSIONS.BAN_MEMBERS]: true,\n    [PERMISSIONS.MANAGE_ROLES]: true,\n    [PERMISSIONS.MANAGE_SERVER]: true,\n    [PERMISSIONS.CREATE_INVITES]: true\n  },\n  moderator: {\n    [PERMISSIONS.VIEW_CHANNEL]: true,\n    [PERMISSIONS.SEND_MESSAGES]: true,\n    [PERMISSIONS.SEND_FILES]: true,\n    [PERMISSIONS.ADD_REACTIONS]: true,\n    [PERMISSIONS.MENTION_EVERYONE]: true,\n    [PERMISSIONS.DELETE_MESSAGES]: true,\n    [PERMISSIONS.PIN_MESSAGES]: true,\n    [PERMISSIONS.MANAGE_CHANNEL]: false,\n    [PERMISSIONS.MANAGE_PERMISSIONS]: false,\n    [PERMISSIONS.MUTE_MEMBERS]: true,\n    [PERMISSIONS.KICK_MEMBERS]: true,\n    [PERMISSIONS.BAN_MEMBERS]: false,\n    [PERMISSIONS.MANAGE_ROLES]: false,\n    [PERMISSIONS.MANAGE_SERVER]: false,\n    [PERMISSIONS.CREATE_INVITES]: true\n  },\n  member: {\n    [PERMISSIONS.VIEW_CHANNEL]: true,\n    [PERMISSIONS.SEND_MESSAGES]: true,\n    [PERMISSIONS.SEND_FILES]: true,\n    [PERMISSIONS.ADD_REACTIONS]: true,\n    [PERMISSIONS.MENTION_EVERYONE]: false,\n    [PERMISSIONS.DELETE_MESSAGES]: false,\n    [PERMISSIONS.PIN_MESSAGES]: false,\n    [PERMISSIONS.MANAGE_CHANNEL]: false,\n    [PERMISSIONS.MANAGE_PERMISSIONS]: false,\n    [PERMISSIONS.MUTE_MEMBERS]: false,\n    [PERMISSIONS.KICK_MEMBERS]: false,\n    [PERMISSIONS.BAN_MEMBERS]: false,\n    [PERMISSIONS.MANAGE_ROLES]: false,\n    [PERMISSIONS.MANAGE_SERVER]: false,\n    [PERMISSIONS.CREATE_INVITES]: true\n  },\n  muted: {\n    [PERMISSIONS.VIEW_CHANNEL]: true,\n    [PERMISSIONS.SEND_MESSAGES]: false,\n    [PERMISSIONS.SEND_FILES]: false,\n    [PERMISSIONS.ADD_REACTIONS]: false,\n    [PERMISSIONS.MENTION_EVERYONE]: false,\n    [PERMISSIONS.DELETE_MESSAGES]: false,\n    [PERMISSIONS.PIN_MESSAGES]: false,\n    [PERMISSIONS.MANAGE_CHANNEL]: false,\n    [PERMISSIONS.MANAGE_PERMISSIONS]: false,\n    [PERMISSIONS.MUTE_MEMBERS]: false,\n    [PERMISSIONS.KICK_MEMBERS]: false,\n    [PERMISSIONS.BAN_MEMBERS]: false,\n    [PERMISSIONS.MANAGE_ROLES]: false,\n    [PERMISSIONS.MANAGE_SERVER]: false,\n    [PERMISSIONS.CREATE_INVITES]: false\n  }\n};\n\nfunction getUserRolesInServer(serverId, userId) {\n  return new Promise((resolve, reject) => {\n    db.all(\n      `SELECT sr.* FROM server_roles sr\n       JOIN server_member_roles smr ON sr.id = smr.role_id\n       WHERE smr.server_id = ? AND smr.user_id = ?\n       ORDER BY sr.position DESC`,\n      [serverId, userId],\n      (err, roles) => {\n        if (err) reject(err);\n        else resolve(roles || []);\n      }\n    );\n  });\n}\n\nfunction getServerOwner(serverId) {\n  return new Promise((resolve, reject) => {\n    db.get('SELECT owner_id FROM servers WHERE id = ?', [serverId], (err, server) => {\n      if (err) reject(err);\n      else resolve(server?.owner_id);\n    });\n  });\n}\n\nfunction getChannelPermissions(channelId) {\n  return new Promise((resolve, reject) => {\n    db.all(\n      'SELECT * FROM channel_permissions WHERE channel_id = ?',\n      [channelId],\n      (err, perms) => {\n        if (err) reject(err);\n        else resolve(perms || []);\n      }\n    );\n  });\n}\n\nfunction parseRolePermissions(role) {\n  if (!role.permissions) return {};\n  try {\n    return typeof role.permissions === 'string' \n      ? JSON.parse(role.permissions) \n      : role.permissions;\n  } catch {\n    return {};\n  }\n}\n\nasync function checkPermission(serverId, channelId, userId, permission) {\n  try {\n    const ownerId = await getServerOwner(serverId);\n    if (ownerId === userId) {\n      return true;\n    }\n\n    const userRoles = await getUserRolesInServer(serverId, userId);\n    const channelPerms = await getChannelPermissions(channelId);\n\n    const userOverride = channelPerms.find(\n      p => p.target_type === 'user' && p.target_id === userId && p.permission === permission\n    );\n    if (userOverride) {\n      return userOverride.value === 1;\n    }\n\n    let hasDeny = false;\n    let hasAllow = false;\n    \n    for (const role of userRoles) {\n      const roleOverride = channelPerms.find(\n        p => p.target_type === 'role' && p.target_id === role.id && p.permission === permission\n      );\n      if (roleOverride) {\n        if (roleOverride.value === 0) hasDeny = true;\n        if (roleOverride.value === 1) hasAllow = true;\n      }\n    }\n    \n    if (hasDeny) return false;\n    if (hasAllow) return true;\n\n    let roleHasDeny = false;\n    let roleHasAllow = false;\n    \n    for (const role of userRoles) {\n      const rolePerms = parseRolePermissions(role);\n      if (rolePerms[permission] !== undefined) {\n        if (rolePerms[permission] === false || rolePerms[permission] === 0) roleHasDeny = true;\n        if (rolePerms[permission] === true || rolePerms[permission] === 1) roleHasAllow = true;\n      }\n    }\n    \n    if (roleHasDeny) return false;\n    if (roleHasAllow) return true;\n\n    return DEFAULT_ROLE_PERMISSIONS.member[permission] || false;\n  } catch (err) {\n    console.error('Permission check error:', err);\n    return false;\n  }\n}\n\nasync function getEffectivePermissions(serverId, channelId, userId) {\n  const result = {};\n  \n  try {\n    const ownerId = await getServerOwner(serverId);\n    if (ownerId === userId) {\n      Object.keys(PERMISSIONS).forEach(key => {\n        result[PERMISSIONS[key]] = true;\n      });\n      return result;\n    }\n\n    const userRoles = await getUserRolesInServer(serverId, userId);\n    const channelPerms = await getChannelPermissions(channelId);\n\n    for (const permKey of Object.keys(PERMISSIONS)) {\n      const permission = PERMISSIONS[permKey];\n      \n      const userOverride = channelPerms.find(\n        p => p.target_type === 'user' && p.target_id === userId && p.permission === permission\n      );\n      if (userOverride) {\n        result[permission] = userOverride.value === 1;\n        continue;\n      }\n\n      let hasDeny = false;\n      let hasAllow = false;\n      \n      for (const role of userRoles) {\n        const roleOverride = channelPerms.find(\n          p => p.target_type === 'role' && p.target_id === role.id && p.permission === permission\n        );\n        if (roleOverride) {\n          if (roleOverride.value === 0) hasDeny = true;\n          if (roleOverride.value === 1) hasAllow = true;\n        }\n      }\n      \n      if (hasDeny) {\n        result[permission] = false;\n        continue;\n      }\n      if (hasAllow) {\n        result[permission] = true;\n        continue;\n      }\n\n      let roleHasDeny = false;\n      let roleHasAllow = false;\n      \n      for (const role of userRoles) {\n        const rolePerms = parseRolePermissions(role);\n        if (rolePerms[permission] !== undefined) {\n          if (rolePerms[permission] === false || rolePerms[permission] === 0) roleHasDeny = true;\n          if (rolePerms[permission] === true || rolePerms[permission] === 1) roleHasAllow = true;\n        }\n      }\n      \n      if (roleHasDeny) {\n        result[permission] = false;\n        continue;\n      }\n      if (roleHasAllow) {\n        result[permission] = true;\n        continue;\n      }\n\n      result[permission] = DEFAULT_ROLE_PERMISSIONS.member[permission] || false;\n    }\n  } catch (err) {\n    console.error('Get effective permissions error:', err);\n    Object.keys(PERMISSIONS).forEach(key => {\n      result[PERMISSIONS[key]] = false;\n    });\n  }\n\n  return result;\n}\n\nfunction setChannelPermission(channelId, targetType, targetId, permission, value) {\n  return new Promise((resolve, reject) => {\n    if (value === null) {\n      db.run(\n        'DELETE FROM channel_permissions WHERE channel_id = ? AND target_type = ? AND target_id = ? AND permission = ?',\n        [channelId, targetType, targetId, permission],\n        function(err) {\n          if (err) reject(err);\n          else resolve({ deleted: true });\n        }\n      );\n    } else {\n      db.run(\n        `INSERT INTO channel_permissions (channel_id, target_type, target_id, permission, value)\n         VALUES (?, ?, ?, ?, ?)\n         ON CONFLICT (channel_id, target_type, target_id, permission) \n         DO UPDATE SET value = ?`,\n        [channelId, targetType, targetId, permission, value, value],\n        function(err) {\n          if (err) reject(err);\n          else resolve({ id: this.lastID });\n        }\n      );\n    }\n  });\n}\n\nfunction getChannelPermissionOverrides(channelId) {\n  return new Promise((resolve, reject) => {\n    db.all(\n      `SELECT cp.*, \n        CASE WHEN cp.target_type = 'role' THEN sr.name ELSE u.username END as target_name\n       FROM channel_permissions cp\n       LEFT JOIN server_roles sr ON cp.target_type = 'role' AND cp.target_id = sr.id\n       LEFT JOIN users u ON cp.target_type = 'user' AND cp.target_id = u.id\n       WHERE cp.channel_id = ?`,\n      [channelId],\n      (err, perms) => {\n        if (err) reject(err);\n        else resolve(perms || []);\n      }\n    );\n  });\n}\n\nasync function canViewChannel(serverId, channelId, userId) {\n  return await checkPermission(serverId, channelId, userId, PERMISSIONS.VIEW_CHANNEL);\n}\n\nasync function canSendMessages(serverId, channelId, userId) {\n  return await checkPermission(serverId, channelId, userId, PERMISSIONS.SEND_MESSAGES);\n}\n\nasync function canManageChannel(serverId, channelId, userId) {\n  return await checkPermission(serverId, channelId, userId, PERMISSIONS.MANAGE_CHANNEL);\n}\n\nasync function canManagePermissions(serverId, channelId, userId) {\n  return await checkPermission(serverId, channelId, userId, PERMISSIONS.MANAGE_PERMISSIONS);\n}\n\nasync function canDeleteMessages(serverId, channelId, userId) {\n  return await checkPermission(serverId, channelId, userId, PERMISSIONS.DELETE_MESSAGES);\n}\n\nmodule.exports = {\n  PERMISSIONS,\n  PERMISSION_VALUES,\n  DEFAULT_ROLE_PERMISSIONS,\n  checkPermission,\n  getEffectivePermissions,\n  setChannelPermission,\n  getChannelPermissionOverrides,\n  canViewChannel,\n  canSendMessages,\n  canManageChannel,\n  canManagePermissions,\n  canDeleteMessages,\n  getUserRolesInServer,\n  getServerOwner\n};\n","path":null,"size_bytes":10877,"size_tokens":null},"backend/routes/activity.js":{"content":"const express = require('express');\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst router = express.Router();\nconst SECRET_KEY = 'real_user_auth_secret_2025';\n\nfunction getUserId(req) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return null;\n  try {\n    const decoded = jwt.verify(token, SECRET_KEY);\n    return decoded.userId;\n  } catch {\n    return null;\n  }\n}\n\nrouter.get('/status', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  db.get('SELECT * FROM activity_status WHERE user_id = ?', [userId], (err, status) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(status || { status_type: 'online', activity_type: null, activity_name: null });\n  });\n});\n\nrouter.post('/status', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  const { status_type, activity_type, activity_name, custom_status, custom_emoji } = req.body;\n\n  db.run(`\n    INSERT INTO activity_status (user_id, status_type, activity_type, activity_name, custom_status, custom_emoji)\n    VALUES (?, ?, ?, ?, ?, ?)\n    ON CONFLICT(user_id) DO UPDATE SET\n      status_type = ?,\n      activity_type = ?,\n      activity_name = ?,\n      custom_status = ?,\n      custom_emoji = ?,\n      updated_at = CURRENT_TIMESTAMP\n  `, [userId, status_type, activity_type, activity_name, custom_status, custom_emoji,\n      status_type, activity_type, activity_name, custom_status, custom_emoji], function(err) {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json({ success: true });\n  });\n});\n\nrouter.post('/playing', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  const { game_name } = req.body;\n\n  db.run(`\n    INSERT INTO activity_status (user_id, activity_type, activity_name)\n    VALUES (?, 'playing', ?)\n    ON CONFLICT(user_id) DO UPDATE SET\n      activity_type = 'playing',\n      activity_name = ?,\n      updated_at = CURRENT_TIMESTAMP\n  `, [userId, game_name, game_name], function(err) {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json({ success: true });\n  });\n});\n\nrouter.post('/watching', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  const { title } = req.body;\n\n  db.run(`\n    INSERT INTO activity_status (user_id, activity_type, activity_name)\n    VALUES (?, 'watching', ?)\n    ON CONFLICT(user_id) DO UPDATE SET\n      activity_type = 'watching',\n      activity_name = ?,\n      updated_at = CURRENT_TIMESTAMP\n  `, [userId, title, title], function(err) {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json({ success: true });\n  });\n});\n\nrouter.post('/browsing', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  const { site } = req.body;\n\n  db.run(`\n    INSERT INTO activity_status (user_id, activity_type, activity_name)\n    VALUES (?, 'browsing', ?)\n    ON CONFLICT(user_id) DO UPDATE SET\n      activity_type = 'browsing',\n      activity_name = ?,\n      updated_at = CURRENT_TIMESTAMP\n  `, [userId, site, site], function(err) {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json({ success: true });\n  });\n});\n\nrouter.post('/clear', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  db.run(`\n    UPDATE activity_status SET activity_type = NULL, activity_name = NULL, updated_at = CURRENT_TIMESTAMP\n    WHERE user_id = ?\n  `, [userId], function(err) {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json({ success: true });\n  });\n});\n\nrouter.get('/user/:userId', (req, res) => {\n  const { userId } = req.params;\n\n  db.get(`\n    SELECT a.*, u.username, u.profile_picture, u.is_online\n    FROM activity_status a\n    RIGHT JOIN users u ON a.user_id = u.id\n    WHERE u.id = ?\n  `, [userId], (err, data) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(data || { status_type: 'offline' });\n  });\n});\n\nrouter.get('/online', (req, res) => {\n  const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000).toISOString();\n  \n  db.run(`\n    UPDATE activity_status \n    SET activity_type = NULL, activity_name = NULL \n    WHERE updated_at < ?\n  `, [fiveMinutesAgo], () => {\n    db.all(`\n      SELECT u.id, u.username, u.profile_picture, u.is_online, a.activity_type, a.activity_name, a.custom_status, a.custom_emoji\n      FROM users u\n      LEFT JOIN activity_status a ON u.id = a.user_id\n      WHERE u.is_online = true\n      ORDER BY a.updated_at DESC\n    `, [], (err, users) => {\n      if (err) return res.status(500).json({ error: err.message });\n      res.json(users);\n    });\n  });\n});\n\nrouter.post('/update', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  const { activity_type, activity_data } = req.body;\n  const validTypes = ['playing_game', 'watching', 'browsing', 'chatting', null];\n  \n  if (!validTypes.includes(activity_type)) {\n    return res.status(400).json({ error: 'Invalid activity type' });\n  }\n\n  db.run(`\n    INSERT INTO activity_status (user_id, activity_type, activity_name)\n    VALUES (?, ?, ?)\n    ON CONFLICT(user_id) DO UPDATE SET\n      activity_type = ?,\n      activity_name = ?,\n      updated_at = CURRENT_TIMESTAMP\n  `, [userId, activity_type, activity_data, activity_type, activity_data], function(err) {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json({ success: true });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":5809,"size_tokens":null},"backend/routes/tasks.js":{"content":"const express = require('express');\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst router = express.Router();\nconst SECRET_KEY = 'real_user_auth_secret_2025';\n\nfunction getUserId(req) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return null;\n  try {\n    const decoded = jwt.verify(token, SECRET_KEY);\n    return decoded.userId;\n  } catch {\n    return null;\n  }\n}\n\nrouter.get('/', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  const { completed, priority } = req.query;\n  let query = 'SELECT * FROM user_tasks WHERE user_id = ?';\n  const params = [userId];\n\n  if (completed !== undefined) {\n    query += ' AND completed = ?';\n    params.push(completed === 'true');\n  }\n\n  if (priority) {\n    query += ' AND priority = ?';\n    params.push(priority);\n  }\n\n  query += ' ORDER BY due_date ASC NULLS LAST, created_at DESC';\n\n  db.all(query, params, (err, tasks) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(tasks);\n  });\n});\n\nrouter.post('/', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  const { title, description, due_date, priority } = req.body;\n  if (!title) return res.status(400).json({ error: 'Title is required' });\n\n  db.run(`\n    INSERT INTO user_tasks (user_id, title, description, due_date, priority)\n    VALUES (?, ?, ?, ?, ?)\n  `, [userId, title, description, due_date, priority || 'medium'], function(err) {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json({ success: true, id: this.lastID });\n  });\n});\n\nrouter.put('/:id', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  const { id } = req.params;\n  const { title, description, due_date, priority } = req.body;\n\n  db.run(`\n    UPDATE user_tasks SET title = ?, description = ?, due_date = ?, priority = ?\n    WHERE id = ? AND user_id = ?\n  `, [title, description, due_date, priority, id, userId], function(err) {\n    if (err) return res.status(500).json({ error: err.message });\n    if (this.changes === 0) return res.status(404).json({ error: 'Task not found' });\n    res.json({ success: true });\n  });\n});\n\nrouter.post('/:id/complete', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  const { id } = req.params;\n\n  db.run(`\n    UPDATE user_tasks SET completed = true, completed_at = CURRENT_TIMESTAMP\n    WHERE id = ? AND user_id = ?\n  `, [id, userId], function(err) {\n    if (err) return res.status(500).json({ error: err.message });\n    if (this.changes === 0) return res.status(404).json({ error: 'Task not found' });\n    \n    db.run(`\n      INSERT INTO user_xp (user_id, total_xp) VALUES (?, 10)\n      ON CONFLICT(user_id) DO UPDATE SET total_xp = total_xp + 10\n    `, [userId]);\n    \n    res.json({ success: true, xp_earned: 10 });\n  });\n});\n\nrouter.post('/:id/uncomplete', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  const { id } = req.params;\n\n  db.run(`\n    UPDATE user_tasks SET completed = false, completed_at = NULL\n    WHERE id = ? AND user_id = ?\n  `, [id, userId], function(err) {\n    if (err) return res.status(500).json({ error: err.message });\n    if (this.changes === 0) return res.status(404).json({ error: 'Task not found' });\n    res.json({ success: true });\n  });\n});\n\nrouter.delete('/:id', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  const { id } = req.params;\n\n  db.run('DELETE FROM user_tasks WHERE id = ? AND user_id = ?', [id, userId], function(err) {\n    if (err) return res.status(500).json({ error: err.message });\n    if (this.changes === 0) return res.status(404).json({ error: 'Task not found' });\n    res.json({ success: true });\n  });\n});\n\nrouter.get('/stats', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  db.get(`\n    SELECT \n      COUNT(*) as total,\n      SUM(CASE WHEN completed = true THEN 1 ELSE 0 END) as completed,\n      SUM(CASE WHEN completed = false THEN 1 ELSE 0 END) as pending,\n      SUM(CASE WHEN due_date < CURRENT_TIMESTAMP AND completed = false THEN 1 ELSE 0 END) as overdue\n    FROM user_tasks WHERE user_id = ?\n  `, [userId], (err, stats) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(stats);\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":4646,"size_tokens":null},"backend/routes/xp.js":{"content":"const express = require('express');\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst router = express.Router();\nconst SECRET_KEY = 'real_user_auth_secret_2025';\n\nfunction getUserId(req) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return null;\n  try {\n    const decoded = jwt.verify(token, SECRET_KEY);\n    return decoded.userId;\n  } catch {\n    return null;\n  }\n}\n\nfunction calculateLevel(xp) {\n  return Math.floor(Math.sqrt(xp / 100)) + 1;\n}\n\nfunction xpForLevel(level) {\n  return Math.pow(level - 1, 2) * 100;\n}\n\nfunction xpForNextLevel(level) {\n  return Math.pow(level, 2) * 100;\n}\n\nrouter.get('/me', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  db.get('SELECT * FROM user_xp WHERE user_id = ?', [userId], (err, xpData) => {\n    if (!xpData) {\n      db.run('INSERT INTO user_xp (user_id) VALUES (?) ON CONFLICT DO NOTHING', [userId], () => {\n        res.json({\n          total_xp: 0,\n          level: 1,\n          messages_sent: 0,\n          games_played: 0,\n          login_streak: 0,\n          xp_for_next_level: 100,\n          progress_percent: 0\n        });\n      });\n    } else {\n      const level = calculateLevel(xpData.total_xp);\n      const currentLevelXp = xpForLevel(level);\n      const nextLevelXp = xpForNextLevel(level);\n      const progressPercent = Math.floor(((xpData.total_xp - currentLevelXp) / (nextLevelXp - currentLevelXp)) * 100);\n      \n      res.json({\n        ...xpData,\n        level,\n        xp_for_next_level: nextLevelXp,\n        progress_percent: progressPercent\n      });\n    }\n  });\n});\n\nconst XP_REWARDS = {\n  message: 5,\n  game: 20,\n  login: 10,\n  friend: 15,\n  task_complete: 10,\n  achievement: 0\n};\n\nconst userActivityTimestamps = new Map();\n\nrouter.post('/activity/:type', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  const { type } = req.params;\n  const reward = XP_REWARDS[type];\n  \n  if (reward === undefined) {\n    return res.status(400).json({ error: 'Invalid activity type' });\n  }\n\n  const now = Date.now();\n  const lastActivity = userActivityTimestamps.get(`${userId}_${type}`) || 0;\n  const cooldowns = { message: 2000, game: 30000, friend: 5000 };\n  const cooldown = cooldowns[type] || 1000;\n  \n  if (now - lastActivity < cooldown) {\n    return res.json({ success: true, xp_added: 0, cooldown: true });\n  }\n  userActivityTimestamps.set(`${userId}_${type}`, now);\n\n  if (reward === 0) {\n    return res.json({ success: true, xp_added: 0 });\n  }\n\n  const updateField = type === 'message' ? 'messages_sent = messages_sent + 1,' : \n                      type === 'game' ? 'games_played = games_played + 1,' : '';\n\n  db.run(`\n    INSERT INTO user_xp (user_id, total_xp, messages_sent, games_played) VALUES (?, ?, 0, 0)\n    ON CONFLICT(user_id) DO UPDATE SET \n      total_xp = user_xp.total_xp + ?,\n      ${updateField}\n      updated_at = CURRENT_TIMESTAMP\n  `, [userId, reward, reward], function(err) {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json({ success: true, xp_added: reward });\n  });\n});\n\nrouter.post('/claim-daily', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  db.get('SELECT * FROM user_xp WHERE user_id = ?', [userId], (err, xpData) => {\n    const now = new Date();\n    const lastClaim = xpData?.last_daily_claim ? new Date(xpData.last_daily_claim) : null;\n    \n    if (lastClaim && (now - lastClaim) < 24 * 60 * 60 * 1000) {\n      return res.status(400).json({ error: 'Already claimed today', next_claim: new Date(lastClaim.getTime() + 24 * 60 * 60 * 1000) });\n    }\n\n    const isConsecutive = lastClaim && (now - lastClaim) < 48 * 60 * 60 * 1000;\n    const newStreak = isConsecutive ? (xpData?.login_streak || 0) + 1 : 1;\n    const baseXp = 50;\n    const bonusXp = Math.min(newStreak * 10, 100);\n    const totalXp = baseXp + bonusXp;\n\n    db.run(`\n      INSERT INTO user_xp (user_id, total_xp, login_streak, last_daily_claim)\n      VALUES (?, ?, ?, CURRENT_TIMESTAMP)\n      ON CONFLICT(user_id) DO UPDATE SET\n        total_xp = user_xp.total_xp + ?,\n        login_streak = ?,\n        last_daily_claim = CURRENT_TIMESTAMP,\n        updated_at = CURRENT_TIMESTAMP\n    `, [userId, totalXp, newStreak, totalXp, newStreak], function(err) {\n      if (err) return res.status(500).json({ error: err.message });\n      \n      res.json({\n        success: true,\n        xp_earned: totalXp,\n        streak: newStreak,\n        bonus_xp: bonusXp\n      });\n    });\n  });\n});\n\nrouter.post('/activity/:type', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  const { type } = req.params;\n  let xpAmount = 0;\n  let column = null;\n\n  switch(type) {\n    case 'message':\n      xpAmount = 2;\n      column = 'messages_sent';\n      break;\n    case 'game':\n      xpAmount = 10;\n      column = 'games_played';\n      break;\n    default:\n      return res.status(400).json({ error: 'Invalid activity type' });\n  }\n\n  db.run(`\n    INSERT INTO user_xp (user_id, total_xp, ${column})\n    VALUES (?, ?, 1)\n    ON CONFLICT(user_id) DO UPDATE SET\n      total_xp = user_xp.total_xp + ?,\n      ${column} = user_xp.${column} + 1,\n      updated_at = CURRENT_TIMESTAMP\n  `, [userId, xpAmount, xpAmount], function(err) {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json({ success: true, xp_earned: xpAmount });\n  });\n});\n\nrouter.get('/leaderboard', (req, res) => {\n  const { type = 'xp', limit = 20 } = req.query;\n  \n  let orderBy = 'total_xp DESC';\n  if (type === 'messages') orderBy = 'messages_sent DESC';\n  if (type === 'games') orderBy = 'games_played DESC';\n  if (type === 'streak') orderBy = 'login_streak DESC';\n\n  db.all(`\n    SELECT u.id, u.username, u.profile_picture, x.total_xp, x.messages_sent, x.games_played, x.login_streak\n    FROM user_xp x\n    JOIN users u ON x.user_id = u.id\n    ORDER BY ${orderBy}\n    LIMIT ?\n  `, [parseInt(limit)], (err, rows) => {\n    if (err) return res.status(500).json({ error: err.message });\n    \n    const leaderboard = rows.map((row, index) => ({\n      rank: index + 1,\n      ...row,\n      level: calculateLevel(row.total_xp)\n    }));\n    \n    res.json(leaderboard);\n  });\n});\n\nrouter.get('/achievements', (req, res) => {\n  db.all('SELECT * FROM achievements ORDER BY category, requirement_value', [], (err, achievements) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(achievements);\n  });\n});\n\nrouter.get('/my-achievements', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  db.all(`\n    SELECT a.*, ua.earned_at\n    FROM achievements a\n    LEFT JOIN user_achievements ua ON a.id = ua.achievement_id AND ua.user_id = ?\n    ORDER BY a.category, a.requirement_value\n  `, [userId], (err, achievements) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(achievements);\n  });\n});\n\nrouter.post('/check-achievements', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  db.get('SELECT * FROM user_xp WHERE user_id = ?', [userId], (err, xpData) => {\n    if (!xpData) return res.json({ new_achievements: [] });\n\n    const level = calculateLevel(xpData.total_xp);\n    const checks = {\n      messages: xpData.messages_sent,\n      games_played: xpData.games_played,\n      login_streak: xpData.login_streak,\n      level: level\n    };\n\n    db.all(`\n      SELECT a.* FROM achievements a\n      WHERE a.id NOT IN (SELECT achievement_id FROM user_achievements WHERE user_id = ?)\n    `, [userId], (err, unearned) => {\n      if (err) return res.status(500).json({ error: err.message });\n\n      const newAchievements = [];\n      unearned.forEach(ach => {\n        const value = checks[ach.requirement_type];\n        if (value !== undefined && value >= ach.requirement_value) {\n          newAchievements.push(ach);\n          db.run('INSERT INTO user_achievements (user_id, achievement_id) VALUES (?, ?) ON CONFLICT DO NOTHING', \n            [userId, ach.id]);\n          if (ach.xp_reward > 0) {\n            db.run('UPDATE user_xp SET total_xp = total_xp + ? WHERE user_id = ?', [ach.xp_reward, userId]);\n          }\n        }\n      });\n\n      res.json({ new_achievements: newAchievements });\n    });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":8517,"size_tokens":null},"backend/routes/announcements.js":{"content":"const express = require('express');\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst router = express.Router();\nconst SECRET_KEY = 'real_user_auth_secret_2025';\n\nfunction getUserId(req) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return null;\n  try {\n    const decoded = jwt.verify(token, SECRET_KEY);\n    return decoded.userId;\n  } catch {\n    return null;\n  }\n}\n\nfunction isAdmin(req, callback) {\n  const userId = getUserId(req);\n  if (!userId) return callback(false);\n  \n  db.get('SELECT role FROM users WHERE id = ?', [userId], (err, user) => {\n    callback(user?.role === 'admin' || user?.role === 'moderator');\n  });\n}\n\nrouter.get('/', (req, res) => {\n  db.all(`\n    SELECT a.*, u.username as author_name\n    FROM announcements a\n    LEFT JOIN users u ON a.author_id = u.id\n    WHERE a.is_active = true \n    AND (a.expires_at IS NULL OR a.expires_at > CURRENT_TIMESTAMP)\n    ORDER BY a.created_at DESC\n    LIMIT 10\n  `, [], (err, announcements) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(announcements);\n  });\n});\n\nrouter.get('/latest', (req, res) => {\n  db.get(`\n    SELECT a.*, u.username as author_name\n    FROM announcements a\n    LEFT JOIN users u ON a.author_id = u.id\n    WHERE a.is_active = true \n    AND (a.expires_at IS NULL OR a.expires_at > CURRENT_TIMESTAMP)\n    ORDER BY a.created_at DESC\n    LIMIT 1\n  `, [], (err, announcement) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(announcement || null);\n  });\n});\n\nrouter.post('/', (req, res) => {\n  isAdmin(req, (admin) => {\n    if (!admin) return res.status(403).json({ error: 'Admin only' });\n\n    const userId = getUserId(req);\n    const { title, content, type, expires_in_hours } = req.body;\n\n    if (!title || !content) {\n      return res.status(400).json({ error: 'Title and content required' });\n    }\n\n    let expiresAt = null;\n    if (expires_in_hours) {\n      expiresAt = new Date(Date.now() + expires_in_hours * 60 * 60 * 1000).toISOString();\n    }\n\n    db.run(`\n      INSERT INTO announcements (title, content, author_id, type, expires_at)\n      VALUES (?, ?, ?, ?, ?)\n    `, [title, content, userId, type || 'info', expiresAt], function(err) {\n      if (err) return res.status(500).json({ error: err.message });\n      res.json({ success: true, id: this.lastID });\n    });\n  });\n});\n\nrouter.put('/:id', (req, res) => {\n  isAdmin(req, (admin) => {\n    if (!admin) return res.status(403).json({ error: 'Admin only' });\n\n    const { id } = req.params;\n    const { title, content, type, is_active } = req.body;\n\n    db.run(`\n      UPDATE announcements SET title = ?, content = ?, type = ?, is_active = ?\n      WHERE id = ?\n    `, [title, content, type, is_active, id], function(err) {\n      if (err) return res.status(500).json({ error: err.message });\n      if (this.changes === 0) return res.status(404).json({ error: 'Announcement not found' });\n      res.json({ success: true });\n    });\n  });\n});\n\nrouter.delete('/:id', (req, res) => {\n  isAdmin(req, (admin) => {\n    if (!admin) return res.status(403).json({ error: 'Admin only' });\n\n    const { id } = req.params;\n\n    db.run('DELETE FROM announcements WHERE id = ?', [id], function(err) {\n      if (err) return res.status(500).json({ error: err.message });\n      if (this.changes === 0) return res.status(404).json({ error: 'Announcement not found' });\n      res.json({ success: true });\n    });\n  });\n});\n\nrouter.get('/all', (req, res) => {\n  isAdmin(req, (admin) => {\n    if (!admin) return res.status(403).json({ error: 'Admin only' });\n\n    db.all(`\n      SELECT a.*, u.username as author_name\n      FROM announcements a\n      LEFT JOIN users u ON a.author_id = u.id\n      ORDER BY a.created_at DESC\n    `, [], (err, announcements) => {\n      if (err) return res.status(500).json({ error: err.message });\n      res.json(announcements);\n    });\n  });\n});\n\nrouter.get('/active', (req, res) => {\n  db.all(`\n    SELECT a.*, u.username as author_name\n    FROM announcements a\n    LEFT JOIN users u ON a.author_id = u.id\n    WHERE a.is_active = true \n    AND (a.expires_at IS NULL OR a.expires_at > CURRENT_TIMESTAMP)\n    ORDER BY a.created_at DESC\n  `, [], (err, announcements) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json(announcements || []);\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":4384,"size_tokens":null},"backend/logger.js":{"content":"const db = require('./db');\n\nconst ActivityLogger = {\n  log(category, action, details = {}, userId = null) {\n    const timestamp = new Date().toISOString();\n    const detailsJson = JSON.stringify(details);\n    \n    db.run(`\n      INSERT INTO activity_log (category, action, details, user_id, created_at)\n      VALUES ($1, $2, $3, $4, $5)\n    `, [category, action, detailsJson, userId, timestamp], (err) => {\n      if (err) {\n        console.error('[Logger Error]', err.message);\n      }\n    });\n    \n    const logMessage = `[${timestamp}] [${category.toUpperCase()}] ${action}`;\n    if (Object.keys(details).length > 0) {\n      console.log(logMessage, details);\n    } else {\n      console.log(logMessage);\n    }\n  },\n\n  user(action, details = {}, userId = null) {\n    this.log('user', action, details, userId);\n  },\n\n  auth(action, details = {}, userId = null) {\n    this.log('auth', action, details, userId);\n  },\n\n  server(action, details = {}, userId = null) {\n    this.log('server', action, details, userId);\n  },\n\n  channel(action, details = {}, userId = null) {\n    this.log('channel', action, details, userId);\n  },\n\n  message(action, details = {}, userId = null) {\n    this.log('message', action, details, userId);\n  },\n\n  moderation(action, details = {}, userId = null) {\n    this.log('moderation', action, details, userId);\n  },\n\n  shop(action, details = {}, userId = null) {\n    this.log('shop', action, details, userId);\n  },\n\n  xp(action, details = {}, userId = null) {\n    this.log('xp', action, details, userId);\n  },\n\n  system(action, details = {}) {\n    this.log('system', action, details, null);\n  },\n\n  error(action, details = {}, userId = null) {\n    this.log('error', action, details, userId);\n    console.error(`[ERROR] ${action}`, details);\n  }\n};\n\nmodule.exports = ActivityLogger;\n","path":null,"size_bytes":1805,"size_tokens":null},"backend/routes/activity-log.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'real_user_auth_secret_2025';\n\nconst authenticateAdmin = (req, res, next) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n  \n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n    req.user = decoded;\n    \n    db.get('SELECT role FROM users WHERE id = ?', [decoded.userId], (err, user) => {\n      if (err || !user || user.role !== 'admin') {\n        return res.status(403).json({ error: 'Admin access required' });\n      }\n      next();\n    });\n  } catch {\n    return res.status(403).json({ error: 'Invalid token' });\n  }\n};\n\nrouter.get('/', authenticateAdmin, (req, res) => {\n  const limit = parseInt(req.query.limit) || 100;\n  const offset = parseInt(req.query.offset) || 0;\n  const category = req.query.category;\n  \n  let query = `\n    SELECT al.*, u.username\n    FROM activity_log al\n    LEFT JOIN users u ON al.user_id = u.id\n  `;\n  const params = [];\n  \n  if (category) {\n    query += ' WHERE al.category = ?';\n    params.push(category);\n  }\n  \n  query += ' ORDER BY al.created_at DESC LIMIT ? OFFSET ?';\n  params.push(limit, offset);\n  \n  db.all(query, params, (err, logs) => {\n    if (err) return res.status(500).json({ error: 'Failed to fetch logs' });\n    \n    const formatted = (logs || []).map(log => ({\n      id: log.id,\n      category: log.category,\n      action: log.action,\n      details: log.details ? JSON.parse(log.details) : null,\n      userId: log.user_id,\n      username: log.username,\n      createdAt: log.created_at\n    }));\n    \n    res.json(formatted);\n  });\n});\n\nrouter.get('/categories', authenticateAdmin, (req, res) => {\n  db.all(`\n    SELECT DISTINCT category, COUNT(*) as count\n    FROM activity_log\n    GROUP BY category\n    ORDER BY count DESC\n  `, [], (err, categories) => {\n    if (err) return res.status(500).json({ error: 'Failed to fetch categories' });\n    res.json(categories || []);\n  });\n});\n\nrouter.get('/stats', authenticateAdmin, (req, res) => {\n  db.get(`\n    SELECT \n      COUNT(*) as total,\n      COUNT(CASE WHEN created_at > NOW() - INTERVAL '1 hour' THEN 1 END) as last_hour,\n      COUNT(CASE WHEN created_at > NOW() - INTERVAL '24 hours' THEN 1 END) as last_24h,\n      COUNT(CASE WHEN category = 'error' THEN 1 END) as errors\n    FROM activity_log\n  `, [], (err, stats) => {\n    if (err) return res.status(500).json({ error: 'Failed to fetch stats' });\n    res.json(stats || { total: 0, last_hour: 0, last_24h: 0, errors: 0 });\n  });\n});\n\nrouter.delete('/clear', authenticateAdmin, (req, res) => {\n  const olderThan = req.query.days || 30;\n  \n  db.run(`DELETE FROM activity_log WHERE created_at < NOW() - INTERVAL '? days'`, [olderThan], function(err) {\n    if (err) return res.status(500).json({ error: 'Failed to clear logs' });\n    res.json({ success: true, deleted: this.changes });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":3053,"size_tokens":null},"backend/routes/forums.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'super-secret-key-change-in-production';\n\nfunction optionalAuth(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (token) {\n    try {\n      req.user = jwt.verify(token, JWT_SECRET);\n    } catch (err) {\n      req.user = null;\n    }\n  }\n  next();\n}\n\nfunction authenticate(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n  \n  try {\n    req.user = jwt.verify(token, JWT_SECRET);\n    next();\n  } catch (err) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\nrouter.get('/categories', (req, res) => {\n  db.all(`\n    SELECT fc.*, \n           (SELECT COUNT(*) FROM forum_posts WHERE category_id = fc.id) as post_count,\n           (SELECT MAX(created_at) FROM forum_posts WHERE category_id = fc.id) as last_post_at\n    FROM forum_categories fc \n    ORDER BY fc.position ASC\n  `, [], (err, rows) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json({ categories: rows || [] });\n  });\n});\n\nrouter.get('/posts', (req, res) => {\n  const { category, page = 1, limit = 20, sort = 'newest' } = req.query;\n  const offset = (page - 1) * limit;\n  \n  let orderBy = 'fp.is_pinned DESC, fp.created_at DESC';\n  if (sort === 'popular') orderBy = 'fp.is_pinned DESC, (fp.upvotes - fp.downvotes) DESC';\n  if (sort === 'views') orderBy = 'fp.is_pinned DESC, fp.views DESC';\n  \n  let whereClause = '';\n  let params = [];\n  \n  if (category) {\n    whereClause = 'WHERE fp.category_id = ?';\n    params = [category];\n  }\n  \n  db.all(`\n    SELECT fp.*, fc.name as category_name, fc.icon as category_icon,\n           (SELECT COUNT(*) FROM forum_replies WHERE post_id = fp.id) as reply_count\n    FROM forum_posts fp\n    JOIN forum_categories fc ON fp.category_id = fc.id\n    ${whereClause}\n    ORDER BY ${orderBy}\n    LIMIT ? OFFSET ?\n  `, [...params, parseInt(limit), parseInt(offset)], (err, rows) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json({ posts: rows || [] });\n  });\n});\n\nrouter.get('/posts/:id', optionalAuth, (req, res) => {\n  const { id } = req.params;\n  \n  db.run('UPDATE forum_posts SET views = views + 1 WHERE id = ?', [id], () => {});\n  \n  db.get(`\n    SELECT fp.*, fc.name as category_name, fc.icon as category_icon\n    FROM forum_posts fp\n    JOIN forum_categories fc ON fp.category_id = fc.id\n    WHERE fp.id = ?\n  `, [id], (err, post) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!post) return res.status(404).json({ error: 'Post not found' });\n    \n    db.all(`\n      SELECT * FROM forum_replies \n      WHERE post_id = ? \n      ORDER BY created_at ASC\n    `, [id], (err, replies) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      res.json({ post, replies: replies || [] });\n    });\n  });\n});\n\nrouter.post('/posts', optionalAuth, (req, res) => {\n  const { categoryId, title, content, anonymousName } = req.body;\n  \n  if (!categoryId || !title || !content) {\n    return res.status(400).json({ error: 'Category, title, and content are required' });\n  }\n  \n  if (title.length > 200) {\n    return res.status(400).json({ error: 'Title must be 200 characters or less' });\n  }\n  \n  if (content.length > 10000) {\n    return res.status(400).json({ error: 'Content must be 10000 characters or less' });\n  }\n  \n  const userId = req.user?.id || null;\n  const anonName = anonymousName?.trim().slice(0, 30) || 'Anonymous';\n  \n  db.run(`\n    INSERT INTO forum_posts (category_id, title, content, anonymous_name, user_id)\n    VALUES (?, ?, ?, ?, ?)\n  `, [categoryId, title.trim(), content.trim(), anonName, userId], function(err) {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json({ success: true, postId: this.lastID });\n  });\n});\n\nrouter.post('/posts/:id/reply', optionalAuth, (req, res) => {\n  const { id } = req.params;\n  const { content, anonymousName } = req.body;\n  \n  if (!content) {\n    return res.status(400).json({ error: 'Content is required' });\n  }\n  \n  if (content.length > 5000) {\n    return res.status(400).json({ error: 'Reply must be 5000 characters or less' });\n  }\n  \n  db.get('SELECT id, is_locked FROM forum_posts WHERE id = ?', [id], (err, post) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!post) return res.status(404).json({ error: 'Post not found' });\n    if (post.is_locked) return res.status(403).json({ error: 'This post is locked' });\n    \n    const userId = req.user?.id || null;\n    const anonName = anonymousName?.trim().slice(0, 30) || 'Anonymous';\n    \n    db.run(`\n      INSERT INTO forum_replies (post_id, content, anonymous_name, user_id)\n      VALUES (?, ?, ?, ?)\n    `, [id, content.trim(), anonName, userId], function(err) {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      res.json({ success: true, replyId: this.lastID });\n    });\n  });\n});\n\nrouter.post('/vote', authenticate, (req, res) => {\n  const { postId, replyId, voteType } = req.body;\n  const userId = req.user.id;\n  \n  if (!voteType || !['up', 'down'].includes(voteType)) {\n    return res.status(400).json({ error: 'Invalid vote type' });\n  }\n  \n  if (!postId && !replyId) {\n    return res.status(400).json({ error: 'Post ID or Reply ID required' });\n  }\n  \n  const pId = postId || null;\n  const rId = replyId || null;\n  \n  db.get('SELECT * FROM forum_votes WHERE user_id = ? AND post_id IS NOT DISTINCT FROM ? AND reply_id IS NOT DISTINCT FROM ?',\n    [userId, pId, rId], (err, existing) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      \n      if (existing) {\n        if (existing.vote_type === voteType) {\n          db.run('DELETE FROM forum_votes WHERE id = ?', [existing.id], (err) => {\n            if (err) return res.status(500).json({ error: 'Database error' });\n            \n            const table = postId ? 'forum_posts' : 'forum_replies';\n            const column = voteType === 'up' ? 'upvotes' : 'downvotes';\n            const targetId = postId || replyId;\n            \n            db.run(`UPDATE ${table} SET ${column} = ${column} - 1 WHERE id = ?`, [targetId], (err) => {\n              if (err) return res.status(500).json({ error: 'Database error' });\n              res.json({ success: true, action: 'removed' });\n            });\n          });\n        } else {\n          db.run('UPDATE forum_votes SET vote_type = ? WHERE id = ?', [voteType, existing.id], (err) => {\n            if (err) return res.status(500).json({ error: 'Database error' });\n            \n            const table = postId ? 'forum_posts' : 'forum_replies';\n            const targetId = postId || replyId;\n            const addCol = voteType === 'up' ? 'upvotes' : 'downvotes';\n            const subCol = voteType === 'up' ? 'downvotes' : 'upvotes';\n            \n            db.run(`UPDATE ${table} SET ${addCol} = ${addCol} + 1, ${subCol} = ${subCol} - 1 WHERE id = ?`, [targetId], (err) => {\n              if (err) return res.status(500).json({ error: 'Database error' });\n              res.json({ success: true, action: 'changed' });\n            });\n          });\n        }\n      } else {\n        db.run('INSERT INTO forum_votes (user_id, post_id, reply_id, vote_type) VALUES (?, ?, ?, ?)',\n          [userId, pId, rId, voteType], function(err) {\n            if (err) return res.status(500).json({ error: 'Database error' });\n            \n            const table = postId ? 'forum_posts' : 'forum_replies';\n            const column = voteType === 'up' ? 'upvotes' : 'downvotes';\n            const targetId = postId || replyId;\n            \n            db.run(`UPDATE ${table} SET ${column} = ${column} + 1 WHERE id = ?`, [targetId], (err) => {\n              if (err) return res.status(500).json({ error: 'Database error' });\n              res.json({ success: true, action: 'added' });\n            });\n          });\n      }\n    });\n});\n\nrouter.get('/search', (req, res) => {\n  const { q, limit = 20 } = req.query;\n  \n  if (!q || q.length < 2) {\n    return res.status(400).json({ error: 'Search query must be at least 2 characters' });\n  }\n  \n  const searchTerm = `%${q}%`;\n  \n  db.all(`\n    SELECT fp.*, fc.name as category_name, fc.icon as category_icon,\n           (SELECT COUNT(*) FROM forum_replies WHERE post_id = fp.id) as reply_count\n    FROM forum_posts fp\n    JOIN forum_categories fc ON fp.category_id = fc.id\n    WHERE fp.title ILIKE ? OR fp.content ILIKE ?\n    ORDER BY fp.created_at DESC\n    LIMIT ?\n  `, [searchTerm, searchTerm, parseInt(limit)], (err, rows) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json({ posts: rows || [] });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":8902,"size_tokens":null},"backend/routes/widgets.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'super-secret-key-change-in-production';\n\nfunction authenticate(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n  \n  try {\n    req.user = jwt.verify(token, JWT_SECRET);\n    next();\n  } catch (err) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\nconst WIDGET_TYPES = [\n  { id: 'stats', name: 'My Stats', description: 'Display your XP, level, and achievements' },\n  { id: 'recent_games', name: 'Recent Games', description: 'Show recently played games' },\n  { id: 'leaderboard', name: 'Leaderboard', description: 'Top players widget' },\n  { id: 'friends', name: 'Friends Online', description: 'Show online friends' },\n  { id: 'announcements', name: 'Announcements', description: 'Latest announcements' },\n  { id: 'tasks', name: 'My Tasks', description: 'Your personal task list' },\n  { id: 'clock', name: 'Clock', description: 'Digital or analog clock' },\n  { id: 'calendar', name: 'Calendar', description: 'Mini calendar widget' },\n  { id: 'notes', name: 'Quick Notes', description: 'Personal notes widget' },\n  { id: 'weather', name: 'Weather', description: 'Current weather display' }\n];\n\n// Get available widget types\nrouter.get('/types', (req, res) => {\n  res.json({ widgetTypes: WIDGET_TYPES });\n});\n\n// Get user's widgets\nrouter.get('/', authenticate, (req, res) => {\n  const userId = req.user.id;\n  \n  db.all('SELECT * FROM user_widgets WHERE user_id = ? ORDER BY position_y, position_x', \n    [userId], (err, rows) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      res.json({ widgets: rows || [] });\n    });\n});\n\n// Add a widget\nrouter.post('/', authenticate, (req, res) => {\n  const userId = req.user.id;\n  const { widgetType, config = {}, positionX = 0, positionY = 0, width = 1, height = 1 } = req.body;\n  \n  if (!widgetType || !WIDGET_TYPES.find(w => w.id === widgetType)) {\n    return res.status(400).json({ error: 'Invalid widget type' });\n  }\n  \n  db.run(`\n    INSERT INTO user_widgets (user_id, widget_type, widget_config, position_x, position_y, width, height) \n    VALUES (?, ?, ?, ?, ?, ?, ?)\n  `, [userId, widgetType, JSON.stringify(config), positionX, positionY, width, height], function(err) {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json({ success: true, widgetId: this.lastID });\n  });\n});\n\n// Update a widget\nrouter.put('/:widgetId', authenticate, (req, res) => {\n  const { widgetId } = req.params;\n  const userId = req.user.id;\n  const { config, positionX, positionY, width, height, enabled } = req.body;\n  \n  const updates = [];\n  const params = [];\n  \n  if (config !== undefined) { updates.push('widget_config = ?'); params.push(JSON.stringify(config)); }\n  if (positionX !== undefined) { updates.push('position_x = ?'); params.push(positionX); }\n  if (positionY !== undefined) { updates.push('position_y = ?'); params.push(positionY); }\n  if (width !== undefined) { updates.push('width = ?'); params.push(width); }\n  if (height !== undefined) { updates.push('height = ?'); params.push(height); }\n  if (enabled !== undefined) { updates.push('enabled = ?'); params.push(enabled); }\n  \n  if (updates.length === 0) {\n    return res.status(400).json({ error: 'No updates provided' });\n  }\n  \n  params.push(widgetId, userId);\n  \n  db.run(`UPDATE user_widgets SET ${updates.join(', ')} WHERE id = ? AND user_id = ?`, \n    params, function(err) {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      if (this.changes === 0) return res.status(404).json({ error: 'Widget not found' });\n      res.json({ success: true });\n    });\n});\n\n// Delete a widget\nrouter.delete('/:widgetId', authenticate, (req, res) => {\n  const { widgetId } = req.params;\n  const userId = req.user.id;\n  \n  db.run('DELETE FROM user_widgets WHERE id = ? AND user_id = ?', \n    [widgetId, userId], function(err) {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      if (this.changes === 0) return res.status(404).json({ error: 'Widget not found' });\n      res.json({ success: true });\n    });\n});\n\n// Reset widgets to default layout\nrouter.post('/reset', authenticate, (req, res) => {\n  const userId = req.user.id;\n  \n  db.run('DELETE FROM user_widgets WHERE user_id = ?', [userId], function(err) {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    \n    // Insert default widgets\n    const defaultWidgets = [\n      { type: 'stats', x: 0, y: 0, w: 1, h: 1 },\n      { type: 'recent_games', x: 1, y: 0, w: 2, h: 1 },\n      { type: 'friends', x: 0, y: 1, w: 1, h: 1 },\n      { type: 'announcements', x: 1, y: 1, w: 2, h: 1 }\n    ];\n    \n    let completed = 0;\n    defaultWidgets.forEach(w => {\n      db.run(`\n        INSERT INTO user_widgets (user_id, widget_type, position_x, position_y, width, height) \n        VALUES (?, ?, ?, ?, ?, ?)\n      `, [userId, w.type, w.x, w.y, w.w, w.h], () => {\n        completed++;\n        if (completed === defaultWidgets.length) {\n          res.json({ success: true, message: 'Widgets reset to default' });\n        }\n      });\n    });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":5341,"size_tokens":null},"backend/routes/youtube.js":{"content":"const express = require('express');\nconst router = express.Router();\n\nconst YOUTUBE_API_KEY = process.env.YOUTUBE_API_KEY;\nconst YOUTUBE_API_BASE = 'https://www.googleapis.com/youtube/v3';\n\nrouter.get('/search', async (req, res) => {\n  try {\n    const { q, maxResults = 12, pageToken = '' } = req.query;\n    \n    if (!q) {\n      return res.status(400).json({ error: 'Search query required' });\n    }\n\n    if (!YOUTUBE_API_KEY) {\n      return res.status(500).json({ error: 'YouTube API key not configured' });\n    }\n\n    const params = new URLSearchParams({\n      part: 'snippet',\n      q: q,\n      type: 'video',\n      maxResults: maxResults,\n      key: YOUTUBE_API_KEY,\n      safeSearch: 'strict'\n    });\n\n    if (pageToken) {\n      params.append('pageToken', pageToken);\n    }\n\n    const response = await fetch(`${YOUTUBE_API_BASE}/search?${params}`);\n    const data = await response.json();\n\n    if (data.error) {\n      console.error('YouTube API error:', data.error);\n      return res.status(500).json({ error: 'YouTube API error' });\n    }\n\n    const videos = data.items.map(item => ({\n      id: item.id.videoId,\n      title: item.snippet.title,\n      description: item.snippet.description,\n      thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.medium?.url,\n      channelTitle: item.snippet.channelTitle,\n      publishedAt: item.snippet.publishedAt\n    }));\n\n    res.json({\n      videos,\n      nextPageToken: data.nextPageToken || null,\n      totalResults: data.pageInfo?.totalResults || 0\n    });\n  } catch (err) {\n    console.error('YouTube search error:', err);\n    res.status(500).json({ error: 'Failed to search YouTube' });\n  }\n});\n\nrouter.get('/video/:videoId', async (req, res) => {\n  try {\n    const { videoId } = req.params;\n\n    if (!YOUTUBE_API_KEY) {\n      return res.status(500).json({ error: 'YouTube API key not configured' });\n    }\n\n    const params = new URLSearchParams({\n      part: 'snippet,statistics,contentDetails',\n      id: videoId,\n      key: YOUTUBE_API_KEY\n    });\n\n    const response = await fetch(`${YOUTUBE_API_BASE}/videos?${params}`);\n    const data = await response.json();\n\n    if (data.error || !data.items?.length) {\n      return res.status(404).json({ error: 'Video not found' });\n    }\n\n    const video = data.items[0];\n    res.json({\n      id: video.id,\n      title: video.snippet.title,\n      description: video.snippet.description,\n      thumbnail: video.snippet.thumbnails.maxres?.url || video.snippet.thumbnails.high?.url,\n      channelTitle: video.snippet.channelTitle,\n      publishedAt: video.snippet.publishedAt,\n      viewCount: video.statistics.viewCount,\n      likeCount: video.statistics.likeCount,\n      duration: video.contentDetails.duration\n    });\n  } catch (err) {\n    console.error('YouTube video error:', err);\n    res.status(500).json({ error: 'Failed to fetch video details' });\n  }\n});\n\nrouter.get('/trending', async (req, res) => {\n  try {\n    const { category = 'education', maxResults = 12 } = req.query;\n\n    if (!YOUTUBE_API_KEY) {\n      return res.status(500).json({ error: 'YouTube API key not configured' });\n    }\n\n    const searchTerms = {\n      education: 'educational videos for students',\n      science: 'science experiments explained',\n      music: 'popular music 2024',\n      gaming: 'gaming videos',\n      entertainment: 'entertainment videos'\n    };\n\n    const params = new URLSearchParams({\n      part: 'snippet',\n      q: searchTerms[category] || 'educational videos',\n      type: 'video',\n      maxResults: maxResults,\n      order: 'viewCount',\n      safeSearch: 'strict',\n      key: YOUTUBE_API_KEY\n    });\n\n    const response = await fetch(`${YOUTUBE_API_BASE}/search?${params}`);\n    const data = await response.json();\n\n    if (data.error) {\n      console.error('YouTube API error:', data.error);\n      return res.status(500).json({ error: 'YouTube API error' });\n    }\n\n    const videos = (data.items || []).map(item => ({\n      id: item.id.videoId,\n      title: item.snippet.title,\n      description: item.snippet.description,\n      thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.medium?.url,\n      channelTitle: item.snippet.channelTitle,\n      publishedAt: item.snippet.publishedAt\n    }));\n\n    res.json({ videos });\n  } catch (err) {\n    console.error('YouTube trending error:', err);\n    res.status(500).json({ error: 'Failed to fetch trending videos' });\n  }\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":4440,"size_tokens":null},"backend/routes/speedruns.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'super-secret-key-change-in-production';\n\nfunction authenticate(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n  \n  try {\n    req.user = jwt.verify(token, JWT_SECRET);\n    next();\n  } catch (err) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\n// Get speedrun leaderboard for a game\nrouter.get('/:gameName', (req, res) => {\n  const { gameName } = req.params;\n  const { category = 'any%', limit = 10 } = req.query;\n  \n  db.all(`\n    SELECT sr.*, u.username, u.profile_picture \n    FROM speedrun_records sr \n    JOIN users u ON sr.user_id = u.id \n    WHERE sr.game_name = ? AND sr.category = ?\n    ORDER BY sr.time_ms ASC \n    LIMIT ?\n  `, [gameName, category, parseInt(limit)], (err, rows) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json({ speedruns: rows || [] });\n  });\n});\n\n// Get all categories for a game\nrouter.get('/:gameName/categories', (req, res) => {\n  const { gameName } = req.params;\n  \n  db.all(`\n    SELECT DISTINCT category, COUNT(*) as run_count, MIN(time_ms) as best_time\n    FROM speedrun_records \n    WHERE game_name = ?\n    GROUP BY category\n    ORDER BY run_count DESC\n  `, [gameName], (err, rows) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json({ categories: rows || [] });\n  });\n});\n\n// Submit a speedrun time\nrouter.post('/submit', authenticate, (req, res) => {\n  const { gameName, timeMs, category = 'any%' } = req.body;\n  const userId = req.user.id;\n  \n  if (!gameName || !timeMs) {\n    return res.status(400).json({ error: 'Game name and time required' });\n  }\n  \n  // Get user's current best for this game/category\n  db.get(`\n    SELECT * FROM speedrun_records \n    WHERE user_id = ? AND game_name = ? AND category = ?\n    ORDER BY time_ms ASC LIMIT 1\n  `, [userId, gameName, category], (err, existing) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    \n    const isPersonalBest = !existing || timeMs < existing.time_ms;\n    \n    // Always insert the run (keep history)\n    db.run(`\n      INSERT INTO speedrun_records (user_id, game_name, time_ms, category) \n      VALUES (?, ?, ?, ?)\n    `, [userId, gameName, timeMs, category], function(err) {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      \n      // Check if this is a world record\n      db.get(`\n        SELECT MIN(time_ms) as world_record FROM speedrun_records \n        WHERE game_name = ? AND category = ?\n      `, [gameName, category], (err, wr) => {\n        const isWorldRecord = !wr || timeMs <= wr.world_record;\n        res.json({ \n          success: true, \n          runId: this.lastID,\n          isPersonalBest,\n          isWorldRecord,\n          previousBest: existing?.time_ms || null\n        });\n      });\n    });\n  });\n});\n\n// Get user's personal best speedrun\nrouter.get('/personal/:gameName', authenticate, (req, res) => {\n  const { gameName } = req.params;\n  const { category = 'any%' } = req.query;\n  const userId = req.user.id;\n  \n  db.get(`\n    SELECT * FROM speedrun_records \n    WHERE user_id = ? AND game_name = ? AND category = ?\n    ORDER BY time_ms ASC LIMIT 1\n  `, [userId, gameName, category], (err, row) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json({ personalBest: row || null });\n  });\n});\n\n// Get user's speedrun history for a game\nrouter.get('/history/:gameName', authenticate, (req, res) => {\n  const { gameName } = req.params;\n  const { category, limit = 20 } = req.query;\n  const userId = req.user.id;\n  \n  let query = `\n    SELECT * FROM speedrun_records \n    WHERE user_id = ? AND game_name = ?\n  `;\n  const params = [userId, gameName];\n  \n  if (category) {\n    query += ' AND category = ?';\n    params.push(category);\n  }\n  \n  query += ' ORDER BY achieved_at DESC LIMIT ?';\n  params.push(parseInt(limit));\n  \n  db.all(query, params, (err, rows) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json({ history: rows || [] });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":4302,"size_tokens":null},"backend/routes/themes.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'super-secret-key-change-in-production';\n\nfunction authenticate(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n  \n  try {\n    req.user = jwt.verify(token, JWT_SECRET);\n    next();\n  } catch (err) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\n// Get user's custom themes\nrouter.get('/my', authenticate, (req, res) => {\n  const userId = req.user.id;\n  \n  db.all('SELECT * FROM custom_themes WHERE user_id = ? ORDER BY updated_at DESC', \n    [userId], (err, rows) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      res.json({ themes: rows || [] });\n    });\n});\n\n// Get public themes (theme gallery)\nrouter.get('/public', (req, res) => {\n  const { limit = 20, offset = 0 } = req.query;\n  \n  db.all(`\n    SELECT ct.*, u.username as creator_name \n    FROM custom_themes ct \n    JOIN users u ON ct.user_id = u.id \n    WHERE ct.is_public = true \n    ORDER BY ct.uses_count DESC, ct.created_at DESC \n    LIMIT ? OFFSET ?\n  `, [parseInt(limit), parseInt(offset)], (err, rows) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json({ themes: rows || [] });\n  });\n});\n\n// Get a specific theme\nrouter.get('/:themeId', (req, res) => {\n  const { themeId } = req.params;\n  \n  db.get(`\n    SELECT ct.*, u.username as creator_name \n    FROM custom_themes ct \n    JOIN users u ON ct.user_id = u.id \n    WHERE ct.id = ?\n  `, [themeId], (err, row) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    if (!row) return res.status(404).json({ error: 'Theme not found' });\n    \n    // Only return if public or owner\n    if (!row.is_public) {\n      const token = req.headers.authorization?.split(' ')[1];\n      if (token) {\n        try {\n          const user = jwt.verify(token, JWT_SECRET);\n          if (user.id !== row.user_id) {\n            return res.status(403).json({ error: 'Private theme' });\n          }\n        } catch {\n          return res.status(403).json({ error: 'Private theme' });\n        }\n      } else {\n        return res.status(403).json({ error: 'Private theme' });\n      }\n    }\n    \n    res.json({ theme: row });\n  });\n});\n\n// Create a new custom theme\nrouter.post('/', authenticate, (req, res) => {\n  const userId = req.user.id;\n  const { name, themeData, isPublic = false } = req.body;\n  \n  if (!name || !themeData) {\n    return res.status(400).json({ error: 'Name and theme data required' });\n  }\n  \n  if (name.length > 50) {\n    return res.status(400).json({ error: 'Name too long (max 50 characters)' });\n  }\n  \n  // Validate theme data structure\n  try {\n    const data = typeof themeData === 'string' ? JSON.parse(themeData) : themeData;\n    if (!data.colors || !data.name) {\n      return res.status(400).json({ error: 'Invalid theme data structure' });\n    }\n  } catch {\n    return res.status(400).json({ error: 'Invalid JSON in theme data' });\n  }\n  \n  const themeDataStr = typeof themeData === 'string' ? themeData : JSON.stringify(themeData);\n  \n  db.run(`\n    INSERT INTO custom_themes (user_id, name, theme_data, is_public) \n    VALUES (?, ?, ?, ?)\n    ON CONFLICT (user_id, name) DO UPDATE SET \n      theme_data = EXCLUDED.theme_data,\n      is_public = EXCLUDED.is_public,\n      updated_at = CURRENT_TIMESTAMP\n  `, [userId, name, themeDataStr, isPublic], function(err) {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json({ success: true, themeId: this.lastID });\n  });\n});\n\n// Update a theme\nrouter.put('/:themeId', authenticate, (req, res) => {\n  const { themeId } = req.params;\n  const userId = req.user.id;\n  const { name, themeData, isPublic } = req.body;\n  \n  const updates = [];\n  const params = [];\n  \n  if (name !== undefined) { updates.push('name = ?'); params.push(name); }\n  if (themeData !== undefined) { \n    updates.push('theme_data = ?'); \n    params.push(typeof themeData === 'string' ? themeData : JSON.stringify(themeData)); \n  }\n  if (isPublic !== undefined) { updates.push('is_public = ?'); params.push(isPublic); }\n  updates.push('updated_at = CURRENT_TIMESTAMP');\n  \n  params.push(themeId, userId);\n  \n  db.run(`UPDATE custom_themes SET ${updates.join(', ')} WHERE id = ? AND user_id = ?`, \n    params, function(err) {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      if (this.changes === 0) return res.status(404).json({ error: 'Theme not found' });\n      res.json({ success: true });\n    });\n});\n\n// Delete a theme\nrouter.delete('/:themeId', authenticate, (req, res) => {\n  const { themeId } = req.params;\n  const userId = req.user.id;\n  \n  db.run('DELETE FROM custom_themes WHERE id = ? AND user_id = ?', \n    [themeId, userId], function(err) {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      if (this.changes === 0) return res.status(404).json({ error: 'Theme not found' });\n      res.json({ success: true });\n    });\n});\n\n// Use a public theme (increment uses count)\nrouter.post('/:themeId/use', authenticate, (req, res) => {\n  const { themeId } = req.params;\n  \n  db.run('UPDATE custom_themes SET uses_count = uses_count + 1 WHERE id = ? AND is_public = true', \n    [themeId], function(err) {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      res.json({ success: true });\n    });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":5571,"size_tokens":null},"backend/routes/leaderboards.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst db = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'super-secret-key-change-in-production';\n\nfunction authenticate(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n  \n  try {\n    req.user = jwt.verify(token, JWT_SECRET);\n    next();\n  } catch (err) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\n// Get global leaderboard (top players across all games) - MUST be before /:gameName\nrouter.get('/global/top', (req, res) => {\n  const { limit = 20 } = req.query;\n  \n  db.all(`\n    SELECT u.id, u.username, u.profile_picture, \n           COUNT(DISTINCT gl.game_name) as games_played,\n           SUM(gl.score) as total_score,\n           MAX(gl.score) as best_score\n    FROM game_leaderboards gl \n    JOIN users u ON gl.user_id = u.id \n    GROUP BY u.id, u.username, u.profile_picture \n    ORDER BY total_score DESC \n    LIMIT ?\n  `, [parseInt(limit)], (err, rows) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json({ leaderboard: rows || [] });\n  });\n});\n\n// Get leaderboard for a specific game\nrouter.get('/:gameName', (req, res) => {\n  const { gameName } = req.params;\n  const { limit = 10 } = req.query;\n  \n  db.all(`\n    SELECT gl.*, u.username, u.profile_picture \n    FROM game_leaderboards gl \n    JOIN users u ON gl.user_id = u.id \n    WHERE gl.game_name = ? \n    ORDER BY gl.score DESC \n    LIMIT ?\n  `, [gameName, parseInt(limit)], (err, rows) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json({ leaderboard: rows || [] });\n  });\n});\n\n// Submit a score\nrouter.post('/submit', authenticate, (req, res) => {\n  const { gameName, score, playTime = 0 } = req.body;\n  const userId = req.user.id;\n  \n  if (!gameName || score === undefined) {\n    return res.status(400).json({ error: 'Game name and score required' });\n  }\n  \n  // Check if user has existing score for this game\n  db.get('SELECT * FROM game_leaderboards WHERE user_id = ? AND game_name = ?', \n    [userId, gameName], (err, existing) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      \n      if (existing) {\n        // Only update if new score is higher\n        if (score > existing.score) {\n          db.run(`\n            UPDATE game_leaderboards \n            SET score = ?, play_time = ?, achieved_at = CURRENT_TIMESTAMP \n            WHERE user_id = ? AND game_name = ?\n          `, [score, playTime, userId, gameName], function(err) {\n            if (err) return res.status(500).json({ error: 'Database error' });\n            res.json({ success: true, newHighScore: true, previousScore: existing.score });\n          });\n        } else {\n          res.json({ success: true, newHighScore: false, currentBest: existing.score });\n        }\n      } else {\n        // Insert new score\n        db.run(`\n          INSERT INTO game_leaderboards (user_id, game_name, score, play_time) \n          VALUES (?, ?, ?, ?)\n        `, [userId, gameName, score, playTime], function(err) {\n          if (err) return res.status(500).json({ error: 'Database error' });\n          res.json({ success: true, newHighScore: true, firstScore: true });\n        });\n      }\n    });\n});\n\n// Get user's personal best for a game\nrouter.get('/personal/:gameName', authenticate, (req, res) => {\n  const { gameName } = req.params;\n  const userId = req.user.id;\n  \n  db.get('SELECT * FROM game_leaderboards WHERE user_id = ? AND game_name = ?', \n    [userId, gameName], (err, row) => {\n      if (err) return res.status(500).json({ error: 'Database error' });\n      res.json({ personalBest: row || null });\n    });\n});\n\n// Get user's rank for a specific game\nrouter.get('/rank/:gameName', authenticate, (req, res) => {\n  const { gameName } = req.params;\n  const userId = req.user.id;\n  \n  db.get(`\n    SELECT COUNT(*) + 1 as rank \n    FROM game_leaderboards \n    WHERE game_name = ? AND score > (\n      SELECT COALESCE(score, 0) FROM game_leaderboards \n      WHERE user_id = ? AND game_name = ?\n    )\n  `, [gameName, userId, gameName], (err, row) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json({ rank: row?.rank || null });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":4385,"size_tokens":null},"backend/routes/customization.js":{"content":"const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst multer = require('multer');\nconst path = require('path');\nconst fs = require('fs');\nconst db = require('../db');\n\nconst router = express.Router();\nconst JWT_SECRET = 'real_user_auth_secret_2025';\n\n// Configure multer for file uploads\nconst storage = multer.diskStorage({\n  destination: (req, file, cb) => {\n    const dir = path.join(__dirname, '../../frontend/uploads/customization');\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true });\n    }\n    cb(null, dir);\n  },\n  filename: (req, file, cb) => {\n    const ext = path.extname(file.originalname);\n    cb(null, `${Date.now()}-${Math.random().toString(36).substr(2, 9)}${ext}`);\n  }\n});\n\nconst upload = multer({ \n  storage,\n  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit\n  fileFilter: (req, file, cb) => {\n    const allowed = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];\n    const ext = path.extname(file.originalname).toLowerCase();\n    if (allowed.includes(ext)) {\n      cb(null, true);\n    } else {\n      cb(new Error('Only image files allowed'));\n    }\n  }\n});\n\nfunction getUserId(req) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return null;\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n    return decoded.userId;\n  } catch {\n    return null;\n  }\n}\n\n// Get user's customization settings\nrouter.get('/settings', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  db.get(`SELECT * FROM user_customization WHERE user_id = ?`, [userId], (err, settings) => {\n    if (err) {\n      console.error('Get customization error:', err);\n      return res.status(500).json({ error: 'Failed to get settings' });\n    }\n    res.json(settings || { \n      wallpaper_url: null, \n      wallpaper_type: 'default',\n      profile_banner_url: null,\n      dashboard_layout: '{}'\n    });\n  });\n});\n\n// Upload custom wallpaper\nrouter.post('/wallpaper', upload.single('wallpaper'), (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  if (!req.file) {\n    return res.status(400).json({ error: 'No file uploaded' });\n  }\n\n  const wallpaperUrl = `/uploads/customization/${req.file.filename}`;\n\n  db.run(`\n    INSERT INTO user_customization (user_id, wallpaper_url, wallpaper_type)\n    VALUES (?, ?, 'custom')\n    ON CONFLICT (user_id) \n    DO UPDATE SET wallpaper_url = EXCLUDED.wallpaper_url, wallpaper_type = 'custom', updated_at = CURRENT_TIMESTAMP\n  `, [userId, wallpaperUrl], function(err) {\n    if (err) {\n      console.error('Save wallpaper error:', err);\n      return res.status(500).json({ error: 'Failed to save wallpaper' });\n    }\n    res.json({ success: true, wallpaper_url: wallpaperUrl });\n  });\n});\n\n// Set wallpaper URL (for preset or external URLs)\nrouter.post('/wallpaper/url', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  const { url, type } = req.body;\n\n  db.run(`\n    INSERT INTO user_customization (user_id, wallpaper_url, wallpaper_type)\n    VALUES (?, ?, ?)\n    ON CONFLICT (user_id) \n    DO UPDATE SET wallpaper_url = EXCLUDED.wallpaper_url, wallpaper_type = EXCLUDED.wallpaper_type, updated_at = CURRENT_TIMESTAMP\n  `, [userId, url || null, type || 'default'], function(err) {\n    if (err) {\n      console.error('Set wallpaper URL error:', err);\n      return res.status(500).json({ error: 'Failed to set wallpaper' });\n    }\n    res.json({ success: true, wallpaper_url: url });\n  });\n});\n\n// Upload profile banner\nrouter.post('/banner', upload.single('banner'), (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  if (!req.file) {\n    return res.status(400).json({ error: 'No file uploaded' });\n  }\n\n  const bannerUrl = `/uploads/customization/${req.file.filename}`;\n\n  db.run(`\n    INSERT INTO user_customization (user_id, profile_banner_url)\n    VALUES (?, ?)\n    ON CONFLICT (user_id) \n    DO UPDATE SET profile_banner_url = EXCLUDED.profile_banner_url, updated_at = CURRENT_TIMESTAMP\n  `, [userId, bannerUrl], function(err) {\n    if (err) {\n      console.error('Save banner error:', err);\n      return res.status(500).json({ error: 'Failed to save banner' });\n    }\n    res.json({ success: true, banner_url: bannerUrl });\n  });\n});\n\n// Remove wallpaper\nrouter.delete('/wallpaper', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  db.run(`\n    UPDATE user_customization \n    SET wallpaper_url = NULL, wallpaper_type = 'default', updated_at = CURRENT_TIMESTAMP\n    WHERE user_id = ?\n  `, [userId], function(err) {\n    if (err) return res.status(500).json({ error: 'Failed to remove wallpaper' });\n    res.json({ success: true });\n  });\n});\n\n// Remove profile banner\nrouter.delete('/banner', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  db.run(`\n    UPDATE user_customization \n    SET profile_banner_url = NULL, updated_at = CURRENT_TIMESTAMP\n    WHERE user_id = ?\n  `, [userId], function(err) {\n    if (err) return res.status(500).json({ error: 'Failed to remove banner' });\n    res.json({ success: true });\n  });\n});\n\n// Get public profile customization (for viewing others' profiles)\nrouter.get('/profile/:userId', (req, res) => {\n  const { userId } = req.params;\n\n  db.get(`SELECT profile_banner_url FROM user_customization WHERE user_id = ?`, [userId], (err, settings) => {\n    if (err) return res.json({ profile_banner_url: null });\n    res.json(settings || { profile_banner_url: null });\n  });\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":5778,"size_tokens":null},"backend/routes/games.js":{"content":"const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst db = require('../db');\n\nconst router = express.Router();\nconst JWT_SECRET = 'real_user_auth_secret_2025';\n\nfunction getUserId(req) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return null;\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n    return decoded.userId;\n  } catch {\n    return null;\n  }\n}\n\n// Rate a game\nrouter.post('/rate', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  const { gameName, rating, review } = req.body;\n  \n  if (!gameName || !rating || rating < 1 || rating > 5) {\n    return res.status(400).json({ error: 'Valid game name and rating (1-5) required' });\n  }\n\n  db.run(`\n    INSERT INTO game_ratings (user_id, game_name, rating, review)\n    VALUES (?, ?, ?, ?)\n    ON CONFLICT (user_id, game_name) \n    DO UPDATE SET rating = EXCLUDED.rating, review = EXCLUDED.review, updated_at = CURRENT_TIMESTAMP\n  `, [userId, gameName, rating, review || null], function(err) {\n    if (err) {\n      console.error('Rate game error:', err);\n      return res.status(500).json({ error: 'Failed to save rating' });\n    }\n    res.json({ success: true, message: 'Rating saved' });\n  });\n});\n\n// Get ratings for a game\nrouter.get('/ratings/:gameName', (req, res) => {\n  const { gameName } = req.params;\n  const userId = getUserId(req);\n\n  db.all(`\n    SELECT gr.*, u.username, u.profile_picture\n    FROM game_ratings gr\n    JOIN users u ON gr.user_id = u.id\n    WHERE gr.game_name = ?\n    ORDER BY gr.created_at DESC\n    LIMIT 50\n  `, [decodeURIComponent(gameName)], (err, ratings) => {\n    if (err) {\n      console.error('Get ratings error:', err);\n      return res.json({ ratings: [], average: 0, total: 0, userRating: null });\n    }\n\n    const average = ratings.length > 0 \n      ? ratings.reduce((sum, r) => sum + r.rating, 0) / ratings.length \n      : 0;\n    \n    const userRating = userId \n      ? ratings.find(r => r.user_id === userId) \n      : null;\n\n    res.json({\n      ratings,\n      average: Math.round(average * 10) / 10,\n      total: ratings.length,\n      userRating\n    });\n  });\n});\n\n// Get user's rating for a specific game\nrouter.get('/my-rating/:gameName', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.json({ rating: null });\n\n  db.get(`\n    SELECT * FROM game_ratings WHERE user_id = ? AND game_name = ?\n  `, [userId, decodeURIComponent(req.params.gameName)], (err, rating) => {\n    res.json({ rating: rating || null });\n  });\n});\n\n// Get top rated games\nrouter.get('/top-rated', (req, res) => {\n  db.all(`\n    SELECT game_name, \n           AVG(rating) as avg_rating, \n           COUNT(*) as total_ratings\n    FROM game_ratings\n    GROUP BY game_name\n    HAVING COUNT(*) >= 3\n    ORDER BY avg_rating DESC, total_ratings DESC\n    LIMIT 20\n  `, [], (err, games) => {\n    if (err) {\n      console.error('Top rated error:', err);\n      return res.json([]);\n    }\n    res.json(games.map(g => ({\n      ...g,\n      avg_rating: Math.round(g.avg_rating * 10) / 10\n    })));\n  });\n});\n\n// Delete user's rating\nrouter.delete('/rating/:gameName', (req, res) => {\n  const userId = getUserId(req);\n  if (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n  db.run(`DELETE FROM game_ratings WHERE user_id = ? AND game_name = ?`, \n    [userId, decodeURIComponent(req.params.gameName)], \n    function(err) {\n      if (err) return res.status(500).json({ error: 'Failed to delete rating' });\n      res.json({ success: true });\n    }\n  );\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":3614,"size_tokens":null},"frontend/css/os-shell.css":{"content":"/* NebulaCore OS Shell - Sidebar Mode with Animations */\n\n:root {\n  --sidebar-width: 260px;\n  --transition-speed: 0.3s;\n}\n\n/* Hide classic content in OS mode */\n.layout-os .classic-content {\n  display: none !important;\n}\n\n/* Hide back-to-dashboard buttons in OS mode */\n.layout-os .back-btn,\n.layout-os .back-link,\n.layout-os .logout-btn[href*=\"dashboard\"],\n.layout-os .video-modal-back,\n.layout-os a[href=\"/dashboard\"] {\n  display: none !important;\n}\n\n/* Hide back buttons when loaded in iframe */\n.in-iframe .back-btn,\n.in-iframe .back-link,\n.in-iframe a[href*=\"dashboard\"],\n.in-iframe .settings-header .back-btn,\n.in-iframe .header .back-btn {\n  display: none !important;\n}\n\n/* Hover Zone - invisible trigger area on left edge */\n.os-sidebar-hover-zone {\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 12px;\n  height: 100vh;\n  z-index: 9998;\n  background: transparent;\n}\n\n.os-sidebar-hover-zone::after {\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 50%;\n  transform: translateY(-50%);\n  width: 4px;\n  height: 80px;\n  background: linear-gradient(180deg, transparent, rgba(0, 212, 255, 0.6), rgba(168, 85, 247, 0.6), transparent);\n  border-radius: 0 4px 4px 0;\n  opacity: 0.6;\n  transition: all 0.3s ease;\n}\n\n.os-sidebar-hover-zone:hover::after {\n  opacity: 1;\n  width: 6px;\n  box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);\n}\n\n/* Sidebar */\n.os-sidebar {\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: var(--sidebar-width);\n  height: 100vh;\n  background: linear-gradient(180deg, rgba(15, 15, 25, 0.98), rgba(10, 10, 18, 0.99));\n  backdrop-filter: blur(30px);\n  border-right: 1px solid rgba(255, 255, 255, 0.08);\n  box-shadow: 4px 0 40px rgba(0, 0, 0, 0.5);\n  display: flex;\n  flex-direction: column;\n  z-index: 9999;\n  transform: translateX(-100%);\n  transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.os-sidebar.visible {\n  transform: translateX(0);\n}\n\n/* Sidebar Header */\n.os-sidebar-header {\n  padding: 20px;\n  display: flex;\n  align-items: center;\n  gap: 12px;\n  border-bottom: 1px solid rgba(255, 255, 255, 0.08);\n}\n\n.os-sidebar-logo {\n  width: 40px;\n  height: 40px;\n  border-radius: 12px;\n  background: linear-gradient(135deg, var(--primary, #00d4ff), var(--secondary, #a855f7));\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-weight: 700;\n  font-size: 14px;\n  color: white;\n  text-shadow: 0 2px 4px rgba(0,0,0,0.3);\n  animation: logoPulse 3s ease-in-out infinite;\n}\n\n@keyframes logoPulse {\n  0%, 100% { box-shadow: 0 0 10px rgba(0, 212, 255, 0.3); }\n  50% { box-shadow: 0 0 25px rgba(0, 212, 255, 0.6), 0 0 40px rgba(168, 85, 247, 0.3); }\n}\n\n.os-sidebar-title {\n  font-size: 18px;\n  font-weight: 600;\n  color: var(--text, #fff);\n  background: linear-gradient(135deg, var(--primary, #00d4ff), var(--secondary, #a855f7));\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  background-clip: text;\n}\n\n/* Sidebar Apps List */\n.os-sidebar-apps {\n  flex: 1;\n  overflow-y: auto;\n  padding: 12px;\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n}\n\n.os-sidebar-apps::-webkit-scrollbar {\n  width: 4px;\n}\n\n.os-sidebar-apps::-webkit-scrollbar-track {\n  background: transparent;\n}\n\n.os-sidebar-apps::-webkit-scrollbar-thumb {\n  background: rgba(255, 255, 255, 0.2);\n  border-radius: 4px;\n}\n\n/* Sidebar App Button */\n.os-sidebar-app {\n  display: flex;\n  align-items: center;\n  gap: 14px;\n  padding: 14px 16px;\n  border-radius: 12px;\n  border: none;\n  background: transparent;\n  color: var(--text, #fff);\n  cursor: pointer;\n  transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);\n  text-align: left;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n}\n\n.os-sidebar-app::before {\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 0;\n  height: 100%;\n  background: linear-gradient(90deg, rgba(0, 212, 255, 0.15), transparent);\n  transition: width 0.3s ease;\n  z-index: -1;\n}\n\n.os-sidebar-app:hover::before {\n  width: 100%;\n}\n\n.os-sidebar-app:hover {\n  transform: translateX(8px);\n}\n\n.os-sidebar-app:hover .app-icon-wrapper svg {\n  filter: drop-shadow(0 0 10px var(--icon-color)) drop-shadow(0 0 18px var(--icon-color));\n}\n\n.os-sidebar-app:active {\n  transform: translateX(8px) scale(0.98);\n}\n\n.os-sidebar-app.active {\n  background: linear-gradient(135deg, rgba(0, 212, 255, 0.15), rgba(168, 85, 247, 0.1));\n}\n\n.os-sidebar-app.active::after {\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 50%;\n  transform: translateY(-50%);\n  width: 3px;\n  height: 60%;\n  background: linear-gradient(180deg, var(--primary, #00d4ff), var(--secondary, #a855f7));\n  border-radius: 0 3px 3px 0;\n}\n\n.os-sidebar-app-label {\n  font-size: 14px;\n  font-weight: 500;\n  color: var(--text, #fff);\n  opacity: 0.9;\n  transition: opacity 0.2s;\n}\n\n.os-sidebar-app:hover .os-sidebar-app-label {\n  opacity: 1;\n}\n\n/* App Icon Wrapper */\n.app-icon-wrapper {\n  width: 24px;\n  height: 24px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-shrink: 0;\n}\n\n.app-icon-wrapper svg {\n  width: 100%;\n  height: 100%;\n  stroke: var(--icon-color, #00d4ff);\n  filter: drop-shadow(0 0 4px var(--icon-color));\n  transition: all 0.3s ease;\n}\n\n/* Logout Icon */\n.logout-icon {\n  width: 24px;\n  height: 24px;\n  stroke: #ff5f57;\n  filter: drop-shadow(0 0 4px rgba(255, 95, 87, 0.5));\n}\n\n.os-sidebar-logout:hover .logout-icon {\n  filter: drop-shadow(0 0 10px #ff5f57) drop-shadow(0 0 18px #ff5f57);\n}\n\n.os-sidebar-logout:hover .os-sidebar-app-label {\n  color: #ff5f57;\n}\n\n/* Sidebar Footer */\n.os-sidebar-footer {\n  padding: 12px;\n  border-top: 1px solid rgba(255, 255, 255, 0.08);\n}\n\n/* Main Content Area */\n.os-main-content {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 1;\n  background: var(--bg, #0a0a12);\n  overflow: hidden;\n}\n\n.os-main-content.fade-out {\n  animation: fadeOut 0.3s ease forwards;\n}\n\n@keyframes fadeOut {\n  to { opacity: 0; transform: scale(0.98); }\n}\n\n/* Page Container */\n.os-page-container {\n  width: 100%;\n  height: 100%;\n  position: relative;\n}\n\n/* Page/iframe styles */\n.os-page {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  border: none;\n  opacity: 0;\n  transform: translateX(30px);\n  transition: all var(--transition-speed) cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.os-page.active {\n  opacity: 1;\n  transform: translateX(0);\n}\n\n.os-page.slide-out {\n  opacity: 0;\n  transform: translateX(-30px);\n}\n\n.os-page.slide-in {\n  opacity: 0;\n  transform: translateX(30px);\n  animation: slideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;\n}\n\n@keyframes slideIn {\n  from {\n    opacity: 0;\n    transform: translateX(30px);\n  }\n  to {\n    opacity: 1;\n    transform: translateX(0);\n  }\n}\n\n/* Loading Overlay */\n.os-loading-overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(10, 10, 18, 0.7);\n  backdrop-filter: blur(5px);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: 100;\n  opacity: 0;\n  visibility: hidden;\n  transition: all 0.2s ease;\n}\n\n.os-loading-overlay.visible {\n  opacity: 1;\n  visibility: visible;\n}\n\n.os-loading-spinner {\n  width: 50px;\n  height: 50px;\n  border: 3px solid rgba(255, 255, 255, 0.1);\n  border-top-color: var(--primary, #00d4ff);\n  border-right-color: var(--secondary, #a855f7);\n  border-radius: 50%;\n  animation: spin 0.8s linear infinite;\n}\n\n@keyframes spin {\n  to { transform: rotate(360deg); }\n}\n\n/* Classic mode hides OS elements */\n.layout-classic .os-sidebar,\n.layout-classic .os-sidebar-hover-zone,\n.layout-classic .os-main-content {\n  display: none !important;\n}\n\n/* Responsive */\n@media (max-width: 768px) {\n  .os-sidebar {\n    width: 100%;\n  }\n  \n  .os-sidebar-hover-zone {\n    width: 20px;\n  }\n  \n  .os-sidebar-hover-zone::after {\n    height: 100px;\n  }\n}\n\n/* Stagger animation for sidebar apps */\n.os-sidebar.visible .os-sidebar-app {\n  animation: slideInApp 0.3s ease forwards;\n  opacity: 0;\n}\n\n.os-sidebar.visible .os-sidebar-app:nth-child(1) { animation-delay: 0.02s; }\n.os-sidebar.visible .os-sidebar-app:nth-child(2) { animation-delay: 0.04s; }\n.os-sidebar.visible .os-sidebar-app:nth-child(3) { animation-delay: 0.06s; }\n.os-sidebar.visible .os-sidebar-app:nth-child(4) { animation-delay: 0.08s; }\n.os-sidebar.visible .os-sidebar-app:nth-child(5) { animation-delay: 0.10s; }\n.os-sidebar.visible .os-sidebar-app:nth-child(6) { animation-delay: 0.12s; }\n.os-sidebar.visible .os-sidebar-app:nth-child(7) { animation-delay: 0.14s; }\n.os-sidebar.visible .os-sidebar-app:nth-child(8) { animation-delay: 0.16s; }\n.os-sidebar.visible .os-sidebar-app:nth-child(9) { animation-delay: 0.18s; }\n.os-sidebar.visible .os-sidebar-app:nth-child(10) { animation-delay: 0.20s; }\n.os-sidebar.visible .os-sidebar-app:nth-child(11) { animation-delay: 0.22s; }\n.os-sidebar.visible .os-sidebar-app:nth-child(12) { animation-delay: 0.24s; }\n.os-sidebar.visible .os-sidebar-app:nth-child(13) { animation-delay: 0.26s; }\n\n@keyframes slideInApp {\n  from {\n    opacity: 0;\n    transform: translateX(-20px);\n  }\n  to {\n    opacity: 1;\n    transform: translateX(0);\n  }\n}\n\n/* Hover zone glow animation */\n@keyframes glowPulse {\n  0%, 100% { opacity: 0.5; }\n  50% { opacity: 0.8; }\n}\n\n.os-sidebar-hover-zone::after {\n  animation: glowPulse 2s ease-in-out infinite;\n}\n","path":null,"size_bytes":9197,"size_tokens":null},"backend/routes/bug-reports.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst pool = require('../db');\nconst jwt = require('jsonwebtoken');\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'supersecretkey';\n\nfunction authenticateToken(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n  \n  if (!token) return res.status(401).json({ error: 'No token provided' });\n  \n  jwt.verify(token, JWT_SECRET, (err, user) => {\n    if (err) return res.status(403).json({ error: 'Invalid token' });\n    req.user = user;\n    next();\n  });\n}\n\nasync function isAdmin(req, res, next) {\n  try {\n    const result = await pool.query('SELECT role FROM users WHERE id = $1', [req.user.userId || req.user.id]);\n    if (result.rows.length === 0 || result.rows[0].role !== 'admin') {\n      return res.status(403).json({ error: 'Admin access required' });\n    }\n    next();\n  } catch (err) {\n    res.status(500).json({ error: 'Server error' });\n  }\n}\n\nrouter.post('/', authenticateToken, async (req, res) => {\n  const { category, title, description, priority, steps, location } = req.body;\n  const userId = req.user.userId || req.user.id;\n\n  if (!title || !description) {\n    return res.status(400).json({ error: 'Title and description are required' });\n  }\n\n  try {\n    const result = await pool.query(\n      `INSERT INTO bug_reports (user_id, category, title, description, priority, steps, status, created_at)\n       VALUES ($1, $2, $3, $4, $5, $6, 'pending', NOW())\n       RETURNING *`,\n      [userId, category || 'other', title, description, priority || 'medium', steps || location || '']\n    );\n    res.json({ success: true, id: result.rows[0].id, message: 'Bug report submitted successfully' });\n  } catch (err) {\n    console.error('Bug report insert error:', err);\n    res.status(500).json({ error: 'Failed to submit bug report' });\n  }\n});\n\nrouter.get('/', authenticateToken, isAdmin, async (req, res) => {\n  const { status, limit = 50, offset = 0 } = req.query;\n  \n  try {\n    let query = `\n      SELECT br.*, u.username as reporter_username\n      FROM bug_reports br\n      LEFT JOIN users u ON br.user_id = u.id\n    `;\n    const params = [];\n    let paramIndex = 1;\n\n    if (status && status !== 'all') {\n      query += ` WHERE br.status = $${paramIndex++}`;\n      params.push(status);\n    }\n\n    query += ` ORDER BY br.created_at DESC LIMIT $${paramIndex++} OFFSET $${paramIndex++}`;\n    params.push(parseInt(limit), parseInt(offset));\n\n    const result = await pool.query(query, params);\n    res.json({ reports: result.rows });\n  } catch (err) {\n    console.error('Bug reports fetch error:', err);\n    res.status(500).json({ error: 'Failed to fetch bug reports' });\n  }\n});\n\nrouter.get('/my-reports', authenticateToken, async (req, res) => {\n  try {\n    const userId = req.user.userId || req.user.id;\n    const result = await pool.query(\n      `SELECT * FROM bug_reports WHERE user_id = $1 ORDER BY created_at DESC`,\n      [userId]\n    );\n    res.json(result.rows);\n  } catch (err) {\n    console.error('My bug reports fetch error:', err);\n    res.status(500).json({ error: 'Failed to fetch your bug reports' });\n  }\n});\n\nrouter.get('/stats', authenticateToken, isAdmin, async (req, res) => {\n  try {\n    const result = await pool.query(\n      `SELECT status, COUNT(*) as count FROM bug_reports GROUP BY status`\n    );\n    \n    const stats = { pending: 0, investigating: 0, resolved: 0, closed: 0, total: 0 };\n    result.rows.forEach(s => {\n      stats[s.status] = parseInt(s.count);\n      stats.total += parseInt(s.count);\n    });\n    \n    res.json(stats);\n  } catch (err) {\n    console.error('Bug report stats error:', err);\n    res.status(500).json({ error: 'Failed to fetch stats' });\n  }\n});\n\nrouter.patch('/:id', authenticateToken, isAdmin, async (req, res) => {\n  const { id } = req.params;\n  const { status, priority, admin_notes } = req.body;\n  const userId = req.user.userId || req.user.id;\n\n  const updates = [];\n  const params = [];\n  let paramIndex = 1;\n\n  if (status) {\n    updates.push(`status = $${paramIndex++}`);\n    params.push(status);\n  }\n  if (priority) {\n    updates.push(`priority = $${paramIndex++}`);\n    params.push(priority);\n  }\n  if (admin_notes !== undefined) {\n    updates.push(`admin_notes = $${paramIndex++}`);\n    params.push(admin_notes);\n  }\n  if (status === 'resolved' || status === 'closed') {\n    updates.push(`resolved_by = $${paramIndex++}`);\n    params.push(userId);\n  }\n\n  updates.push('updated_at = NOW()');\n\n  if (updates.length === 1) {\n    return res.status(400).json({ error: 'No updates provided' });\n  }\n\n  params.push(id);\n\n  try {\n    const result = await pool.query(\n      `UPDATE bug_reports SET ${updates.join(', ')} WHERE id = $${paramIndex} RETURNING *`,\n      params\n    );\n    \n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'Bug report not found' });\n    }\n    res.json({ success: true, message: 'Bug report updated' });\n  } catch (err) {\n    console.error('Bug report update error:', err);\n    res.status(500).json({ error: 'Failed to update bug report' });\n  }\n});\n\nrouter.delete('/:id', authenticateToken, isAdmin, async (req, res) => {\n  const { id } = req.params;\n\n  try {\n    const result = await pool.query(`DELETE FROM bug_reports WHERE id = $1 RETURNING id`, [id]);\n    \n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'Bug report not found' });\n    }\n    res.json({ success: true, message: 'Bug report deleted' });\n  } catch (err) {\n    console.error('Bug report delete error:', err);\n    res.status(500).json({ error: 'Failed to delete bug report' });\n  }\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":5674,"size_tokens":null},"frontend/js/os-shell.js":{"content":"/* NebulaCore OS Shell - Sidebar Mode with Animations */\n\nconst OSShell = {\n  currentApp: null,\n  isTransitioning: false,\n  \n  apps: [\n    { id: 'games', name: 'Games', icon: 'games', color: '#ff6b6b', url: '/private/games.html' },\n    { id: 'chat', name: 'Chat', icon: 'chat', color: '#a855f7', url: '/private/chat.html' },\n    { id: 'forums', name: 'Forums', icon: 'forums', color: '#22c55e', url: '/private/forums.html' },\n    { id: 'youtube', name: 'Videos', icon: 'videos', color: '#ef4444', url: '/private/youtube.html' },\n    { id: 'apps', name: 'Apps', icon: 'apps', color: '#3b82f6', url: '/private/apps.html' },\n    { id: 'music', name: 'Music', icon: 'music', color: '#ec4899', url: '/private/music.html' },\n    { id: 'proxy', name: 'Web Proxy', icon: 'proxy', color: '#14b8a6', url: '/private/proxy.html' },\n    { id: 'profile', name: 'Profile', icon: 'profile', color: '#f59e0b', url: '/private/profile.html' },\n    { id: 'settings', name: 'Settings', icon: 'settings', color: '#6b7280', url: '/private/settings.html' },\n    { id: 'themes', name: 'Themes', icon: 'themes', color: '#8b5cf6', url: '/private/themes.html' },\n    { id: 'leaderboard', name: 'Leaderboard', icon: 'leaderboard', color: '#eab308', url: '/private/leaderboard.html' },\n    { id: 'shop', name: 'Shop', icon: 'shop', color: '#06b6d4', url: '/private/shop.html' },\n    { id: 'admin', name: 'Admin', icon: 'admin', color: '#dc2626', url: '/private/admin.html', adminOnly: true }\n  ],\n  \n  icons: {\n    games: `<svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><rect x=\"2\" y=\"6\" width=\"20\" height=\"12\" rx=\"2\"/><line x1=\"6\" y1=\"12\" x2=\"10\" y2=\"12\"/><line x1=\"8\" y1=\"10\" x2=\"8\" y2=\"14\"/><circle cx=\"16\" cy=\"10\" r=\"1\" fill=\"currentColor\"/><circle cx=\"18\" cy=\"12\" r=\"1\" fill=\"currentColor\"/></svg>`,\n    chat: `<svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z\"/><line x1=\"8\" y1=\"9\" x2=\"16\" y2=\"9\"/><line x1=\"8\" y1=\"13\" x2=\"14\" y2=\"13\"/></svg>`,\n    forums: `<svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"/><circle cx=\"9\" cy=\"7\" r=\"4\"/><path d=\"M23 21v-2a4 4 0 0 0-3-3.87\"/><path d=\"M16 3.13a4 4 0 0 1 0 7.75\"/></svg>`,\n    videos: `<svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><rect x=\"2\" y=\"4\" width=\"20\" height=\"16\" rx=\"2\"/><polygon points=\"10 9 16 12 10 15\" fill=\"currentColor\"/></svg>`,\n    apps: `<svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><rect x=\"3\" y=\"3\" width=\"7\" height=\"7\" rx=\"1\"/><rect x=\"14\" y=\"3\" width=\"7\" height=\"7\" rx=\"1\"/><rect x=\"3\" y=\"14\" width=\"7\" height=\"7\" rx=\"1\"/><rect x=\"14\" y=\"14\" width=\"7\" height=\"7\" rx=\"1\"/></svg>`,\n    music: `<svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><circle cx=\"5.5\" cy=\"17.5\" r=\"3.5\"/><circle cx=\"18.5\" cy=\"15.5\" r=\"3.5\"/><line x1=\"9\" y1=\"17\" x2=\"9\" y2=\"4\"/><line x1=\"22\" y1=\"15\" x2=\"22\" y2=\"2\"/><path d=\"M9 8l13-4\"/></svg>`,\n    proxy: `<svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><line x1=\"2\" y1=\"12\" x2=\"22\" y2=\"12\"/><path d=\"M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z\"/></svg>`,\n    profile: `<svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><circle cx=\"12\" cy=\"8\" r=\"5\"/><path d=\"M20 21a8 8 0 0 0-16 0\"/></svg>`,\n    settings: `<svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><circle cx=\"12\" cy=\"12\" r=\"3\"/><path d=\"M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z\"/></svg>`,\n    themes: `<svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83\"/></svg>`,\n    leaderboard: `<svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M6 9H4.5a2.5 2.5 0 0 1 0-5H6\"/><path d=\"M18 9h1.5a2.5 2.5 0 0 0 0-5H18\"/><path d=\"M4 22h16\"/><path d=\"M10 22V8a2 2 0 0 1 2-2h0a2 2 0 0 1 2 2v14\"/><path d=\"M14 14h2a2 2 0 0 1 2 2v6\"/><path d=\"M6 18a2 2 0 0 1 2-2h2v6H6z\"/></svg>`,\n    shop: `<svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><circle cx=\"9\" cy=\"21\" r=\"1\"/><circle cx=\"20\" cy=\"21\" r=\"1\"/><path d=\"M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6\"/></svg>`,\n    admin: `<svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z\"/><path d=\"M9 12l2 2 4-4\"/></svg>`\n  },\n  \n  getIcon(iconName, color) {\n    const svg = this.icons[iconName] || this.icons.apps;\n    return `<div class=\"app-icon-wrapper\" style=\"--icon-color: ${color}\">${svg}</div>`;\n  },\n  \n  init() {\n    if (window.self !== window.top) {\n      return;\n    }\n    \n    const layoutMode = localStorage.getItem('layoutMode') || 'classic';\n    document.body.classList.add(`layout-${layoutMode}`);\n    \n    if (layoutMode === 'os') {\n      this.renderOSShell();\n      this.setupEventListeners();\n      setTimeout(() => this.openApp('proxy', false), 100);\n    }\n  },\n  \n  renderOSShell() {\n    const sidebar = document.createElement('div');\n    sidebar.className = 'os-sidebar';\n    sidebar.id = 'osSidebar';\n    \n    const user = this.getCurrentUser();\n    const isAdmin = user && user.is_admin;\n    \n    const appsList = this.apps.filter(app => !app.adminOnly || isAdmin);\n    \n    const appsHtml = appsList.map(app => `\n      <button class=\"os-sidebar-app\" data-app=\"${app.id}\" title=\"${app.name}\">\n        ${this.getIcon(app.icon, app.color)}\n        <span class=\"os-sidebar-app-label\">${app.name}</span>\n      </button>\n    `).join('');\n    \n    sidebar.innerHTML = `\n      <div class=\"os-sidebar-header\">\n        <div class=\"os-sidebar-logo\">NC</div>\n        <span class=\"os-sidebar-title\">NebulaCore</span>\n      </div>\n      <div class=\"os-sidebar-apps\">\n        ${appsHtml}\n      </div>\n      <div class=\"os-sidebar-footer\">\n        <button class=\"os-sidebar-app os-sidebar-logout\" title=\"Sign Out\">\n          <svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" class=\"logout-icon\">\n            <path d=\"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4\"/>\n            <polyline points=\"16 17 21 12 16 7\"/>\n            <line x1=\"21\" y1=\"12\" x2=\"9\" y2=\"12\"/>\n          </svg>\n          <span class=\"os-sidebar-app-label\">Sign Out</span>\n        </button>\n      </div>\n    `;\n    \n    const hoverZone = document.createElement('div');\n    hoverZone.className = 'os-sidebar-hover-zone';\n    hoverZone.id = 'osSidebarHoverZone';\n    \n    const mainContent = document.createElement('div');\n    mainContent.className = 'os-main-content';\n    mainContent.id = 'osMainContent';\n    mainContent.innerHTML = `\n      <div class=\"os-page-container\" id=\"osPageContainer\">\n        <iframe class=\"os-page active\" id=\"osMainFrame\" src=\"about:blank\"></iframe>\n      </div>\n      <div class=\"os-loading-overlay\" id=\"osLoadingOverlay\">\n        <div class=\"os-loading-spinner\"></div>\n      </div>\n    `;\n    \n    document.body.appendChild(hoverZone);\n    document.body.appendChild(sidebar);\n    document.body.appendChild(mainContent);\n  },\n  \n  setupEventListeners() {\n    const sidebar = document.getElementById('osSidebar');\n    const hoverZone = document.getElementById('osSidebarHoverZone');\n    \n    hoverZone.addEventListener('mouseenter', () => {\n      sidebar.classList.add('visible');\n    });\n    \n    sidebar.addEventListener('mouseenter', () => {\n      sidebar.classList.add('visible');\n    });\n    \n    sidebar.addEventListener('mouseleave', () => {\n      sidebar.classList.remove('visible');\n    });\n    \n    document.querySelectorAll('.os-sidebar-app').forEach(btn => {\n      btn.addEventListener('click', () => {\n        const appId = btn.dataset.app;\n        if (appId) {\n          this.openApp(appId, true);\n        }\n      });\n    });\n    \n    document.querySelector('.os-sidebar-logout')?.addEventListener('click', () => {\n      this.signOut();\n    });\n    \n    const frame = document.getElementById('osMainFrame');\n    if (frame) {\n      frame.addEventListener('load', () => {\n        this.hideLoading();\n      });\n    }\n  },\n  \n  openApp(appId, animate = true) {\n    if (this.isTransitioning || appId === this.currentApp) {\n      document.getElementById('osSidebar')?.classList.remove('visible');\n      return;\n    }\n    \n    const app = this.apps.find(a => a.id === appId);\n    if (!app) return;\n    \n    this.isTransitioning = true;\n    const container = document.getElementById('osPageContainer');\n    const currentFrame = document.getElementById('osMainFrame');\n    \n    if (animate && this.currentApp) {\n      this.showLoading();\n      \n      currentFrame.classList.add('slide-out');\n      \n      setTimeout(() => {\n        currentFrame.classList.remove('slide-out', 'active');\n        currentFrame.src = app.url;\n        currentFrame.classList.add('slide-in');\n        \n        setTimeout(() => {\n          currentFrame.classList.remove('slide-in');\n          currentFrame.classList.add('active');\n          this.isTransitioning = false;\n        }, 300);\n      }, 200);\n    } else {\n      this.showLoading();\n      currentFrame.src = app.url;\n      currentFrame.classList.add('active');\n      this.isTransitioning = false;\n    }\n    \n    this.currentApp = appId;\n    this.updateActiveApp();\n    document.getElementById('osSidebar')?.classList.remove('visible');\n  },\n  \n  updateActiveApp() {\n    document.querySelectorAll('.os-sidebar-app').forEach(btn => {\n      btn.classList.toggle('active', btn.dataset.app === this.currentApp);\n    });\n  },\n  \n  showLoading() {\n    document.getElementById('osLoadingOverlay')?.classList.add('visible');\n  },\n  \n  hideLoading() {\n    setTimeout(() => {\n      document.getElementById('osLoadingOverlay')?.classList.remove('visible');\n    }, 100);\n  },\n  \n  getCurrentUser() {\n    const token = localStorage.getItem('token');\n    if (!token) return null;\n    try {\n      const payload = JSON.parse(atob(token.split('.')[1]));\n      return payload;\n    } catch {\n      return null;\n    }\n  },\n  \n  signOut() {\n    const mainContent = document.getElementById('osMainContent');\n    if (mainContent) {\n      mainContent.classList.add('fade-out');\n    }\n    \n    setTimeout(() => {\n      localStorage.removeItem('token');\n      localStorage.removeItem('currentUser');\n      window.location.href = '/login.html';\n    }, 300);\n  }\n};\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  OSShell.init();\n});\n","path":null,"size_bytes":11325,"size_tokens":null},"frontend/js/os-notifications.js":{"content":"const OSNotifications = {\n  container: null,\n  notifications: [],\n  maxNotifications: 5,\n  defaultDuration: 5000,\n\n  init() {\n    if (this.container) return;\n    \n    this.container = document.createElement('div');\n    this.container.id = 'os-notifications-container';\n    this.container.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      z-index: 10000;\n      display: flex;\n      flex-direction: column;\n      gap: 10px;\n      max-width: 350px;\n      pointer-events: none;\n    `;\n    document.body.appendChild(this.container);\n  },\n\n  show(options) {\n    this.init();\n    \n    const {\n      title = 'Notification',\n      message = '',\n      type = 'info',\n      icon = null,\n      duration = this.defaultDuration,\n      onClick = null,\n      actions = []\n    } = typeof options === 'string' ? { message: options } : options;\n\n    const icons = {\n      info: 'â„¹ï¸',\n      success: 'âœ…',\n      warning: 'âš ï¸',\n      error: 'âŒ',\n      message: 'ðŸ’¬',\n      achievement: 'ðŸ†',\n      friend: 'ðŸ‘¤',\n      system: 'ðŸ””'\n    };\n\n    const colors = {\n      info: '#4cc9f0',\n      success: '#00ff88',\n      warning: '#ffcc00',\n      error: '#ff6b6b',\n      message: '#a855f7',\n      achievement: '#ffd700',\n      friend: '#3b82f6',\n      system: '#6b7280'\n    };\n\n    const notification = document.createElement('div');\n    notification.className = 'os-notification';\n    notification.style.cssText = `\n      background: linear-gradient(135deg, rgba(30, 30, 50, 0.95), rgba(20, 20, 40, 0.95));\n      border: 1px solid ${colors[type] || colors.info};\n      border-left: 4px solid ${colors[type] || colors.info};\n      border-radius: 12px;\n      padding: 14px 16px;\n      color: white;\n      font-family: 'Inter', 'Segoe UI', sans-serif;\n      backdrop-filter: blur(10px);\n      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 20px ${colors[type] || colors.info}33;\n      transform: translateX(120%);\n      transition: transform 0.3s ease, opacity 0.3s ease;\n      pointer-events: all;\n      cursor: ${onClick ? 'pointer' : 'default'};\n      animation: slideIn 0.3s ease forwards;\n    `;\n\n    notification.innerHTML = `\n      <div style=\"display: flex; gap: 12px; align-items: flex-start;\">\n        <span style=\"font-size: 24px;\">${icon || icons[type] || icons.info}</span>\n        <div style=\"flex: 1; min-width: 0;\">\n          <div style=\"font-weight: 600; font-size: 14px; margin-bottom: 2px;\">${this.escapeHtml(title)}</div>\n          ${message ? `<div style=\"font-size: 13px; opacity: 0.8; word-wrap: break-word;\">${this.escapeHtml(message)}</div>` : ''}\n          ${actions.length > 0 ? `\n            <div style=\"display: flex; gap: 8px; margin-top: 10px;\">\n              ${actions.map((action, i) => `\n                <button data-action=\"${i}\" style=\"\n                  padding: 6px 12px;\n                  background: ${action.primary ? colors[type] || colors.info : 'rgba(255,255,255,0.1)'};\n                  border: none;\n                  border-radius: 6px;\n                  color: ${action.primary ? '#000' : '#fff'};\n                  font-size: 12px;\n                  font-weight: 600;\n                  cursor: pointer;\n                  transition: all 0.2s;\n                \">${this.escapeHtml(action.label)}</button>\n              `).join('')}\n            </div>\n          ` : ''}\n        </div>\n        <button class=\"close-notification\" style=\"\n          background: none;\n          border: none;\n          color: rgba(255,255,255,0.5);\n          font-size: 18px;\n          cursor: pointer;\n          padding: 0;\n          line-height: 1;\n        \">&times;</button>\n      </div>\n    `;\n\n    if (onClick) {\n      notification.addEventListener('click', (e) => {\n        if (!e.target.classList.contains('close-notification') && !e.target.dataset.action) {\n          onClick();\n          this.dismiss(notification);\n        }\n      });\n    }\n\n    notification.querySelector('.close-notification').addEventListener('click', (e) => {\n      e.stopPropagation();\n      this.dismiss(notification);\n    });\n\n    actions.forEach((action, i) => {\n      const btn = notification.querySelector(`[data-action=\"${i}\"]`);\n      if (btn) {\n        btn.addEventListener('click', (e) => {\n          e.stopPropagation();\n          if (action.onClick) action.onClick();\n          this.dismiss(notification);\n        });\n      }\n    });\n\n    this.container.appendChild(notification);\n    this.notifications.push(notification);\n\n    requestAnimationFrame(() => {\n      notification.style.transform = 'translateX(0)';\n    });\n\n    while (this.notifications.length > this.maxNotifications) {\n      this.dismiss(this.notifications[0]);\n    }\n\n    if (duration > 0) {\n      setTimeout(() => this.dismiss(notification), duration);\n    }\n\n    return notification;\n  },\n\n  dismiss(notification) {\n    if (!notification || !notification.parentElement) return;\n    \n    notification.style.transform = 'translateX(120%)';\n    notification.style.opacity = '0';\n    \n    setTimeout(() => {\n      if (notification.parentElement) {\n        notification.parentElement.removeChild(notification);\n      }\n      const index = this.notifications.indexOf(notification);\n      if (index > -1) {\n        this.notifications.splice(index, 1);\n      }\n    }, 300);\n  },\n\n  dismissAll() {\n    [...this.notifications].forEach(n => this.dismiss(n));\n  },\n\n  escapeHtml(text) {\n    if (!text) return '';\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  },\n\n  success(title, message) {\n    return this.show({ title, message, type: 'success' });\n  },\n\n  error(title, message) {\n    return this.show({ title, message, type: 'error' });\n  },\n\n  warning(title, message) {\n    return this.show({ title, message, type: 'warning' });\n  },\n\n  info(title, message) {\n    return this.show({ title, message, type: 'info' });\n  },\n\n  achievement(title, message) {\n    return this.show({ \n      title, \n      message, \n      type: 'achievement',\n      duration: 8000\n    });\n  },\n\n  friendRequest(username) {\n    return this.show({\n      title: 'Friend Request',\n      message: `${username} sent you a friend request`,\n      type: 'friend',\n      icon: 'ðŸ‘‹',\n      actions: [\n        { label: 'Accept', primary: true, onClick: () => console.log('Accept clicked') },\n        { label: 'Decline', onClick: () => console.log('Decline clicked') }\n      ]\n    });\n  },\n\n  newMessage(sender, preview) {\n    return this.show({\n      title: `Message from ${sender}`,\n      message: preview,\n      type: 'message',\n      onClick: () => window.location.href = '/private/chat.html'\n    });\n  }\n};\n\nif (typeof window !== 'undefined') {\n  window.OSNotifications = OSNotifications;\n}\n","path":null,"size_bytes":6720,"size_tokens":null},"frontend/js/security.js":{"content":"// Security measures to prevent dev tools access\n(function() {\n  function isAdmin() {\n    try {\n      const userData = localStorage.getItem('user');\n      if (userData) {\n        const user = JSON.parse(userData);\n        return user.role === 'admin' || user.is_admin === true || user.username === 'admin' || user.username === 'Yusoff(ADMIN)';\n      }\n    } catch (e) {}\n    return false;\n  }\n  \n  // Block F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U\n  document.addEventListener('keydown', function(e) {\n    if (isAdmin()) return;\n    \n    // F12\n    if (e.key === 'F12' || e.keyCode === 123) {\n      e.preventDefault();\n      e.stopPropagation();\n      showAccessDenied();\n      return false;\n    }\n    \n    // Ctrl+Shift+I (Dev Tools)\n    if (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'i' || e.keyCode === 73)) {\n      e.preventDefault();\n      e.stopPropagation();\n      showAccessDenied();\n      return false;\n    }\n    \n    // Ctrl+Shift+J (Console)\n    if (e.ctrlKey && e.shiftKey && (e.key === 'J' || e.key === 'j' || e.keyCode === 74)) {\n      e.preventDefault();\n      e.stopPropagation();\n      showAccessDenied();\n      return false;\n    }\n    \n    // Ctrl+U (View Source)\n    if (e.ctrlKey && (e.key === 'U' || e.key === 'u' || e.keyCode === 85)) {\n      e.preventDefault();\n      e.stopPropagation();\n      showAccessDenied();\n      return false;\n    }\n    \n    // Ctrl+Shift+C (Inspect Element)\n    if (e.ctrlKey && e.shiftKey && (e.key === 'C' || e.key === 'c' || e.keyCode === 67)) {\n      e.preventDefault();\n      e.stopPropagation();\n      showAccessDenied();\n      return false;\n    }\n  }, true);\n  \n  // Note: Right-click is allowed for custom context menus\n  // Dev tools are blocked via keyboard shortcuts only\n  \n  function showAccessDenied() {\n    // Create overlay\n    const overlay = document.createElement('div');\n    overlay.id = 'accessDeniedOverlay';\n    overlay.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      background: rgba(0, 0, 0, 0.95);\n      z-index: 999999;\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      justify-content: center;\n      animation: fadeIn 0.3s ease;\n    `;\n    \n    overlay.innerHTML = `\n      <style>\n        @keyframes fadeIn {\n          from { opacity: 0; }\n          to { opacity: 1; }\n        }\n        @keyframes shake {\n          0%, 100% { transform: translateX(0); }\n          10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }\n          20%, 40%, 60%, 80% { transform: translateX(10px); }\n        }\n        @keyframes pulse {\n          0%, 100% { transform: scale(1); }\n          50% { transform: scale(1.1); }\n        }\n      </style>\n      <div style=\"text-align: center; animation: shake 0.5s ease;\">\n        <div style=\"font-size: 80px; margin-bottom: 20px; animation: pulse 1s infinite;\">ðŸš«</div>\n        <h1 style=\"color: #ff4444; font-size: 48px; margin: 0 0 15px 0; font-family: 'Space Grotesk', sans-serif; text-shadow: 0 0 20px rgba(255,68,68,0.5);\">ACCESS DENIED</h1>\n        <p style=\"color: #888; font-size: 18px; margin-bottom: 30px;\">Developer tools are not permitted on this platform.</p>\n        <p style=\"color: #666; font-size: 14px;\">This tab will close in <span id=\"countdown\">3</span> seconds...</p>\n      </div>\n    `;\n    \n    document.body.appendChild(overlay);\n    \n    // Countdown and close\n    let count = 3;\n    const countdownEl = overlay.querySelector('#countdown');\n    \n    const interval = setInterval(function() {\n      count--;\n      if (countdownEl) countdownEl.textContent = count;\n      \n      if (count <= 0) {\n        clearInterval(interval);\n        // Try to close the tab\n        try {\n          window.open('', '_self');\n          window.close();\n        } catch(e) {\n          // If can't close, redirect to blank page or landing\n          window.location.href = 'about:blank';\n        }\n        // Fallback: redirect to landing page\n        setTimeout(function() {\n          window.location.href = '/';\n        }, 500);\n      }\n    }, 1000);\n  }\n})();\n","path":null,"size_bytes":4087,"size_tokens":null},"backend/utils/updateLogger.js":{"content":"const db = require('../db');\n\nconst UPDATE_TYPES = {\n  SERVER_CREATED: 'server_created',\n  SERVER_UPDATED: 'server_updated',\n  SERVER_DELETED: 'server_deleted',\n  CHANNEL_CREATED: 'channel_created',\n  CHANNEL_UPDATED: 'channel_updated',\n  CHANNEL_DELETED: 'channel_deleted',\n  ROLE_CREATED: 'role_created',\n  ROLE_UPDATED: 'role_updated',\n  ROLE_DELETED: 'role_deleted',\n  MEMBER_JOINED: 'member_joined',\n  MEMBER_LEFT: 'member_left',\n  MEMBER_KICKED: 'member_kicked',\n  MEMBER_BANNED: 'member_banned',\n  ROLE_ASSIGNED: 'role_assigned',\n  ROLE_REMOVED: 'role_removed',\n  PERMISSION_UPDATED: 'permission_updated',\n  MESSAGE_DELETED: 'message_deleted',\n  MESSAGE_PINNED: 'message_pinned',\n  MESSAGE_UNPINNED: 'message_unpinned',\n  INVITE_CREATED: 'invite_created',\n  INVITE_DELETED: 'invite_deleted',\n  SETTINGS_UPDATED: 'settings_updated',\n  USER_REGISTERED: 'user_registered',\n  USER_UPDATED: 'user_updated',\n  GAME_PLAYED: 'game_played',\n  XP_GAINED: 'xp_gained',\n  ACHIEVEMENT_UNLOCKED: 'achievement_unlocked',\n  THEME_CHANGED: 'theme_changed',\n  BUG_REPORTED: 'bug_reported',\n  FORUM_POST_CREATED: 'forum_post_created',\n  SYSTEM_UPDATE: 'system_update'\n};\n\nfunction logUpdate(type, actorId, serverId, targetType, targetId, changes, reason) {\n  return new Promise((resolve, reject) => {\n    const changesJson = changes ? JSON.stringify(changes) : null;\n    \n    db.run(`\n      INSERT INTO audit_log (action_type, actor_id, server_id, target_type, target_id, changes, reason)\n      VALUES (?, ?, ?, ?, ?, ?, ?)\n    `, [type, actorId, serverId, targetType, targetId, changesJson, reason], function(err) {\n      if (err) {\n        console.error('Failed to log update:', err);\n        reject(err);\n      } else {\n        resolve(this.lastID);\n      }\n    });\n  });\n}\n\nfunction logGlobalUpdate(type, actorId, targetType, targetId, changes, description) {\n  return new Promise((resolve, reject) => {\n    const changesJson = changes ? JSON.stringify(changes) : null;\n    \n    db.run(`\n      INSERT INTO update_log (update_type, actor_id, target_type, target_id, changes, description)\n      VALUES (?, ?, ?, ?, ?, ?)\n    `, [type, actorId, targetType, targetId, changesJson, description], function(err) {\n      if (err) {\n        console.error('Failed to log global update:', err);\n        reject(err);\n      } else {\n        resolve(this.lastID);\n      }\n    });\n  });\n}\n\nfunction getServerLogs(serverId, limit = 100, offset = 0) {\n  return new Promise((resolve, reject) => {\n    db.all(`\n      SELECT al.*, u.username as actor_username\n      FROM audit_log al\n      LEFT JOIN users u ON al.actor_id = u.id\n      WHERE al.server_id = ?\n      ORDER BY al.created_at DESC\n      LIMIT ? OFFSET ?\n    `, [serverId, limit, offset], (err, logs) => {\n      if (err) reject(err);\n      else resolve(logs || []);\n    });\n  });\n}\n\nfunction getGlobalLogs(limit = 100, offset = 0, updateType = null) {\n  return new Promise((resolve, reject) => {\n    let query = `\n      SELECT ul.*, u.username as actor_username\n      FROM update_log ul\n      LEFT JOIN users u ON ul.actor_id = u.id\n    `;\n    const params = [];\n    \n    if (updateType) {\n      query += ' WHERE ul.update_type = ?';\n      params.push(updateType);\n    }\n    \n    query += ' ORDER BY ul.created_at DESC LIMIT ? OFFSET ?';\n    params.push(limit, offset);\n    \n    db.all(query, params, (err, logs) => {\n      if (err) reject(err);\n      else resolve(logs || []);\n    });\n  });\n}\n\nmodule.exports = {\n  UPDATE_TYPES,\n  logUpdate,\n  logGlobalUpdate,\n  getServerLogs,\n  getGlobalLogs\n};\n","path":null,"size_bytes":3531,"size_tokens":null},"frontend/js/iframe-detect.js":{"content":"// Detect if page is loaded in an iframe (OS mode) and hide back buttons\n(function() {\n  if (window.self !== window.top) {\n    // We're in an iframe - add class to hide back buttons\n    document.documentElement.classList.add('in-iframe');\n    document.addEventListener('DOMContentLoaded', function() {\n      document.body.classList.add('in-iframe');\n      \n      // Hide all back buttons and back links\n      const backElements = document.querySelectorAll('.back-btn, .back-link, a[href*=\"dashboard\"], .header .back-btn, .settings-header .back-btn');\n      backElements.forEach(el => {\n        el.style.display = 'none';\n      });\n    });\n  }\n})();\n","path":null,"size_bytes":649,"size_tokens":null},"backend/routes/proxy.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst https = require('https');\nconst http = require('http');\nconst { URL } = require('url');\n\nconst httpAgent = new http.Agent({ keepAlive: true, maxSockets: 50, timeout: 30000 });\nconst httpsAgent = new https.Agent({ keepAlive: true, maxSockets: 50, timeout: 30000 });\n\nrouter.get('/fetch', async (req, res) => {\n  const targetUrl = req.query.url;\n  \n  if (!targetUrl) {\n    return res.status(400).json({ error: 'URL parameter required' });\n  }\n  \n  try {\n    const parsedUrl = new URL(targetUrl);\n    const isHttps = parsedUrl.protocol === 'https:';\n    const protocol = isHttps ? https : http;\n    const agent = isHttps ? httpsAgent : httpAgent;\n    \n    const proxyReq = protocol.request(parsedUrl, {\n      method: 'GET',\n      agent: agent,\n      timeout: 15000,\n      headers: {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'Accept-Language': 'en-US,en;q=0.5',\n        'Accept-Encoding': 'identity',\n        'Connection': 'keep-alive',\n        'Upgrade-Insecure-Requests': '1'\n      }\n    }, (proxyRes) => {\n      const contentType = proxyRes.headers['content-type'] || 'text/html';\n      \n      res.set({\n        'Content-Type': contentType,\n        'X-Proxy-Status': proxyRes.statusCode,\n        'X-Final-URL': parsedUrl.href\n      });\n      \n      proxyRes.on('error', (err) => {\n        console.error('Proxy response error:', err);\n        if (!res.headersSent) {\n          res.status(502).json({ error: 'Upstream error', details: err.message });\n        } else {\n          res.destroy();\n        }\n      });\n\n      if (contentType.includes('text/html')) {\n        let data = [];\n        proxyRes.on('data', chunk => data.push(chunk));\n        proxyRes.on('end', () => {\n          const buffer = Buffer.concat(data);\n          let html = buffer.toString('utf-8');\n          const origin = parsedUrl.origin;\n          const proxyBase = '/api/proxy/fetch?url=';\n          \n          const baseTag = `<base href=\"${origin}/\">`;\n          html = html.replace(/<head>/i, `<head>${baseTag}`);\n          \n          html = html.replace(/href=\"(https?:\\/\\/[^\"]+)\"/g, (match, url) => {\n            return `href=\"${proxyBase}${encodeURIComponent(url)}\"`;\n          });\n          html = html.replace(/src=\"(https?:\\/\\/[^\"]+)\"/g, (match, url) => {\n            return `src=\"${proxyBase}${encodeURIComponent(url)}\"`;\n          });\n          html = html.replace(/href='(https?:\\/\\/[^']+)'/g, (match, url) => {\n            return `href='${proxyBase}${encodeURIComponent(url)}'`;\n          });\n          html = html.replace(/src='(https?:\\/\\/[^']+)'/g, (match, url) => {\n            return `src='${proxyBase}${encodeURIComponent(url)}'`;\n          });\n          \n          res.send(html);\n        });\n      } else {\n        proxyRes.pipe(res);\n        proxyRes.on('end', () => res.end());\n      }\n    });\n    \n    proxyReq.on('error', (err) => {\n      if (!res.headersSent) {\n        res.status(500).json({ error: 'Proxy request failed', details: err.message });\n      } else {\n        res.destroy();\n      }\n    });\n    \n    proxyReq.on('timeout', () => {\n      proxyReq.destroy();\n      if (!res.headersSent) {\n        res.status(504).json({ error: 'Request timeout' });\n      }\n    });\n    \n    proxyReq.end();\n  } catch (err) {\n    res.status(500).json({ error: 'Invalid URL', details: err.message });\n  }\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":3598,"size_tokens":null},"frontend/js/cloak.js":{"content":"const CloakManager = {\n  CLOAK_ICON: 'https://play-lh.googleusercontent.com/ujsa1M8GdT-fo-GfPazpUwgPXVWEOWKUgKZk-SdnUhmcL3opS24MiHe6ypEgqxGpllw',\n  CLOAK_TITLE: 'My Apps',\n  \n  getSettings() {\n    return JSON.parse(localStorage.getItem('cloakSettings') || '{}');\n  },\n  \n  saveSettings(settings) {\n    localStorage.setItem('cloakSettings', JSON.stringify(settings));\n  },\n  \n  applyTabCloak() {\n    const settings = this.getSettings();\n    if (settings.tabCloak) {\n      document.title = this.CLOAK_TITLE;\n      let link = document.querySelector(\"link[rel*='icon']\") || document.createElement('link');\n      link.type = 'image/png';\n      link.rel = 'shortcut icon';\n      link.href = this.CLOAK_ICON;\n      document.getElementsByTagName('head')[0].appendChild(link);\n    }\n  },\n  \n  openInAboutBlank() {\n    const currentUrl = window.location.href;\n    const newWindow = window.open('about:blank', '_blank');\n    if (newWindow) {\n      newWindow.document.write(`\n        <!DOCTYPE html>\n        <html>\n        <head>\n          <title>${this.CLOAK_TITLE}</title>\n          <link rel=\"icon\" href=\"${this.CLOAK_ICON}\">\n          <style>\n            body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; }\n            iframe { width: 100%; height: 100%; border: none; }\n          </style>\n        </head>\n        <body>\n          <iframe src=\"${currentUrl}\" allowfullscreen></iframe>\n        </body>\n        </html>\n      `);\n      newWindow.document.close();\n      window.close();\n    }\n  },\n  \n  openInBlob() {\n    const currentUrl = window.location.href;\n    const html = `\n      <!DOCTYPE html>\n      <html>\n      <head>\n        <title>${this.CLOAK_TITLE}</title>\n        <link rel=\"icon\" href=\"${this.CLOAK_ICON}\">\n        <style>\n          body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; }\n          iframe { width: 100%; height: 100%; border: none; }\n        </style>\n      </head>\n      <body>\n        <iframe src=\"${currentUrl}\" allowfullscreen></iframe>\n      </body>\n      </html>\n    `;\n    const blob = new Blob([html], { type: 'text/html' });\n    const blobUrl = URL.createObjectURL(blob);\n    window.open(blobUrl, '_blank');\n    window.close();\n  },\n  \n  checkAutoCloak() {\n    const settings = this.getSettings();\n    if (settings.autoCloak === 'aboutblank' && !window.location.href.includes('about:blank') && !sessionStorage.getItem('cloaked')) {\n      sessionStorage.setItem('cloaked', 'true');\n      this.openInAboutBlank();\n      return true;\n    }\n    if (settings.autoCloak === 'blob' && !window.location.protocol.includes('blob') && !sessionStorage.getItem('cloaked')) {\n      sessionStorage.setItem('cloaked', 'true');\n      this.openInBlob();\n      return true;\n    }\n    return false;\n  },\n  \n  init() {\n    if (!this.checkAutoCloak()) {\n      this.applyTabCloak();\n    }\n  }\n};\n\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => CloakManager.init());\n} else {\n  CloakManager.init();\n}\n","path":null,"size_bytes":2988,"size_tokens":null},"frontend/js/customization.js":{"content":"const Customization = {\n  customCursors: {\n    neon: 'data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\"><circle cx=\"12\" cy=\"12\" r=\"8\" fill=\"none\" stroke=\"%2300ffff\" stroke-width=\"2\"/><circle cx=\"12\" cy=\"12\" r=\"3\" fill=\"%2300ffff\"/></svg>',\n    retro: 'data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\"><rect width=\"4\" height=\"4\" fill=\"%23000\"/><rect x=\"4\" y=\"4\" width=\"4\" height=\"4\" fill=\"%23000\"/><rect x=\"8\" y=\"8\" width=\"4\" height=\"4\" fill=\"%23000\"/><rect x=\"12\" y=\"12\" width=\"4\" height=\"4\" fill=\"%23000\"/></svg>',\n    minimal: 'data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"12\"><circle cx=\"6\" cy=\"6\" r=\"5\" fill=\"%23fff\" stroke=\"%23000\" stroke-width=\"1\"/></svg>'\n  },\n\n  soundEffects: {\n    chime: [523.25, 659.25, 783.99],\n    pop: [880],\n    ding: [1046.5],\n    swoosh: [200, 400, 600],\n    bubble: [300, 450],\n    bell: [440, 554.37, 659.25],\n    click: [1000],\n    tap: [800],\n    soft: [400]\n  },\n\n  audioContext: null,\n\n  init() {\n    this.applyCursor();\n    this.setupClickSounds();\n  },\n\n  applyCursor(style) {\n    style = style || localStorage.getItem('cursorStyle') || 'default';\n    if (this.customCursors[style]) {\n      document.body.style.cursor = `url(\"${this.customCursors[style]}\") 12 12, auto`;\n    } else if (style === 'default') {\n      document.body.style.cursor = '';\n    } else {\n      document.body.style.cursor = style;\n    }\n  },\n\n  getAudioContext() {\n    if (!this.audioContext) {\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    }\n    return this.audioContext;\n  },\n\n  playTone(frequencies, duration = 0.1) {\n    if (localStorage.getItem('soundsEnabled') === 'false') return;\n    \n    const ctx = this.getAudioContext();\n    const volume = (parseInt(localStorage.getItem('soundVolume') || '50')) / 100;\n    \n    frequencies.forEach((freq, i) => {\n      const osc = ctx.createOscillator();\n      const gain = ctx.createGain();\n      osc.connect(gain);\n      gain.connect(ctx.destination);\n      osc.frequency.value = freq;\n      osc.type = 'sine';\n      gain.gain.value = volume * 0.3;\n      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);\n      osc.start(ctx.currentTime + (i * 0.05));\n      osc.stop(ctx.currentTime + duration + (i * 0.05));\n    });\n  },\n\n  playNotification() {\n    const sound = localStorage.getItem('notifSound') || 'chime';\n    if (this.soundEffects[sound]) {\n      this.playTone(this.soundEffects[sound]);\n    }\n  },\n\n  playClick() {\n    const sound = localStorage.getItem('clickSound') || 'none';\n    if (sound !== 'none' && this.soundEffects[sound]) {\n      this.playTone(this.soundEffects[sound], 0.05);\n    }\n  },\n\n  setupClickSounds() {\n    document.addEventListener('click', (e) => {\n      if (e.target.matches('button, .btn, .app-card, .setting-btn, a')) {\n        this.playClick();\n      }\n    });\n  }\n};\n\ndocument.addEventListener('DOMContentLoaded', () => Customization.init());\n","path":null,"size_bytes":3003,"size_tokens":null},"backend/routes/ai-chat.js":{"content":"const express = require('express');\nconst router = express.Router();\n\nconst OPENAI_API_KEY = process.env.OPENAI_API_KEY;\n\nconst SYSTEM_PROMPT = `You are Nova, a friendly and helpful AI assistant for the NebulaCore Learning Portal. You're designed to help K-12 students with their studies, answer questions, and provide support.\n\nGuidelines:\n- Be conversational, warm, and encouraging\n- Keep responses concise but helpful (2-4 sentences when possible)\n- Use simple language appropriate for students\n- If asked about inappropriate topics, gently redirect to educational content\n- You can help with homework, explain concepts, suggest study tips, or just chat\n- Add occasional emojis to be friendly but don't overdo it\n- Never reveal you are ChatGPT or mention OpenAI - you are Nova`;\n\nrouter.post('/', async (req, res) => {\n  try {\n    const { messages } = req.body;\n    \n    if (!messages || !Array.isArray(messages)) {\n      return res.status(400).json({ error: 'Messages array required' });\n    }\n\n    if (!OPENAI_API_KEY) {\n      return res.status(500).json({ error: 'AI service not configured' });\n    }\n\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${OPENAI_API_KEY}`\n      },\n      body: JSON.stringify({\n        model: 'gpt-4o-mini',\n        messages: [\n          { role: 'system', content: SYSTEM_PROMPT },\n          ...messages\n        ],\n        max_tokens: 500,\n        temperature: 0.7\n      })\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      console.error('OpenAI API error:', errorData);\n      return res.status(500).json({ error: 'AI service error' });\n    }\n\n    const data = await response.json();\n    const aiMessage = data.choices?.[0]?.message?.content || 'Sorry, I couldn\\'t generate a response.';\n\n    res.json({ message: aiMessage });\n  } catch (error) {\n    console.error('AI chat error:', error);\n    res.status(500).json({ error: 'Failed to process request' });\n  }\n});\n\nmodule.exports = router;\n","path":null,"size_bytes":2129,"size_tokens":null}},"version":2}